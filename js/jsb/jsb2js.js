anonymousFunc = function () {
    window.cachedFileNames["jsb2js"] = "jsb2js"
    if (!window.cached_jsb2js) window.cached_jsb2js = {}
    var z = "Subroutine Assment\xFE";
    z += "*\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "    Hardcode = 1\xFE";
    z += "    R = savetk()\xFE";
    z += "\xFE";
    z += "    Vattr = parsevar(1, 1, C_equal, 1)\xFE";
    z += "\xFE";
    z += "    ' Object Store?\xFE";
    z += "    If Index(C_equal:C_plus:C_minus:C_less:C_fslash:C_asterisk:C_percent:C_colon, Tkno, 1) = 0 Then Call Objectparse(Vattr)\xFE";
    z += "* \xFE";
    z += "* <A, V, SV> ?\xFE";
    z += "*\xFE";
    z += "    Avs = Lddynadr()\xFE";
    z += "    \xFE";
    z += "    If Instr(\"+-*/:%\", Tkstr) Then\xFE";
    z += "        Op = Tkstr\xFE";
    z += "        Call Restoret(R)\xFE";
    z += "        Pattr = Atom(Vattr.SYM_TYPE, C_equal:C_plus:C_minus:C_less:C_fslash:C_asterisk:C_percent:C_colon)\xFE";
    z += "        If Op = Tkstr Then Call Tcv(False) Else Err(\"error\")\xFE";
    z += "    Else\xFE";
    z += "        Op = \"\"\xFE";
    z += "    End If\xFE";
    z += "\xFE";
    z += "    If (Tkno = C_plus And Op = \"+\") Or (Tkno = C_minus And Op = \"-\") Then\xFE";
    z += "        Gattr = {}\xFE";
    z += "        Gattr.SYM_C = \"1\"\xFE";
    z += "        Gattr.SYM_TYPE = Type_cnum\xFE";
    z += "        Call Tcv(False)\xFE";
    z += "    Else\xFE";
    z += "        *\xFE";
    z += "        * If typing variables, check for A = A: (makes it a string)\xFE";
    z += "        *\xFE";
    z += "        If Outputtypes And Vattr.SYM_TYPE = Type_var Then\xFE";
    z += "            If Not(Index(Vattr.SYM_TYPES,Type_vstr,1)) Then\xFE";
    z += "                Htk = savetk()\xFE";
    z += "                Gattr = Expr(Type_vstr, 1, C_colon)\xFE";
    z += "                If Gattr.SYM_C = Vattr.SYM_C And Tkno = C_colon Then\xFE";
    z += "                    Vattr.SYM_TYPES=Vattr.SYM_TYPES:Type_vstr\xFE";
    z += "                    Call Writevsym(Vattr.SYM_TYPES,Vattr.SYMNAME, \"SYM_TYPES\")\xFE";
    z += "                End\xFE";
    z += "                Call Restoret(Htk)\xFE";
    z += "            End\xFE";
    z += "        End\xFE";
    z += "\xFE";
    z += "        If Tkno = C_equal Then Call Tcv(False) Else Call Err('assignment = expected')\xFE";
    z += "        \xFE";
    z += "        *\xFE";
    z += "        * expr\xFE";
    z += "        *\xFE";
    z += "        Gattr = Expr(Vattr.SYM_TYPE, 1, '')\xFE";
    z += "    End If\xFE";
    z += "\xFE";
    z += "    If Avs # '' Then\xFE";
    z += "        * Makes it a string\xFE";
    z += "        If Not(Index(Vattr.SYM_TYPES,Type_vstr,1)) Then\xFE";
    z += "            Vattr.SYM_TYPES=Vattr.SYM_TYPES:Type_vstr\xFE";
    z += "            Call Writevsym(Vattr.SYM_TYPES,Vattr.SYMNAME, \"SYM_TYPES\")\xFE";
    z += "        End\xFE";
    z += "        Call Typestr(Type_vstr, Gattr)\xFE";
    z += "        Gattr.SYM_C = \"Replace(\":Vattr.SYM_C:\",\":Avs:\",\":Gattr.SYM_C:\")\"\xFE";
    z += "    End\xFE";
    z += "*\xFE";
    z += "    If Op = \":\" Then\xFE";
    z += "        Call Makestr(Type_estr, Gattr)\xFE";
    z += "        if !Pattr.SYM_ASSIGNED Then Pattr.SYM_C = \"CStr(\":Pattr.SYM_C:\")\"\xFE";
    z += "        Gattr.SYM_C = Pattr.SYM_C:\" + \":Gattr.SYM_C\xFE";
    z += "        \xFE";
    z += "    Else If Op = \"+\" Then\xFE";
    z += "        Call Makenum(Type_eNum, Gattr)\xFE";
    z += "        Gattr.SYM_C = Pattr.SYM_C:\" \":Op:\" \":Gattr.SYM_C\xFE";
    z += "        \xFE";
    z += "    Else If Op = \"-\" And Instr(Gattr.SYM_C, \"+\") = 0 And Instr(Gattr.SYM_C, \"-\") = 0 Then\xFE";
    z += "        Call Makenum(Type_eNum, Gattr)\xFE";
    z += "        Gattr.SYM_C = Pattr.SYM_C:\" \":Op:\" \":Gattr.SYM_C\xFE";
    z += "        \xFE";
    z += "    Else If Op Then\xFE";
    z += "        Call Makenum(Type_eNum, Gattr)\xFE";
    z += "        Gattr.SYM_C = Pattr.SYM_C:\" \":Op:\" (\":Gattr.SYM_C:\")\"\xFE";
    z += "    End If\xFE";
    z += "        \xFE";
    z += "    Call Store(Vattr, Gattr)\xFE";
    z += "    Return\xFE";
    z += "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "* Vattr = Eattr (Stored in Vattr)\xFE";
    z += "*\xFE";
    z += "Subroutine Store(byval Vattr, byval Eattr)\xFE";
    z += "*\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "    If Vattr.SYM_ISCONST Then\xFE";
    z += "        Call Err('Variable is CONST, assignment not possible')\xFE";
    z += "    End\xFE";
    z += "*\xFE";
    z += "    Dimarray = Vattr.SYM_INDEX1 Or Vattr.SYM_INDEX2\xFE";
    z += "    If Dimarray Then\xFE";
    z += "        Call Err(\"MATSTORE not possible\")\xFE";
    z += "        Return\xFE";
    z += "    End\xFE";
    z += "*\xFE";
    z += "* Attempt to Fix UBOUND on empty Array.  A[UBound(A)] should return 1 if A is an empty array.  But A[UBound(A) + 1] should return 0\xFE";
    z += "*\xFE";
    z += "    If Instr(Vattr.SYM_C, \"[UBound(\") And Instr(Vattr.SYM_C, \")]\") Then\xFE";
    z += "        Vattr.SYM_C = Replace(Vattr.SYM_C, \"[UBound(\", \"[UBound1(\")\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    * Change \"At_Application.Item(X) = Y\" into \"At_Application.Item(X, Y) = Y\"\xFE";
    z += "    Vlen = Len(Vattr.SYM_C)\xFE";
    z += "    If (Left(Vattr.SYM_C, 16) = \"At_Session.Item(\" Or Left(Vattr.SYM_C, 20) = \"At_Application.Item(\") And Right(Vattr.SYM_C, 1) = \")\" Then\xFE";
    z += "        Vattr.SYM_C = Left(Vattr.SYM_C, Vlen-1)\xFE";
    z += "        Oc = Oc:Vattr.SYM_C:\", \":Eattr.SYM_C:'); '\xFE";
    z += "        Return\xFE";
    z += "    End If\xFE";
    z += "\xFE";
    z += "    * Record types of assignments to variables so we can optionally type them later\xFE";
    z += "    If Vattr.SYM_TYPE = Type_var Then\xFE";
    z += "        Dtype = Eattr.SYM_TYPE\xFE";
    z += "\xFE";
    z += "        If Eattr.SYM_TYPE = Type_var Then\xFE";
    z += "            If Index(Eattr.SYM_TYPES,Type_var,1) Then\xFE";
    z += "                Dtype = Type_vstr\xFE";
    z += "            End Else If Index(Eattr.SYM_TYPES,Type_vstr,1) Then\xFE";
    z += "                Dtype = Type_vstr\xFE";
    z += "            End Else\xFE";
    z += "                Dtype = \"\"\xFE";
    z += "            End\xFE";
    z += "        End\xFE";
    z += "        If Dtype <> \"\" Then\xFE";
    z += "            If Index(Vattr.SYM_TYPES,Dtype,1) = 0 Then\xFE";
    z += "                Vattr.SYM_TYPES = Vattr.SYM_TYPES:Dtype\xFE";
    z += "                Call Writevsym(Vattr.SYM_TYPES, Vattr.SYMNAME,  \"SYM_TYPES\")\xFE";
    z += "            End\xFE";
    z += "        End\xFE";
    z += "    End\xFE";
    z += "    \xFE";
    z += "    if !Vattr.SYM_ASSIGNED Then\xFE";
    z += "        Vattr.SYM_ASSIGNED = True\xFE";
    z += "        Call Writevsym(True, Vattr.SYMNAME,  \"SYM_ASSIGNED\")\xFE";
    z += "    end if\xFE";
    z += "    \xFE";
    z += "    * Do auto conversion of Eattr to the storage type of Vattr\xFE";
    z += "    Call MakeAFromB(Eattr, Vattr)\xFE";
    z += "    \xFE";
    z += "    * Do we have A = A + ... ?  Convert to A += ...\xFE";
    z += "    Op = Eattr.SYM_C[Vlen+1,1]\xFE";
    z += "    If Op = \" \" Then\xFE";
    z += "        Op = Eattr.SYM_C[Vlen+2,1]\xFE";
    z += "        Nlen = Vlen + 3\xFE";
    z += "    Else\xFE";
    z += "        Nlen = Vlen + 2\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    If Vattr.SYM_C = Eattr.SYM_C[1,Vlen] And Index(' +-',Op,1)>1 Then\xFE";
    z += "        Eattr.SYM_C = LTrim(Eattr.SYM_C[Nlen,99999])\xFE";
    z += "        If Eattr.SYM_C = \"1\" Then\xFE";
    z += "            If Op = \"+\" Then\xFE";
    z += "                Oc=Oc:Vattr.SYM_C:'++; '\xFE";
    z += "            End Else\xFE";
    z += "                Oc=Oc:Vattr.SYM_C:'--; '\xFE";
    z += "            End\xFE";
    z += "            \xFE";
    z += "        End Else If Op = \"+\" Then\xFE";
    z += "            Oc = Oc:Vattr.SYM_C:' ':Op:'= ':Eattr.SYM_C:'; '\xFE";
    z += "            \xFE";
    z += "        End Else If Index(\"&|^\",Op,1) Then\xFE";
    z += "            Oc = Oc:Vattr.SYM_C:' ':Op:'= (':Eattr.SYM_C:'); '\xFE";
    z += "            \xFE";
    z += "        End Else\xFE";
    z += "            If Index(Eattr.SYM_C,'+',1) Or Index(Eattr.SYM_C,'-',1) Then\xFE";
    z += "                Oc = Oc:Vattr.SYM_C:' = ':Vattr.SYM_C:Op:Eattr.SYM_C:'; '\xFE";
    z += "            End Else\xFE";
    z += "                Oc = Oc:Vattr.SYM_C:' ':Op:'= ':Eattr.SYM_C:'; '\xFE";
    z += "            End\xFE";
    z += "        End\xFE";
    z += "        \xFE";
    z += "        Return\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    If Index(Eattr.SYM_C,'&',1) Or Index(Eattr.SYM_C,'|',1) Then\xFE";
    z += "        Oc = Oc:Vattr.SYM_C:' = (':Eattr.SYM_C:'); '\xFE";
    z += "    End Else\xFE";
    z += "        Oc = Oc:Vattr.SYM_C:' = ':Eattr.SYM_C:'; '\xFE";
    z += "    End\xFE";
    z += "\xFE";
    z += "    Return"
    window.cached_jsb2js["assment"] = z;
    var z = "*********************************************************************************************************************\xFE";
    z += "// Return Rtnattr\xFE";
    z += "*\xFE";
    z += "function Docall(ByVal Isfunc, Optional ByVal xTraParams)\xFE";
    z += "*\xFE";
    z += "* Build and return RTNATTR\xFE";
    z += "*\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "\xFE";
    z += "    myValidTypes = 'v?cnbs$' // if not in this list, then need to swap through interChangeTypesChars\xFE";
    z += "\xFE";
    z += "    *                   v (variant), s (string), b (boolean), n (real/number), i (integer), j (json), a (array), ? (object), l (select-list), f (filehandle), m (mat array)\xFE";
    z += "    interChangeTypesChars  = 'vsbnija?lfm'\xFE";
    z += "    interChangeTypes = [Type_var,    Type_estr,  Type_eBool,  Type_eNum,       Type_eNum,   Type_var, Type_var,  Type_var,   Type_var,        Type_var,       Type_var]\xFE";
    z += "    \xFE";
    z += "    ByRefScript = []\xFE";
    z += "    Parami = 0\xFE";
    z += "    Mytmpvari = Tmpvari\xFE";
    z += "    If Mytmpvari = 0 Then Mytmpvari = \"\"\xFE";
    z += "    Tmpvari = Tmpvari + 1\xFE";
    z += "    needCallDef = False\xFE";
    z += "    PrmList = \"\"\xFE";
    z += "    noByRefParams = False\xFE";
    z += "    Isatat = false\xFE";
    z += "    isCallAt = false\xFE";
    z += "    dblParen = false\xFE";
    z += "    Rtnattr = {}\xFE";
    z += "    Ignoremissingcall = False\xFE";
    z += "    hasLiteralFName = False\xFE";
    z += "    callNameIsLiteral = False\xFE";
    z += "\xFE";
    z += "    If Tkno = C_at Then\xFE";
    z += "        Call Tcv(False) ;* Skip @\xFE";
    z += "        //If Tkstr = \"AM\" Or Tkstr = \"VM\" Or Tkstr = \"SVM\" Or Tkstr = \"CRLF\" Or Tkstr = \"LF\" Or Tkstr = \"CR\" Then\xFE";
    z += "            Rtnattr = Dofuncs(Type_estr, True)\xFE";
    z += "            If Rtnattr Then Return Rtnattr\xFE";
    z += "            Rtnattr = {}\xFE";
    z += "        //End If\xFE";
    z += "        \xFE";
    z += "        ' @@rpcRequest CALL(x) ?\xFE";
    z += "        If Tkno = C_at Then\xFE";
    z += "            Call Tcv(False) ;* Skip @\xFE";
    z += "            If Tkno = C_question Then\xFE";
    z += "                Ignoremissingcall = True\xFE";
    z += "                Call Tcv(False) ;* Skip @\xFE";
    z += "            End If\xFE";
    z += "            Isatat = 1\xFE";
    z += "            Cname = Tkstr\xFE";
    z += "            callNameIsLiteral = True ;* @@odbName(x)\xFE";
    z += "            firstTkStr = Tkstr\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "            \xFE";
    z += "        Else\xFE";
    z += "            If Tkno = C_question Then \xFE";
    z += "                Call Tcv(False) \xFE";
    z += "                Ignoremissingcall = True\xFE";
    z += "            End if\xFE";
    z += "            \xFE";
    z += "            //  Call @variable(params)\xFE";
    z += "            //  x = @literal(...)\xFE";
    z += "            //  x = @(variable)(params)\xFE";
    z += "            //  x = @literal.literal()\xFE";
    z += "            \xFE";
    z += "            // @((varname))?\xFE";
    z += "            If Tkno = C_lparen Then \xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                isCallAt = True\xFE";
    z += "                \xFE";
    z += "                If Tkno = C_lparen Then \xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    firstTkStr = Tkstr\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    If Tkno = C_rparen Then Call Tcv(False) Else Call Err(') expected')\xFE";
    z += "                    If Tkno = C_rparen Then Call Tcv(False) Else Call Err(') expected')\xFE";
    z += "                Else\xFE";
    z += "                    firstTkStr = Tkstr\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    If Tkno <> C_rparen Then Call Err(') expected')\xFE";
    z += "                end if\xFE";
    z += "                \xFE";
    z += "            ElseIf Ignoremissingcall Or !isFunc Then\xFE";
    z += "                firstTkStr = Tkstr\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                \xFE";
    z += "                If Tkstr <> Mobjectdelemeter Then\xFE";
    z += "                    isCallAt = True // Call @variable() - but could be Call @file.sub\xFE";
    z += "                    Pattr = Readsym(firstTkStr)\xFE";
    z += "                    Cname = Pattr.SYM_C\xFE";
    z += "                End If\xFE";
    z += "\xFE";
    z += "            Else\xFE";
    z += "                // @Literal() or @Literal.Literal\xFE";
    z += "                firstTkStr = Tkstr\xFE";
    z += "                callNameIsLiteral = True\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "            End If\xFE";
    z += "            \xFE";
    z += "            If isCallAt Then // @variable(xxx)\xFE";
    z += "                Pattr =  Readsym(firstTkStr)\xFE";
    z += "                Cname = Pattr.SYM_C\xFE";
    z += "\xFE";
    z += "            ElseIf Tkstr = Mobjectdelemeter Then\xFE";
    z += "                hasLiteralFName = True\xFE";
    z += "            End If\xFE";
    z += "        End If\xFE";
    z += "\xFE";
    z += "    End Else\xFE";
    z += "        // could be json.xxx?\xFE";
    z += "        Ignoremissingcall = Tkno = C_question\xFE";
    z += "        If Ignoremissingcall Then Call Tcv(False) ;* Call ?Literal\xFE";
    z += "        firstTkStr = Tkstr\xFE";
    z += "        callNameIsLiteral = True\xFE";
    z += "        Call Tcv(False)\xFE";
    z += "        If Tkstr = Mobjectdelemeter Then hasLiteralFName = True\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    if Isfunc Then \xFE";
    z += "        xrefSuffix = \"_fnc.def\" \xFE";
    z += "        CNameSuffix = \"\"\xFE";
    z += "    Else \xFE";
    z += "        xrefSuffix = \".def\"\xFE";
    z += "        CNameSuffix = \"_Sub\"\xFE";
    z += "    End If\xFE";
    z += "\xFE";
    z += "    if isAtAt Then\xFE";
    z += "    \xFE";
    z += "    Else If hasLiteralFName Then\xFE";
    z += "        Call Tcv(False) ;* Skip \".\"\xFE";
    z += "        \xFE";
    z += "        FName = UCase(Cspc_truefilename(firstTkStr))\xFE";
    z += "        shortCallName = TKStr\xFE";
    z += "\xFE";
    z += "        Locate TKStr In UC_externals_purejs_list Setting X Then\xFE";
    z += "            standardJSCall =  True\xFE";
    z += "            CallDef = { SUB_SUBNAME: UC_externals_purejs_list<X>, SUB_CNAME: externals_purejs_list<X>, SUB_ISFUNCTION: isFunc, SUB_NOAWAITSALLOWED: true, SUB_PARAMTYPES: '' }\xFE";
    z += "            Cname = externals_purejs_list<X>\xFE";
    z += "        else\xFE";
    z += "            subTkStr = Makesubname(TKStr)\xFE";
    z += "            Cname = FName:\"_\":subTkStr:CNameSuffix\xFE";
    z += "            CallDef = readXRef(Cname:xrefSuffix)\xFE";
    z += "            if !CallDef Then needCallDef = True\xFE";
    z += "        end if\xFE";
    z += "        Call Tcv(False)\xFE";
    z += "        \xFE";
    z += "    else If callNameIsLiteral Then\xFE";
    z += "        // if callNameIsLiteral then firstTkStr is valid\xFE";
    z += "        \xFE";
    z += "\xFE";
    z += "        // Look up any previous compile on this routine\xFE";
    z += "        FName = UCase(pcfname) \xFE";
    z += "        shortCallName = firstTkStr\xFE";
    z += "        subTkStr = Makesubname(firstTkStr)\xFE";
    z += "        Cname = FName:\"_\":subTkStr:CNameSuffix\xFE";
    z += "        CallDef = readXRef(Cname:xrefSuffix)\xFE";
    z += "        \xFE";
    z += "        if !CallDef Then \xFE";
    z += "            FName = \"JSB_BF\"\xFE";
    z += "            Cname = FName:\"_\":subTkStr:CNameSuffix\xFE";
    z += "            CallDef = readXRef(Cname:xrefSuffix)\xFE";
    z += "        end if\xFE";
    z += "        \xFE";
    z += "        if !CallDef Then \xFE";
    z += "            FName = \"JSB_HTML\"\xFE";
    z += "            Cname = FName:\"_\":subTkStr:CNameSuffix\xFE";
    z += "            CallDef = readXRef(Cname:xrefSuffix)\xFE";
    z += "        End If\xFE";
    z += "        \xFE";
    z += "        // Look first in config_jsb2js\xFE";
    z += "        Locate firstTkStr In UC_externals_purejs_list Setting X Then\xFE";
    z += "            standardJSCall =  True\xFE";
    z += "            cName = externals_purejs_list<X>\xFE";
    z += "            if !CallDef Then CallDef = { SUB_SUBNAME: UC_externals_purejs_list<X>, SUB_ISFUNCTION: isFunc, SUB_NOAWAITSALLOWED: true, SUB_PARAMTYPES: '' }\xFE";
    z += "            CallDef.SUB_CNAME = cName\xFE";
    z += "        Else\xFE";
    z += "            if !CallDef Then CallDef = {}\xFE";
    z += "            if !CallDef.SUB_CNAME Then\xFE";
    z += "                read x from fHandle('JSB_HTML'), subTkStr Then \xFE";
    z += "                    FName = 'JSB_HTML' \xFE";
    z += "                Else\xFE";
    z += "                    read x from fHandle('JSB_BF'), subTkStr Then \xFE";
    z += "                        FName = 'JSB_BF' \xFE";
    z += "                    Else\xFE";
    z += "                        FName = Cur_realfname\xFE";
    z += "                    end if\xFE";
    z += "                end if\xFE";
    z += "    \xFE";
    z += "                needCallDef = True\xFE";
    z += "                FName = UCase(pcfname) \xFE";
    z += "                Cname = FName:\"_\":subTkStr:CNameSuffix\xFE";
    z += "            end if\xFE";
    z += "        end if\xFE";
    z += "        \xFE";
    z += "    end If\xFE";
    z += "    \xFE";
    z += "    if needCallDef Then\xFE";
    z += "        myFuncType = calcAppendage(functionType)\xFE";
    z += "        if !myFuncType Then myFuncType = \"_fnc\"\xFE";
    z += "\xFE";
    z += "        CallDef = { SUB_COMPILEDATE: \"Referenced by \":Pcfname:\" \":Itemid:\" on \":DateTime(), \xFE";
    z += "                 SUB_FNAME: LCase(FName),\xFE";
    z += "                 SUB_CNAME: Cname, \xFE";
    z += "                 SUB_SUBNAME: shortCallName, \xFE";
    z += "                 SUB_ISFUNCTION: 1,       // -1) COMMONS, 0) PROGRAM, 1) SUBROUTINE, 2) FUNCTION, 3) @@FUNCTION, 4) PICK/RESTFUL FUNCTION \xFE";
    z += "                 SUB_NOAWAITSALLOWED: NotASyncFunction, \xFE";
    z += "                 SUB_PARAMTYPES: '',\xFE";
    z += "                 SUB_RTNTYPE: '',\xFE";
    z += "                 SUB_OPTIONALPARAMCNT: 0,\xFE";
    z += "                 SUB_ISCALLEDBY: LCase(Pcfname:\"*\":Itemid:\"*\":Pcfname:\"_\":subName:\"*\":Pcfname:\"_\":subName:myFuncType)\xFE";
    z += "        }\xFE";
    z += "        if isFunc Then CallDef.SUB_ISFUNCTION = 2\xFE";
    z += "    Else\xFE";
    z += "        if !CallDef Then CallDef = {}\xFE";
    z += "        if CallDef.SUB_CNAME Then CName = CallDef.SUB_CNAME\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    // if we are not defined as a asyn function, then we can't call any functions that are\xFE";
    z += "    if NotASyncFunction And !CallDef.SUB_NOAWAITSALLOWED Then Call Warning(\"A call to an async function from a non-async function.  Add IJS or ASYNC- to \":Cname:\" or remove it from this function\")\xFE";
    z += "    if Isatat And NotASyncFunction Then Call Err(subName:' can not be an IJS function and use @@functions')\xFE";
    z += "    if CallDef.SUB_ISEXTERNAL Then standardJSCall = True\xFE";
    z += "\xFE";
    z += "*\xFE";
    z += "* LOOP ON EACH PARAMETER AND BUILD PrmList...(EXPR, EXPR, VAR, ETC)\xFE";
    z += "*\xFE";
    z += "    Needlp = Tkno = C_lparen\xFE";
    z += "    Cbadr = \"\"\xFE";
    z += "    ParamCnt = 0\xFE";
    z += "    ParamTypes = Split(CallDef.SUB_PARAMTYPES, \",\")\xFE";
    z += "    Byreffparams = ''\xFE";
    z += "    \xFE";
    z += "    If Needlp Then\xFE";
    z += "        Call Tcv(False) ;* Skip (\xFE";
    z += "        La = La:C_comma\xFE";
    z += "        \xFE";
    z += "        ' STOP WHEN WE GET TO A \")\"\xFE";
    z += "        Loop While Tkno <> C_rparen Do\xFE";
    z += "            ParamI += 1\xFE";
    z += "            *\xFE";
    z += "            * DETERMINE THE TYPE OF PARAMETER: (ByVal - Upper Case, ByRef - lower Case)\xFE";
    z += "            *    s (string), v (variant), b (boolean), n (real/number), i (integer), j (json), a (array), ? (object), l (select-list)\xFE";
    z += "            *\xFE";
    z += "            if isCallAt Or isAtAt Then\xFE";
    z += "                Expectingtype = 'V'\xFE";
    z += "                if tkstr = \"BYREF\" Then\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    Expectingtype = 'v'\xFE";
    z += "                    \xFE";
    z += "                ElseIf tkstr = \"BYVAL\" Then\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                End If\xFE";
    z += "                    \xFE";
    z += "            Else If needCallDef Then\xFE";
    z += "                If Tkno=C_mat Then \xFE";
    z += "                    Call Tcv(False) \xFE";
    z += "                    holdTK = Savetk()\xFE";
    z += "                    Pattr = matLoad() // sets global MatLoadSize\xFE";
    z += "                    Expectingtype = MatLoadSize\xFE";
    z += "                    Call Restoret(holdTK)\xFE";
    z += "                Else\xFE";
    z += "                    Expectingtype = 'v'\xFE";
    z += "                End if\xFE";
    z += "    \xFE";
    z += "                ParamTypes[Parami] = Expectingtype \xFE";
    z += "                CallDef.SUB_PARAMTYPES = Join(ParamTypes, \",\")\xFE";
    z += "                \xFE";
    z += "            End Else\xFE";
    z += "                Expectingtype = ParamTypes[Parami]\xFE";
    z += "                if !Expectingtype And !standardJSCall Then \xFE";
    z += "                    debug\xFE";
    z += "                    Call Warning(\"too many parameters\")\xFE";
    z += "                end if\xFE";
    z += "                If Tkno=C_mat Then Call Tcv(False) \xFE";
    z += "            End If\xFE";
    z += "            \xFE";
    z += "            LCE = LCase(Left(Expectingtype, 1))\xFE";
    z += "            if !InStr(myValidTypes, LCE) Then\xFE";
    z += "                TypeI = Index(interChangeTypesChars, LCE, 1)\xFE";
    z += "                if TypeI Then \xFE";
    z += "                    Expectingtype = interChangeTypes[TypeI]\xFE";
    z += "                Else\xFE";
    z += "                    debug 'Unknown parameter definition type: ':LCE\xFE";
    z += "                    Expectingtype = Type_var\xFE";
    z += "                End If\xFE";
    z += "            End If\xFE";
    z += "                     \xFE";
    z += "            isByRef = LCase(Expectingtype) = Expectingtype And Expectingtype <> \"\"\xFE";
    z += "            \xFE";
    z += "            If Tkno = C_comma Then\xFE";
    z += "                // Empty param \",,\"\xFE";
    z += "                Pattr = {}\xFE";
    z += "                Pattr.SYM_C = \"undefined\"\xFE";
    z += "                Pattr.SYM_INCLEVEL = Incfile\xFE";
    z += "                Pattr.SYM_TYPE = Type_eNum\xFE";
    z += "                Pattr.SYM_TYPES = Symtypes_stored\xFE";
    z += "                Pattr.SYMNAME = \"UNDEFINED\"\xFE";
    z += "                Pattr.SYM_FLAVOR = Flavor_external\xFE";
    z += "                isByRef = LCase(Expectingtype) = Expectingtype\xFE";
    z += "                \xFE";
    z += "            End Else\xFE";
    z += "                Pattr = Expr(Expectingtype, 1, C_comma:C_rparen)\xFE";
    z += "            End\xFE";
    z += "            \xFE";
    z += "            *\xFE";
    z += "            * Update Symtypes_stored and SYM_USED if needed\xFE";
    z += "            *\xFE";
    z += "            If Index(Type_vNum:Type_vBool:Type_vstr:Type_var, Pattr.SYM_TYPE, 1) And Pattr.SYM_USED=0 Then\xFE";
    z += "                Pattr.SYM_USED = 1\xFE";
    z += "                If Not(Index(Pattr.SYM_TYPES,Symtypes_stored,1)) And LCase(Expectingtype) = Expectingtype Then Pattr.SYM_TYPES := Symtypes_stored\xFE";
    z += "                Call Writesym(Pattr, Pattr.SYMNAME)\xFE";
    z += "            End\xFE";
    z += "\xFE";
    z += "            *\xFE";
    z += "            * if Call by reference, build ByRefScript\xFE";
    z += "            *\xFE";
    z += "            If isByRef or isAtAt Then\xFE";
    z += "                if ByRefFParams Then ByRefFParams := \", \"\xFE";
    z += "            \xFE";
    z += "                // Did we pass a variable?\xFE";
    z += "                if Index(Type_vNum:Type_vBool:Type_vstr:Type_var, Pattr.SYM_TYPE, 1) Then \xFE";
    z += "                    PName = FieldLeft(Pattr.SYM_C, \"[\") \xFE";
    z += "                    If InStr(PName, \".\") Then PName = FieldRight(Pattr.SYM_C, \".\")\xFE";
    z += "                    PName = \"_\":PName\xFE";
    z += "                    ByRefFParams := PName\xFE";
    z += "                    \xFE";
    z += "                    if isByRef Then ByRefScript[-1] = Pattr.SYM_C:\" = \":PName\xFE";
    z += "                        \xFE";
    z += "                    If Not(Index(Pattr.SYM_TYPES,Symtypes_stored,1)) Then\xFE";
    z += "                        Pattr.SYM_TYPES := Symtypes_stored\xFE";
    z += "                        Call Writevsym(Pattr.SYM_TYPES, Pattr.SYMNAME, \"SYM_TYPES\")\xFE";
    z += "                    End if\xFE";
    z += "                Else\xFE";
    z += "                    ByRefFParams := \"_P\":ParamI\xFE";
    z += "                End If\xFE";
    z += "                \xFE";
    z += "                // Update sugguesting type?\xFE";
    z += "                If Pattr.SYM_TYPE = Expectingtype and !isAtAT Then\xFE";
    z += "                    If Not(needCallDef) Then\xFE";
    z += "                        If Not(Index(Pattr.SYM_TYPES,Expectingtype,1)) Then\xFE";
    z += "                            Pattr.SYM_TYPES := Expectingtype\xFE";
    z += "                            Call Writevsym(Pattr.SYM_TYPES, Pattr.SYMNAME,  \"SYM_TYPES\")\xFE";
    z += "                        End\xFE";
    z += "                    End\xFE";
    z += "                End\xFE";
    z += "            Else\xFE";
    z += "                Begin Case\xFE";
    z += "                    Case Expectingtype='N' Or Expectingtype='n'\xFE";
    z += "                        Call Makenum(Type_vnum, Pattr)\xFE";
    z += "                    Case Expectingtype='B' Or Expectingtype='b'\xFE";
    z += "                        Call Makebool(Pattr)\xFE";
    z += "                    Case Expectingtype='S' Or Expectingtype='s'\xFE";
    z += "                        Call Makestr(Type_vstr, Pattr)\xFE";
    z += "                End Case\xFE";
    z += "            End\xFE";
    z += "            \xFE";
    z += "            If Len(PrmList) Then PrmList := \", \"\xFE";
    z += "            PrmList := Pattr.SYM_C\xFE";
    z += "\xFE";
    z += "            Call SkipOverComments(True)\xFE";
    z += "            ParamCnt += 1\xFE";
    z += "            If Tkno <> C_comma Then Exit Do\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "            If Index(C_am:C_asterisk, Tkno, 1) Then Call SkipOverComments(True)\xFE";
    z += "        Repeat\xFE";
    z += "        La = La[1,Len(La)-1]\xFE";
    z += "    End\xFE";
    z += "\xFE";
    z += "    If Needlp Then\xFE";
    z += "        If Tkno <> C_rparen Then Call Err(\") Expected\") Else Call Tcv(False)\xFE";
    z += "    End\xFE";
    z += "\xFE";
    z += "    // Fill in optional parameters\xFE";
    z += "    If Not(needCallDef) And ByRefFParams Then\xFE";
    z += "        for ParamI = ParamI + 1 to UBound(ParamTypes)\xFE";
    z += "            Expectingtype = ParamTypes[Parami]\xFE";
    z += "            If Len(PrmList) Then PrmList := \", \"\xFE";
    z += "            PrmList := \"undefined\"\xFE";
    z += "            ParamCnt += 1\xFE";
    z += "        next\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    if xTraParams Then\xFE";
    z += "        If Len(PrmList) Then PrmList := \", \"\xFE";
    z += "        PrmList := xTraParams\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    if ByRefFParams And ByRefScript Then\xFE";
    z += "        PrmList := \", function (\":ByRefFParams:\") { \":Join(ByRefScript, \"; \"):\" }\"\xFE";
    z += "    end if\xFE";
    z += "    \xFE";
    z += "    \xFE";
    z += "    If Isatat Then\xFE";
    z += "        hasPromises[-1] = \"Has a CALL @@ (rpc request)\"\xFE";
    z += "\xFE";
    z += "        if PrmList Then PrmList = \", \":PrmList\xFE";
    z += "        If Isfunc Then\xFE";
    z += "            Rtnattr.SYM_C = \"await asyncRpcRequest('\":Cname:\"'\":PrmList:\")\"\xFE";
    z += "        End Else\xFE";
    z += "            OC := \"/* call */ await asyncRpcRequest('\":Cname:\"'\":PrmList:'); '\xFE";
    z += "        End If\xFE";
    z += "\xFE";
    z += "    Else If isCallAt Then\xFE";
    z += "        // A lot of assumuptions make - ASync function (all ByRefs's)\xFE";
    z += "        //  Call @Sub\xFE";
    z += "        If Isfunc Then\xFE";
    z += "            Rtnattr.SYM_C = \"await asyncCallByName(\":Cname:', me, ':Ignoremissingcall:'/*ignore if missing */, ':PrmList:')'\xFE";
    z += "        End Else\xFE";
    z += "            OC := \"await asyncCallByName(\":Cname:', me, ':Ignoremissingcall:' /*ignore if missing */, ':PrmList:'); '\xFE";
    z += "        End If\xFE";
    z += "        \xFE";
    z += "    End Else\xFE";
    z += "    \xFE";
    z += "        if NotASyncFunction Or CallDef.SUB_NOAWAITSALLOWED then prefix = \"\" else prefix = \"await \"\xFE";
    z += "        \xFE";
    z += "        if Ignoremissingcall Then prefix = 'if (window.':Cname:') ':prefix\xFE";
    z += "\xFE";
    z += "        If Isfunc Then\xFE";
    z += "            Rtnattr.SYM_C = prefix:Cname:'(':PrmList:')'\xFE";
    z += "        End Else\xFE";
    z += "            OC := prefix:Cname:'(':PrmList:'); '\xFE";
    z += "        End If\xFE";
    z += "    End If\xFE";
    z += "\xFE";
    z += "    // To update or not.... what we temporarily built isn't exactly the definition\xFE";
    z += "    // if needCallDef Then writejson CallDef on fXRefs, LCase(Cname):xrefSuffix\xFE";
    z += "    \xFE";
    z += "    If needCallDef And Isfunc Then Returntype = 'v' Else Returntype = CallDef.SUB_RTNTYPE\xFE";
    z += "    Begin Case\xFE";
    z += "        Case Returntype='N'\xFE";
    z += "            Rtnattr.SYM_TYPE = Type_eNum\xFE";
    z += "        Case Returntype = 'S'\xFE";
    z += "            Rtnattr.SYM_TYPE = Type_estr\xFE";
    z += "        Case 1\xFE";
    z += "            Rtnattr.SYM_TYPE = Type_dc\xFE";
    z += "    End Case\xFE";
    z += "*\xFE";
    z += "* Keep track of routines we call (except calls to routines in config_jsb2js)\xFE";
    z += "*\xFE";
    z += "    if callNameIsLiteral And !standardJSCall Then\xFE";
    z += "        if Isfunc Then CallID = LCase(Cname):\"_fnc\" Else CallID = LCase(Cname)  \xFE";
    z += "        Locate CallID In Calllist Else Calllist[-1] = CallID\xFE";
    z += "    End\xFE";
    z += "*\xFE";
    z += "    Return Rtnattr\xFE";
    z += "end function\xFE";
    z += "\xFE";
    z += ""
    window.cached_jsb2js["docall"] = z;
    var z = "Function Dofuncs(byval Exp_type, byval Noparams)\xFE";
    z += "*\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "* Should return a type:\xFE";
    z += "*    TYPE_ESTR - a known string expression\xFE";
    z += "*    Type_eNum           number\xFE";
    z += "*    Type_eBool           boolean\xFE";
    z += "*    TYPE_EXP            anything else (xml, json, array, etc.)\xFE";
    z += "*\xFE";
    z += "*\xFE";
    z += "    Gattr = {}\xFE";
    z += "    Gattr.SYM_FLAVOR = Flavor_temp\xFE";
    z += "    Gattr.SYM_TYPE = Type_estr\xFE";
    z += "    Gattr.SYM_INCLEVEL = Incfile\xFE";
    z += "    Gattr.SYM_ATRNO = 0\xFE";
    z += "    Gattr.SYMNAME = Tkstr\xFE";
    z += "                \xFE";
    z += "    Success = 1\xFE";
    z += "    For Breakcase = 1 To 1\xFE";
    z += "        Begin Case\xFE";
    z += "            Case Tkstr = \"$\" ;* Jquery\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Exp_type, 1, C_rparen)\xFE";
    z += "                Gattr.SYM_C='$(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_FLAVOR = Flavor_external\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "\xFE";
    z += "            Case Tkstr = \"FUNCTION\"\xFE";
    z += "                Call Tcv(False) ;* Skip function\xFE";
    z += "                S = \"\"\xFE";
    z += "                If Tkno = C_lparen Then\xFE";
    z += "                    Call Tcv(False) ;* Skip (\xFE";
    z += "                    Loop Until Tkno = C_rparen Or Tkno = C_sm Do\xFE";
    z += "                        S = S:Otkstr\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                    Repeat\xFE";
    z += "                    If Tkno = C_rparen Then Call Tcv(False)\xFE";
    z += "                End If\xFE";
    z += "              \xFE";
    z += "                If Tkstr <> \"{\" Then Call Err(\"{ expected\")\xFE";
    z += "      \xFE";
    z += "                Contents = \" { \" : PassThruJavascript() : \" }\"\xFE";
    z += "                Gattr.SYM_C= \"function (\":S:\")\":Contents\xFE";
    z += "\xFE";
    z += "                If Tkno = C_lparen Then\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    If Tkno = C_rparen Then Call Tcv(False) Else Call Err(\"')' expected; Found \":Tkstr)\xFE";
    z += "                    Gattr.SYM_C = Gattr.SYM_C:\"()\"\xFE";
    z += "                End If\xFE";
    z += "                \xFE";
    z += "                Gattr.SYM_TYPE = Type_exp\xFE";
    z += "                Return Gattr\xFE";
    z += "\xFE";
    z += "            Case Tkstr = \"IIF\" Or Tkstr = \"IFF\"\xFE";
    z += "                Call Tcv(False); * Skip iif\xFE";
    z += "                Call Tcv(False); * skip (\xFE";
    z += "                \xFE";
    z += "                Gattr = Expr(Type_eBool, 1, C_comma:C_rparen)\xFE";
    z += "                \xFE";
    z += "                If Tkno <> C_comma Then Call Err(', expected') ; Break\xFE";
    z += "                Call Tcv(False); * skip ,\xFE";
    z += "                \xFE";
    z += "                battr = Expr(Exp_type, 1, C_comma:C_rparen)\xFE";
    z += "                \xFE";
    z += "                If Tkno <> C_comma Then Call Err(', expected') ; Break\xFE";
    z += "                Call Tcv(False); * skip ,\xFE";
    z += "            \xFE";
    z += "                cattr = Expr(Exp_type, 1, C_rparen)\xFE";
    z += "                \xFE";
    z += "                Gattr.SYM_C = '(':Gattr.SYM_C:'?':battr.SYM_C:':':cattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Exp_type\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"ABS\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Exp_type, 1, C_rparen)\xFE";
    z += "                Call Typenum(Type_vnum, Gattr)\xFE";
    z += "                Gattr.SYM_C='Abs(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "\xFE";
    z += "            Case Tkstr = \"PI\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr.SYM_C='PI()'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "\xFE";
    z += "            Case Tkstr = \"GUID\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr.SYM_C='newGUID()'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "\xFE";
    z += "            Case Tkstr = \"ARGUMENTS\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr.SYM_C='arguments'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"SEQ\" Or Tkstr = \"ASC\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'Seq(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"ISALPHA\" Or Tkstr = \"ALPHA\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'isAlpha(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eBool\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"ISINT\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'isInt(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eBool\xFE";
    z += "\xFE";
    z += "            Case Tkstr = \"ISMISSING\" Or Tkstr = \"ISUNDEFINED\" \xFE";
    z += "                // Returns True for undefined \xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                Gattr.SYM_C = Gattr.SYM_C:' === undefined'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eBool\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"ISNULL\" Or Tkstr = \"ISMISSING\" Or Tkstr = \"ISNOTHING\"  Or Tkstr = \"ISUNDEFINED\" \xFE";
    z += "                // Note: ISNULL: Needs to be the same for ASPX compatibility - use window.IsNull if you really need IsNull()\xFE";
    z += "                // Returns True for null or undefined - but NOT an empty string\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'isNothing(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eBool\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"ISEMPTY\" \xFE";
    z += "                // Returns True for null, undefined, or empty string\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'isEmpty(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eBool\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"CHAR\" Or Tkstr = \"CHR\" Or Tkstr = \"CHR$\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                *\xFE";
    z += "                Call Typenum(Type_vnum, Gattr)\xFE";
    z += "                If Gattr.SYM_TYPE = Type_cnum Then\xFE";
    z += "                    Begin Case\xFE";
    z += "                        Case Gattr.SYM_C = 10\xFE";
    z += "                            Gattr.SYM_C = \"'\\\\n'\"\xFE";
    z += "                        Case Gattr.SYM_C = 11\xFE";
    z += "                            Gattr.SYM_C = \"'\\\\f'\"\xFE";
    z += "                        Case Gattr.SYM_C = 7\xFE";
    z += "                            Gattr.SYM_C = \"'\\\\a'\"\xFE";
    z += "                        Case Gattr.SYM_C = 13\xFE";
    z += "                            Gattr.SYM_C = \"'\\\\r'\"\xFE";
    z += "                        Case Gattr.SYM_C = 9\xFE";
    z += "                            Gattr.SYM_C = \"'\\\\t'\"\xFE";
    z += "                        Case Gattr.SYM_C = Seq('\\\\')\xFE";
    z += "                            Gattr.SYM_C = \"'\\\\\\\\'\"\xFE";
    z += "                        Case Gattr.SYM_C = Seq(' ')\xFE";
    z += "                            Gattr.SYM_C = \"' '\"\xFE";
    z += "                        Case 1\xFE";
    z += "                            Gattr.SYM_C = 'Chr(':Gattr.SYM_C:')'\xFE";
    z += "                            Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                    End Case\xFE";
    z += "                End Else\xFE";
    z += "                    Gattr.SYM_C = 'Chr(':Gattr.SYM_C:')'\xFE";
    z += "                    Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                End\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"MID\" Or Tkstr = \"MID$\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_comma:C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                *\xFE";
    z += "                If Tkno <> C_comma Then Call Err(', expected') ; Break\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                *\xFE";
    z += "                Bexpr = Expr(Type_eNum, 1, C_comma:C_rparen)\xFE";
    z += "                If Not(Index(Type_vNum:Type_vBool:Type_eNum:Type_cnum:Type_eBool,Bexpr.SYM_TYPE,1)) Then\xFE";
    z += "                    Call Typenum(Type_vnum, Bexpr)\xFE";
    z += "                End\xFE";
    z += "                *\xFE";
    z += "                If Tkno = C_rparen Then\xFE";
    z += "                    Gattr.SYM_C = 'Mid1(':Gattr.SYM_C:',':Bexpr.SYM_C:')'\xFE";
    z += "                    Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                    Break\xFE";
    z += "                End\xFE";
    z += "                *\xFE";
    z += "                If Tkno <> C_comma Then Call Err(', expected') ; Break\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                *\xFE";
    z += "                Aexpr = Expr(Type_eNum, 2, C_rparen)\xFE";
    z += "                If Not(Index(Type_vNum:Type_vBool:Type_eNum:Type_cnum:Type_eBool,Aexpr.SYM_TYPE,1)) Then\xFE";
    z += "                    Call Typenum(Type_vnum, Aexpr)\xFE";
    z += "                End\xFE";
    z += "                *\xFE";
    z += "                Gattr.SYM_C = 'Mid1(':Gattr.SYM_C:',':Bexpr.SYM_C:',':Aexpr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"LEFT\" Or Tkstr = \"LEFT$\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_comma)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                If Tkno <> C_comma Then Call Err(', expected') ; Break\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                *\xFE";
    z += "                Aexpr = Expr(Type_eNum, 2, C_comma:C_rparen)\xFE";
    z += "                If Not(Index(Type_vNum:Type_vBool:Type_eNum:Type_cnum:Type_eBool,Aexpr.SYM_TYPE,1)) Then\xFE";
    z += "                    Call Typenum(Type_vnum, Aexpr)\xFE";
    z += "                End\xFE";
    z += "                *\xFE";
    z += "                Gattr.SYM_C = 'Left(':Gattr.SYM_C:',':Aexpr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"RIGHT\" Or Tkstr = \"RIGHT$\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_comma:C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                If Tkno <> C_comma Then Call Err(', expected') ; Break\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                *\xFE";
    z += "                Aexpr = Expr(Type_eNum, 2, C_rparen)\xFE";
    z += "                If Not(Index(Type_vNum:Type_vBool:Type_eNum:Type_cnum:Type_eBool,Aexpr.SYM_TYPE,1)) Then\xFE";
    z += "                    Call Typenum(Type_vnum, Aexpr)\xFE";
    z += "                End\xFE";
    z += "                *\xFE";
    z += "                Gattr.SYM_C = 'Right(':Gattr.SYM_C:',':Aexpr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"COL1\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                Gattr.SYM_C = 'activeProcess.Col1'\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"COL2\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                Gattr.SYM_C = 'activeProcess.Col2'\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"COS\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                Call Typenum(Type_vnum, Gattr)\xFE";
    z += "                If Mr83 Then Gattr.SYM_C = 'R83_Cos(':Gattr.SYM_C:' )' Else Gattr.SYM_C = 'Cos(':Gattr.SYM_C:' )'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"COUNT\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_estr, 1, C_comma:C_rparen)\xFE";
    z += "                If Tkno <> C_comma Then Gattr = fErr(', expected') Else\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    Bexpr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                End\xFE";
    z += "                Call Typestr(Type_vstr, Aexpr)\xFE";
    z += "                Call Typestr(Type_vstr, Bexpr)\xFE";
    z += "                Gattr.SYM_C = 'Count(':Aexpr.SYM_C:',':Bexpr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"CINT\" Or Tkstr = \"INT\" Or Tkstr = \"CLNG\" Or Tkstr = \"FIX\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                Gattr.SYM_C = 'CInt(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "\xFE";
    z += "            Case Tkstr = \"CBOOL\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                Gattr.SYM_C = 'CBool(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eBool\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"CDBL\" Or Tkstr = \"CSNG\" Or Tkstr = \"CDEC\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                Gattr.SYM_C = 'CDbl(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"CNUM\" Or Tkstr = \"VAL\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                Gattr.SYM_C = 'CNum(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"NUM\" Or Tkstr = \"ISNUM\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'isNumber(':Gattr.SYM_C:')' ;* forgiving version (trailing stuff ok)\xFE";
    z += "                Gattr.SYM_TYPE = Type_eBool\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"ISNUMERIC\" ;* stricter version\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'isNumeric(':Gattr.SYM_C:')' \xFE";
    z += "                Gattr.SYM_TYPE = Type_eBool\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"DCOUNT\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_estr, 1, C_comma:C_rparen)\xFE";
    z += "                If Tkno <> C_comma Then\xFE";
    z += "                    Gattr = fErr(', expected')\xFE";
    z += "                    Bexpr = Clone(Gattr)\xFE";
    z += "                End Else\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    Bexpr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                End\xFE";
    z += "                Call Typestr(Type_vstr, Aexpr)\xFE";
    z += "                Call Typestr(Type_vstr, Bexpr)\xFE";
    z += "                Gattr.SYM_C = 'DCount(':Aexpr.SYM_C:',':Bexpr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"DELETE\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_estr, 1, C_comma:C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Aexpr)\xFE";
    z += "                If Tkno <> C_comma Then Gattr = fErr(', expected') Else\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    Bexpr = Expr(Type_eNum, 1, C_comma:C_rparen)\xFE";
    z += "                    Call Typenum(Type_vnum, Bexpr)\xFE";
    z += "                    *\xFE";
    z += "                    If Tkno = C_comma Then\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Cexpr = Expr(Type_eNum, 2, C_comma:C_rparen)\xFE";
    z += "                        Call Typenum(Type_vnum, Cexpr)\xFE";
    z += "                        If Tkno = C_comma Then\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            Dexpr = Expr(Type_eNum, 2, C_comma:C_rparen)\xFE";
    z += "                            Call Typenum(Type_vnum, Dexpr)\xFE";
    z += "                        End Else\xFE";
    z += "                            Dexpr = {}\xFE";
    z += "                            Dexpr.SYM_C = \"0\"\xFE";
    z += "                        End\xFE";
    z += "                    End Else\xFE";
    z += "                        Cexpr = {}\xFE";
    z += "                        Cexpr.SYM_C = \"0\"\xFE";
    z += "                        Dexpr = {}\xFE";
    z += "                        Dexpr.SYM_C = \"0\"\xFE";
    z += "                    End\xFE";
    z += "                End\xFE";
    z += "                Gattr.SYM_C = 'Delete(':Aexpr.SYM_C:',':Bexpr.SYM_C:',':Cexpr.SYM_C:',':Dexpr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"DTX\" Or Tkstr = \"HEX\" Or Tkstr = \"HEX$\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                Call Typenum(Type_vnum, Aexpr)\xFE";
    z += "                Gattr.SYM_C = 'DTX(':Aexpr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"EXP\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                Call Typenum(Type_vnum, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'Exp(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"EXTRACT\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_estr, 1, C_comma:C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Aexpr)\xFE";
    z += "                If Tkno <> C_comma Then Gattr = fErr(', expected') Else\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    Bexpr = Expr(Type_eNum, 1, C_comma:C_rparen)\xFE";
    z += "                    Call Typenum(Type_vnum, Bexpr)\xFE";
    z += "                    *\xFE";
    z += "                    If Tkno = C_comma Then\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Cexpr = Expr(Type_eNum, 2, C_comma:C_rparen)\xFE";
    z += "                        Call Typenum(Type_vnum, Cexpr)\xFE";
    z += "                        If Tkno = C_comma Then\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            Dexpr = Expr(Type_eNum, 2, C_comma:C_rparen)\xFE";
    z += "                            Call Typenum(Type_vnum, Dexpr)\xFE";
    z += "                        End Else\xFE";
    z += "                            Dexpr = {}\xFE";
    z += "                            Dexpr.SYM_C = '0'\xFE";
    z += "                        End\xFE";
    z += "                    End Else\xFE";
    z += "                        Cexpr = {}\xFE";
    z += "                        Cexpr.SYM_C = '0'\xFE";
    z += "                        Dexpr = {}\xFE";
    z += "                        Dexpr.SYM_C = '0'\xFE";
    z += "                    End\xFE";
    z += "                End\xFE";
    z += "                Gattr.SYM_C = 'Extract(':Aexpr.SYM_C:',':Bexpr.SYM_C:',':Cexpr.SYM_C:',':Dexpr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"FIELD\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_estr, 1, C_comma:C_rparen)\xFE";
    z += "                Call Typestr(Type_estr, Aexpr)\xFE";
    z += "                If Tkno <> C_comma Then Gattr = fErr(', expected') Else\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    Bexpr = Expr(Type_estr, 1, C_comma:C_rparen)\xFE";
    z += "                    Call Typestr(Type_vstr, Bexpr)\xFE";
    z += "                    If Tkno <> C_comma Then Gattr = fErr(', expected') Else\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Cexpr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                        Call Typenum(Type_vnum, Cexpr)\xFE";
    z += "                        \xFE";
    z += "                        If Instr(Mcu(Itemsrc), \"COL1()\") Or Instr(Mcu(Itemsrc), \"COL2()\") Then\xFE";
    z += "                            Gattr.SYM_C = 'Field(':Aexpr.SYM_C:',':Bexpr.SYM_C:',':Cexpr.SYM_C:', true)'\xFE";
    z += "                        Else\xFE";
    z += "                            Gattr.SYM_C = 'Field(':Aexpr.SYM_C:',':Bexpr.SYM_C:',':Cexpr.SYM_C:')'\xFE";
    z += "                        End If\xFE";
    z += "                        Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                    End\xFE";
    z += "                End\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"INDEX\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Bexpr = Expr(Type_estr, 1, C_comma:C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Bexpr)\xFE";
    z += "\xFE";
    z += "                If Tkno <> C_comma Then Gattr = fErr(', expected') Else\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    Aexpr = Expr(Type_estr, 1, C_comma:C_rparen)\xFE";
    z += "                    Call Typestr(Type_vstr, Aexpr)\xFE";
    z += "\xFE";
    z += "                    If Tkno = C_comma Then\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Gattr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                        Call Typenum(Type_vnum, Gattr)\xFE";
    z += "                    End Else\xFE";
    z += "                        Gattr.SYM_C = 1\xFE";
    z += "                    End If\xFE";
    z += "                    \xFE";
    z += "                    Gattr.SYM_C='Index1(':Bexpr.SYM_C:',':Aexpr.SYM_C:',':Gattr.SYM_C:')'\xFE";
    z += "                    Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                End\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"INSTR\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_estr, 1, C_comma:C_rparen)\xFE";
    z += "                If Tkno <> C_comma Then Gattr = fErr(', expected') Else\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    Bexpr = Expr(Type_estr, 1, C_comma:C_rparen)\xFE";
    z += "                    If Tkno = C_comma Then\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                        Call Typenum(Type_vnum, Aexpr)\xFE";
    z += "                    End Else\xFE";
    z += "                        Gattr = Clone(Bexpr)\xFE";
    z += "                        Bexpr = Clone(Aexpr)\xFE";
    z += "                        Aexpr.SYM_C = 1\xFE";
    z += "                    End\xFE";
    z += "                    Call Typestr(Type_vstr, Bexpr)\xFE";
    z += "                    Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                    Gattr.SYM_C='InStr1(':Aexpr.SYM_C:',':Bexpr.SYM_C:',':Gattr.SYM_C:')'\xFE";
    z += "                    Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                End\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"INSTRI\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_estr, 1, C_comma:C_rparen)\xFE";
    z += "                If Tkno <> C_comma Then Gattr = fErr(', expected') Else\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    Bexpr = Expr(Type_estr, 1, C_comma:C_rparen)\xFE";
    z += "                    If Tkno = C_comma Then\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                        Call Typenum(Type_vnum, Aexpr)\xFE";
    z += "                    End Else\xFE";
    z += "                        Gattr = Clone(Bexpr)\xFE";
    z += "                        Bexpr = Clone(Aexpr)\xFE";
    z += "                        Aexpr.SYM_C = 1\xFE";
    z += "                    End\xFE";
    z += "                    Call Typestr(Type_vstr, Bexpr)\xFE";
    z += "                    Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                    Gattr.SYM_C='InStrI1(':Aexpr.SYM_C:',':Bexpr.SYM_C:',':Gattr.SYM_C:')'\xFE";
    z += "                    Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                End\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"INSTRREV\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_estr, 1, C_comma:C_rparen)\xFE";
    z += "                If Tkno <> C_comma Then Gattr = fErr(', expected') Else\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    Bexpr = Expr(Type_estr, 1, C_comma:C_rparen)\xFE";
    z += "                    If Tkno = C_comma Then\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                        Call Typenum(Type_vnum, Aexpr)\xFE";
    z += "                    End Else\xFE";
    z += "                        Gattr = Clone(Bexpr)\xFE";
    z += "                        Bexpr = Clone(Aexpr)\xFE";
    z += "                        Aexpr.SYM_C = \"undefined\"\xFE";
    z += "                    End\xFE";
    z += "                    Call Typestr(Type_vstr, Bexpr)\xFE";
    z += "                    Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                    Gattr.SYM_C='InStrRev1(':Aexpr.SYM_C:',':Bexpr.SYM_C:',':Gattr.SYM_C:')'\xFE";
    z += "\xFE";
    z += "                    Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                End\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"INSERT\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_estr, 1, C_comma:C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Aexpr)\xFE";
    z += "                *\xFE";
    z += "                If Tkno <> C_comma Then Gattr = fErr(', expected') Else\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    Cexpr = Expr(Type_eNum, 1, C_comma:C_semi:C_rparen)\xFE";
    z += "                    Call Typenum(Type_vnum, Cexpr)\xFE";
    z += "                    *\xFE";
    z += "                    If Tkno = C_comma Then\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Dexpr = Expr(Type_eNum, 2, C_comma:C_semi:C_rparen)\xFE";
    z += "                        Call Typenum(Type_vnum, Dexpr)\xFE";
    z += "                        If Tkno = C_comma Then\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            Bexpr = Expr(Type_eNum, 2, C_comma:C_semi:C_rparen)\xFE";
    z += "                            Call Typenum(Type_vnum, Bexpr)\xFE";
    z += "                        End Else\xFE";
    z += "                            Bexpr = {}\xFE";
    z += "                            Bexpr.SYM_C = \"0\"\xFE";
    z += "                        End\xFE";
    z += "                    End Else\xFE";
    z += "                        Dexpr = {}\xFE";
    z += "                        Dexpr.SYM_C = \"0\"\xFE";
    z += "                        Bexpr = {}\xFE";
    z += "                        Bexpr.SYM_C = \"0\"\xFE";
    z += "                    End\xFE";
    z += "                    *\xFE";
    z += "                    If Tkno = C_semi Or Tkno = C_comma Then\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                        Call Typestr(Type_dc, Gattr)\xFE";
    z += "                        Avs=Cexpr.SYM_C:',':Dexpr.SYM_C:',':Bexpr.SYM_C\xFE";
    z += "                        Gattr.SYM_C='Insert(':Aexpr.SYM_C:',':Avs:',':Gattr.SYM_C:')'\xFE";
    z += "                        Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                    End Else Gattr = fErr('\";\" Expected')\xFE";
    z += "                End\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"LEN\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_dc, Gattr)\xFE";
    z += "                Gattr.SYM_C='Len(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"LN\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                Call Typenum(Type_vnum, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'Ln(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"LOG\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                Call Typenum(Type_vnum, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'Log(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"MCL\" Or Tkstr = \"LCASE\" Or Tkstr = \"LCASE$\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Aexpr)\xFE";
    z += "                Gattr.SYM_C = 'LCase(':Aexpr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"MCU\" Or Tkstr = \"UCASE\" Or Tkstr = \"UCASE$\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Aexpr)\xFE";
    z += "                Gattr.SYM_C = 'UCase(':Aexpr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"LOWER\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Aexpr)\xFE";
    z += "                Gattr.SYM_C = 'Lower(':Aexpr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"RAISE\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Aexpr)\xFE";
    z += "                Gattr.SYM_C = 'Raise(':Aexpr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"MXI\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Aexpr)\xFE";
    z += "                Gattr.SYM_C = 'Mxi(':Aexpr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"MXO\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Aexpr)\xFE";
    z += "                Gattr.SYM_C = 'Mxo(':Aexpr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"MOD\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Exp_type, 1, C_comma:C_rparen)\xFE";
    z += "                If Tkno <> C_comma Then Gattr = fErr(', expected') Else\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    Gattr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                End\xFE";
    z += "                \xFE";
    z += "                Call Typenum(Type_vnum, Aexpr)\xFE";
    z += "                Call Typenum(Type_vnum, Gattr)\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                if InStr(Aexpr.SYM_C, \"*\") Or InStr(Aexpr.SYM_C, \"/\") Or InStr(Aexpr.SYM_C, \"-\") Then Aexpr.SYM_C = '(':Aexpr.SYM_C:')'\xFE";
    z += "                if InStr(Gattr.SYM_C, \"*\") Or InStr(Gattr.SYM_C, \"/\") Or InStr(Gattr.SYM_C, \"-\") Then Gattr.SYM_C = '(':Gattr.SYM_C:')'\xFE";
    z += "                \xFE";
    z += "                Gattr.SYM_C = Aexpr.SYM_C:' % ':Gattr.SYM_C\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"NOT\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                Call MakeNot(Gattr)\xFE";
    z += "\xFE";
    z += "            Case Tkstr = \"PWR\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_eNum, 1, C_comma:C_rparen)\xFE";
    z += "                If Tkno <> C_comma Then Gattr = fErr(', expected') ; Break\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                Call Typenum(Type_vnum, Gattr)\xFE";
    z += "                Call Typenum(Type_vnum, Aexpr)\xFE";
    z += "                Gattr.SYM_C = 'Pwr(':Gattr.SYM_C:',':Aexpr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"REM\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Exp_type, 1, C_comma:C_rparen)\xFE";
    z += "                If Tkno <> C_comma Then Gattr = fErr(', expected') Else\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    Gattr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                End\xFE";
    z += "                Call Typenum(Type_vnum, Aexpr)\xFE";
    z += "                Call Typenum(Type_vnum, Gattr)\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                Gattr.SYM_C = Aexpr.SYM_C:' % ':Gattr.SYM_C\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"RND\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                Call Typenum(Type_vnum, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'Rnd(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"SIN\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                Call Typenum(Type_vnum, Gattr)\xFE";
    z += "                \xFE";
    z += "                If Mr83 Then Gattr.SYM_C = 'R83_Sin(':Gattr.SYM_C:')' Else Gattr.SYM_C = 'Sin(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"SPACE\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                *\xFE";
    z += "                Call Typenum(Type_vnum, Aexpr)\xFE";
    z += "                Gattr.SYM_C = 'Space(':Aexpr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"SQRT\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                Call Typenum(Type_vnum, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'Sqrt(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"STR\" Or Tkstr = \"STRRPT\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_cstr, 1, C_comma:C_rparen)\xFE";
    z += "                If Tkno <> C_comma Then Gattr = fErr(', expected') Else\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    Bexpr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                    Call Typenum(Type_vnum, Bexpr)\xFE";
    z += "                End\xFE";
    z += "                Call Typestr(Type_dc, Aexpr)\xFE";
    z += "                Gattr.SYM_C = 'StrRpt(':Aexpr.SYM_C:',':Bexpr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"TAN\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                Call Typenum(Type_vnum, Gattr)\xFE";
    z += "                If Mr83 Then Gattr.SYM_C = 'R83_Tan(':Gattr.SYM_C:' )' Else Gattr.SYM_C = 'Tan(':Gattr.SYM_C:' )'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "\xFE";
    z += "            Case Tkstr = \"DATESERIAL\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_cstr, 1, C_comma:C_rparen)\xFE";
    z += "                Call Typenum(Type_vnum, Aexpr)\xFE";
    z += "\xFE";
    z += "                If Tkno <> C_comma Then Gattr = fErr(', expected') Else\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    Bexpr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                    Call Typenum(Type_vnum, Bexpr)\xFE";
    z += "\xFE";
    z += "                    If Tkno <> C_comma Then Gattr = fErr(', expected') Else\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Cexpr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                        Call Typenum(Type_vnum, Cexpr)\xFE";
    z += "                        Gattr.SYM_C = 'makeR83Date(':Cexpr.SYM_C:',':Bexpr.SYM_C:',':Aexpr.SYM_C:')'\xFE";
    z += "                        Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                    End If\xFE";
    z += "                End\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"TRIM\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'Trim(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"TRIMB\" Or Tkstr = \"RTRIM\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'RTrim(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"TRIMF\" Or Tkstr = \"LTRIM\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'LTrim(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"XTD\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Aexpr)\xFE";
    z += "                If Aexpr.SYM_TYPE = Type_cstr Then\xFE";
    z += "                    S = Aexpr.SYM_C[7,Len(Aexpr.SYM_C)-8]\xFE";
    z += "                    Isx = 1\xFE";
    z += "                    Slen = Len(S)\xFE";
    z += "                    If Not(Slen) Then S = '0'\xFE";
    z += "                    For I = 1 To Slen\xFE";
    z += "                        If Not(Index(\"0123456789ABCDEFabcdef\",S[I,1],1)) Then Isx = 0\xFE";
    z += "                    Next I\xFE";
    z += "                    If Not(Isx) Then Gattr = fErr(\"Not a Hex number\") ; Break\xFE";
    z += "                    Gattr.SYM_C = \"0x\":S\xFE";
    z += "                    If Slen < 5 Then\xFE";
    z += "                        Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                    End Else\xFE";
    z += "                        Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                    End\xFE";
    z += "                    Break\xFE";
    z += "                End\xFE";
    z += "                *\xFE";
    z += "                Gattr.SYM_C = 'XTD(':Aexpr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"CONVERT\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                * A = CONVERT(A TO B IN C)\xFE";
    z += "                *\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_comma)\xFE";
    z += "                If Tkno <> C_comma Then Gattr = fErr(', expected') ; Break\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                *\xFE";
    z += "                Aexpr = Expr(Type_estr, 1, C_comma)\xFE";
    z += "                If Tkno <> C_comma Then Gattr = fErr(', expected') ; Break\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                *\xFE";
    z += "                Bexpr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                *\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                Call Typestr(Type_vstr, Aexpr)\xFE";
    z += "                *\xFE";
    z += "                Call Typestr(Type_vstr, Bexpr)\xFE";
    z += "                Gattr.SYM_C = 'Convert(':Gattr.SYM_C:',':Aexpr.SYM_C:',':Bexpr.SYM_C:')'\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"KEYIN\" Or Tkstr = \"INKEY\"\xFE";
    z += "                Call Tcv(False) // skip KeyIn\xFE";
    z += "                Call Tcv(False) // skip (\xFE";
    z += "                \xFE";
    z += "                // KeyIn() - no wait\xFE";
    z += "                // KeyIn(true) - wait\xFE";
    z += "                \xFE";
    z += "                if Tkno = C_RParen Then\xFE";
    z += "                    Gattr.SYM_C = 'KeyIn()'\xFE";
    z += "                Else\xFE";
    z += "                    hasPromises[-1] = \"Has KeyIn()\"\xFE";
    z += "                    Gattr.SYM_C = 'await asyncKeyIn(true)'\xFE";
    z += "                End If\xFE";
    z += "\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"MOUSEX\" Or Tkstr = \"MOUSEY\"\xFE";
    z += "                Gattr.SYM_C = 'window.mouse':Right(Tkstr, 1)\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"REPLACE\" ;* Replace(Aexpr, From, To)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_estr, 1, C_comma:C_rparen) ; *Replace(Str\xFE";
    z += "                Call Typestr(Type_vstr, Aexpr)\xFE";
    z += "                *\xFE";
    z += "                Dexpr = {}\xFE";
    z += "                Dexpr.SYM_C = \"0\"\xFE";
    z += "                Bexpr = {}\xFE";
    z += "                Bexpr.SYM_C = \"0\"\xFE";
    z += "                *\xFE";
    z += "                If Tkno <> C_comma Then Gattr = fErr(', expected') Else\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    Cexpr = Expr(Type_eNum, 1, C_comma:C_semi:C_rparen) ; *Replace(Str, From\xFE";
    z += "                    If Tkno = C_comma Then\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Dexpr = Expr(Type_eNum, 1, C_semi:C_comma:C_rparen) ;* Replace(Str, From, To)\xFE";
    z += "                        If Tkno = C_comma Then\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            Bexpr = Expr(Type_eNum, 2, C_comma:C_semi:C_rparen) ;* Replace(Str, Am, Vm, Svm\xFE";
    z += "                        End Else If Tkno <> C_semi Then\xFE";
    z += "                            Gattr.SYM_C = 'Change(':Aexpr.SYM_C:',':Cexpr.SYM_C:',':Dexpr.SYM_C:')'\xFE";
    z += "                        End\xFE";
    z += "                    End Else If Tkno <> C_semi Then\xFE";
    z += "                        Gattr = fErr('\";\" Expected')\xFE";
    z += "                    End\xFE";
    z += "                    *\xFE";
    z += "                    If Tkno = C_semi Or Tkno = C_comma Then\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Gattr = Expr(Type_estr, 1, C_rparen) ;* Replace(Str, Am, Vm, Svm; Withstr)\xFE";
    z += "                        Call Typestr(Type_dc, Gattr)\xFE";
    z += "                        \xFE";
    z += "                        Call Typenum(Type_vnum, Cexpr)\xFE";
    z += "                        Call Typenum(Type_vnum, Dexpr)\xFE";
    z += "                        Call Typenum(Type_vnum, Bexpr)\xFE";
    z += "                        \xFE";
    z += "                        Avs=Cexpr.SYM_C:',':Dexpr.SYM_C:',':Bexpr.SYM_C\xFE";
    z += "                        Gattr.SYM_C='Replace(':Aexpr.SYM_C:',':Avs:',':Gattr.SYM_C:')'\xFE";
    z += "                        Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                    End If\xFE";
    z += "                End\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"CHANGE\" Or Tkstr = \"REPLACEI\" Or Tkstr = \"CHANGEI\"\xFE";
    z += "                * X = CHANGE(AEXPR, GATTR, BEXPR)\xFE";
    z += "                *\xFE";
    z += "                Ctkstr = Tkstr\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                * \xFE";
    z += "                * Changes characters A to characters B in String\xFE";
    z += "                *\xFE";
    z += "                Aexpr = Expr(Type_estr, 1, C_comma:C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Aexpr)\xFE";
    z += "                If Tkno <> C_comma Then Gattr = fErr(',  expected') ; Break\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                *\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_comma:C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                If Tkno <> C_comma Then Gattr = fErr(',  expected') ; Break\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                *\xFE";
    z += "                Bexpr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                *\xFE";
    z += "                If Ctkstr = \"CHANGE\" Then\xFE";
    z += "                    Gattr.SYM_C = 'Change(':Aexpr.SYM_C:',':Gattr.SYM_C:',':Bexpr.SYM_C:')'\xFE";
    z += "                End Else\xFE";
    z += "                    Gattr.SYM_C = 'ChangeI(':Aexpr.SYM_C:',':Gattr.SYM_C:',':Bexpr.SYM_C:')'\xFE";
    z += "                End If\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"BITOR\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_eNum, 1, C_comma:C_rparen)\xFE";
    z += "                *\xFE";
    z += "                If Tkno <> C_comma Then Gattr = fErr(', expected') ; Break\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                *\xFE";
    z += "                Gattr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                *\xFE";
    z += "                Call Makenum(Type_vnum, Aexpr)\xFE";
    z += "                Call Makenum(Type_vnum, Gattr)\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                Gattr.SYM_C = '(':Aexpr.SYM_C:' | ':Gattr.SYM_C:')'\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"BITAND\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_eNum, 1, C_comma:C_rparen)\xFE";
    z += "                *\xFE";
    z += "                If Tkno <> C_comma Then Gattr = fErr(', expected') ; Break\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                *\xFE";
    z += "                Gattr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                *\xFE";
    z += "                Call Makenum(Type_vnum, Aexpr)\xFE";
    z += "                Call Makenum(Type_vnum, Gattr)\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                Gattr.SYM_C = '(':Aexpr.SYM_C:' & ':Gattr.SYM_C:')'\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"BITXOR\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_eNum, 1, C_comma:C_rparen)\xFE";
    z += "                *\xFE";
    z += "                If Tkno <> C_comma Then Gattr = fErr(', expected') ; Break\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                *\xFE";
    z += "                Gattr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                *\xFE";
    z += "                Call Makenum(Type_vnum, Aexpr)\xFE";
    z += "                Call Makenum(Type_vnum, Gattr)\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                Gattr.SYM_C = '(':Aexpr.SYM_C:' ^ ':Gattr.SYM_C:')'\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"ACOS\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                Call Typenum(Type_vnum, Gattr)\xFE";
    z += "                If Mr83 Then Gattr.SYM_C = 'R83_ACos(':Gattr.SYM_C:' )' Else Gattr.SYM_C = 'ACos(':Gattr.SYM_C:' )'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"ASIN\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                Call Typenum(Type_vnum, Gattr)\xFE";
    z += "                If Mr83 Then Gattr.SYM_C = 'R83_ASin(':Gattr.SYM_C:' )' Else Gattr.SYM_C = 'ASin(':Gattr.SYM_C:' )'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"ATAN\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                Call Typenum(Type_vnum, Gattr)\xFE";
    z += "                If Mr83 Then Gattr.SYM_C = 'R83_ATan(':Gattr.SYM_C:' )' Else Gattr.SYM_C = 'ATan(':Gattr.SYM_C:' )'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"SINH\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                Call Typenum(Type_vnum, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'Sinh(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"COSH\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                Call Typenum(Type_vnum, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'Cosh(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"TANH\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                Call Typenum(Type_vnum, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'Tanh(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"FLOOR\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                Call Typenum(Type_vnum, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'Floor(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"CEIL\" Or Tkstr = \"CEILING\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                Call Typenum(Type_vnum, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'Ceiling(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"XTS\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'XTS(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"STX\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'STX(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"ENCODE\" Or Tkstr = \"ENCRYPT\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_comma:C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                If Tkno = C_comma Then\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    Cexpr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                    Gattr.SYM_C = 'aesEncrypt(':Gattr.SYM_C:',':Cexpr.SYM_C:')'\xFE";
    z += "                Else\xFE";
    z += "                    Gattr.SYM_C = 'aesEncrypt(':Gattr.SYM_C:')'\xFE";
    z += "                End If\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "\xFE";
    z += "            Case Tkstr = \"DECODE\" Or Tkstr = \"DECRYPT\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_comma:C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                If Tkno = C_comma Then\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    Cexpr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                    Gattr.SYM_C = 'aesDecrypt(':Gattr.SYM_C:',':Cexpr.SYM_C:')'\xFE";
    z += "                Else\xFE";
    z += "                    Gattr.SYM_C = 'aesDecrypt(':Gattr.SYM_C:')'\xFE";
    z += "                End If\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"DATE\" Or Tkstr = \"CDATE\" Or Tkstr = \"DATEVALUE\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                If Tkno = C_rparen Then\xFE";
    z += "                    Gattr.SYM_C = 'r83Date()'\xFE";
    z += "                    Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                End Else\xFE";
    z += "                    Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                    Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                    Gattr.SYM_C = 'r83Date(':Gattr.SYM_C:')'\xFE";
    z += "                    Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                End If\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"TIME\" Or Tkstr = \"CTIME\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                If Tkno = C_rparen Then\xFE";
    z += "                    Gattr.SYM_C = 'r83Time()'\xFE";
    z += "                    Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                End Else\xFE";
    z += "                    Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                    Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                    Gattr.SYM_C = 'r83Time(':Gattr.SYM_C:')'\xFE";
    z += "                    Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                End If\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"TIMER\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr.SYM_C = 'Timer()'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"NOW\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr.SYM_C = 'Now()'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"DOW\" Or Tkstr = \"DAYOFWEEK\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'DayOfWeek(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "\xFE";
    z += "            Case Tkstr = \"YEAR\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'Field(YearMonthDay(':Gattr.SYM_C:'), \"-\", 1)'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "\xFE";
    z += "            Case Tkstr = \"MONTH\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'Field(YearMonthDay(':Gattr.SYM_C:'), \"-\", 2)'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "\xFE";
    z += "            Case Tkstr = \"DAY\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'Field(YearMonthDay(':Gattr.SYM_C:'), \"-\", 3)'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"DMY\" Or Tkstr = \"DAYMONTHYEAR\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'YearMonthDay(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"CSTR\" Or Tkstr = \"CSTR$\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_comma:C_rparen)\xFE";
    z += "                \xFE";
    z += "                Call Typestr(Type_dc, Gattr)\xFE";
    z += "                Gattr.SYM_C = \"CStr(\":Gattr.SYM_C:\", true)\"\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "\xFE";
    z += "            Case Tkstr = \"SYSTEM\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                \xFE";
    z += "                Gattr.SYM_C = 'System(':Gattr.SYM_C\xFE";
    z += "                if Val(Gattr.SYM_C) = 27 Or Val(Gattr.SYM_C) = 28 Then Gattr.SYM_C := ', me'\xFE";
    z += "                Gattr.SYM_C := ')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_exp\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"JSON\" Or Tkstr = \"STR2JSON\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'parseJSON(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_exp\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"XML\" Or Tkstr = \"STR2XML\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'parseXML(':Gattr.SYM_C:')' ;* xmlToJson(X)\xFE";
    z += "                Gattr.SYM_TYPE = Type_exp\xFE";
    z += "\xFE";
    z += "            Case Tkstr = \"HTMLENCODE\" Or Tkstr = \"ESCAPE\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'htmlEscape(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "\xFE";
    z += "            Case Tkstr = \"HTMLDECODE\" Or Tkstr = \"UNESCAPE\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'htmlUnescape(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "\xFE";
    z += "            Case Tkstr = \"URLENCODE\" Or Tkstr = \"ENCODEURI\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'urlEncode(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "\xFE";
    z += "            Case Tkstr = \"URLDECODE\" Or Tkstr = \"DECODEURI\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'urlDecode(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "\xFE";
    z += "            Case Tkstr = \"FORMVAR\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'formVar(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_exp\xFE";
    z += "\xFE";
    z += "            Case Tkstr = \"PARAMVAR\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'paramVar(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_exp\xFE";
    z += "\xFE";
    z += "            Case Tkstr = \"QUERYVAR\" Or Tkstr = \"GUP\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'queryVar(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_exp\xFE";
    z += "\xFE";
    z += "            Case Tkstr = \"SPLIT\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_estr, 1, C_comma:C_rparen)\xFE";
    z += "                If Tkno <> C_comma Then Gattr = fErr(', expected') ; Break\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_comma:C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Aexpr)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "\xFE";
    z += "                If Tkno = C_comma Then\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    Cexpr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                    Gattr.SYM_C = 'Split(':Aexpr.SYM_C:',':Gattr.SYM_C:',':Cexpr.SYM_C:')'\xFE";
    z += "                Else\xFE";
    z += "                    Gattr.SYM_C = 'Split(':Aexpr.SYM_C:',':Gattr.SYM_C:')'\xFE";
    z += "                End If\xFE";
    z += "                Gattr.SYM_TYPE = Type_exp\xFE";
    z += "\xFE";
    z += "            Case Tkstr = \"JOIN\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_estr, 1, C_comma:C_rparen)\xFE";
    z += "                If Tkno = C_comma Then\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                    Gattr.SYM_C = 'Join(':Aexpr.SYM_C:',':Gattr.SYM_C:')'\xFE";
    z += "                End Else\xFE";
    z += "                    Call Typestr(Type_vnum, Aexpr)\xFE";
    z += "                    Gattr.SYM_C = 'Join(':Aexpr.SYM_C:')'\xFE";
    z += "                End If\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "\xFE";
    z += "            Case Tkstr = \"FMT\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_estr, 1, C_comma:C_rparen)\xFE";
    z += "                If Tkno <> C_comma Then Gattr = fErr(', expected') ; Break\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vnum, Aexpr)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                \xFE";
    z += "                Gattr.SYM_C = 'Fmt(':Aexpr.SYM_C:',':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "\xFE";
    z += "            Case Tkstr = \"TYPEOF\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'typeOf(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"LBOUND\" Or Tkstr = \"LOWERBOUND\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_exp, 1, C_rparen)\xFE";
    z += "                Gattr.SYM_C = 'LBound(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "\xFE";
    z += "            Case Tkstr = \"UBOUND\" Or Tkstr = \"UPPERBOUND\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_exp, 1, C_rparen)\xFE";
    z += "                Gattr.SYM_C = 'UBound(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "\xFE";
    z += "            Case Tkstr = \"GETLIST\" ;* Turn A Select List Into A String\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_exp, 1, C_comma:C_rparen)\xFE";
    z += "                \xFE";
    z += "                If Tkno = C_comma Then\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    Aexpr = Expr(Type_eBool, 1, C_rparen)\xFE";
    z += "                    Gattr.SYM_C = 'getList(':Gattr.SYM_C:',':Aexpr.SYM_C:')'\xFE";
    z += "                End Else\xFE";
    z += "                    Gattr.SYM_C = 'getList(':Gattr.SYM_C:')'\xFE";
    z += "                    Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                End If\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"ACTIVELIST\" Or Tkstr = \"ACTIVESELECT\" Or Tkstr = \"LISTACTIVE\" Or Tkstr = \"SELECTACTIVE\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                If Tkno <> C_rparen Then\xFE";
    z += "                    Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                    Gattr.SYM_C = 'isActiveSelect(':Gattr.SYM_C:')'\xFE";
    z += "                End Else\xFE";
    z += "                    Gattr.SYM_C = 'isSelectActive()'\xFE";
    z += "                End If\xFE";
    z += "                Gattr.SYM_TYPE = Type_eBool\xFE";
    z += "\xFE";
    z += "            Case Tkstr = \"KEYS\" Or Tkstr = \"TAGNAMES\" ;* Array Of Keys\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_exp, 1, C_rparen)\xFE";
    z += "                Gattr.SYM_C = 'Keys(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "\xFE";
    z += "            Case Tkstr = \"TAGNAME\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_exp, 1, C_rparen)\xFE";
    z += "                S = Gattr.SYM_C\xFE";
    z += "                I = Count(S, \"[\")\xFE";
    z += "                If I Then\xFE";
    z += "                    I = Index(S, \"[\", I)\xFE";
    z += "                    S = Left(S, I-1):\",\":Mid(S, I+1)\xFE";
    z += "                    I = Instr(I, S, \"]\")\xFE";
    z += "                    S = Left(S, I-1):Mid(S, I+1)\xFE";
    z += "                End If\xFE";
    z += "                Gattr.SYM_C = 'TagName(':S:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "\xFE";
    z += "            Case Tkstr = \"ATTRIBUTES\" ;* Array Of Attributes\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_exp, 1, C_rparen)\xFE";
    z += "                Gattr.SYM_C = 'Attributes(':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"HASTAG\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_exp, 1, C_comma:C_rparen)\xFE";
    z += "                If Tkno <> C_comma Then Gattr = fErr(', expected') ; Break\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                Gattr.SYM_C = 'HasTag(':Aexpr.SYM_C:',':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eBool\xFE";
    z += "\xFE";
    z += "            Case Tkstr = \"IS\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_exp, 1, C_comma:C_rparen)\xFE";
    z += "                If Tkno <> C_comma Then Gattr = fErr(', expected') ; Break\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_exp, 1, C_rparen)\xFE";
    z += "                Gattr.SYM_C = '(':Aexpr.SYM_C:' == ':Gattr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_eBool\xFE";
    z += "\xFE";
    z += "            Case Tkstr = \"XTS\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Aexpr)\xFE";
    z += "                Gattr.SYM_C = 'XTS(':Aexpr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"STX\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Aexpr)\xFE";
    z += "                Gattr.SYM_C = 'STX(':Aexpr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"CLONE\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_exp, 1, C_rparen)\xFE";
    z += "                Gattr.SYM_C = 'clone(':Aexpr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_exp\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"REGX\" Or Tkstr = \"REGEX\" Or Tkstr = \"REGEXP\" ;* RegX(Source, Pattern, Replace)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_comma)\xFE";
    z += "                Call Typestr(Type_vstr, Gattr)\xFE";
    z += "                *\xFE";
    z += "                If Tkno <> C_comma Then Call Err(', expected') ; Break\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                *\xFE";
    z += "                Bexpr = Expr(Type_eNum, 1, C_comma:C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Bexpr)\xFE";
    z += "                *\xFE";
    z += "                If Tkno <> C_comma Then Call Err(', expected') ; Break\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                *\xFE";
    z += "                Cexpr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Cexpr)\xFE";
    z += "                *\xFE";
    z += "                Gattr.SYM_C = 'regExp(':Gattr.SYM_C:',':Bexpr.SYM_C:',':Cexpr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "\xFE";
    z += "            Case Tkstr = \"EXECUTEDOS\" ;* Executedos(\"DIR\")\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Aexpr)\xFE";
    z += "                Gattr.SYM_C = 'ExecuteDOS(':Aexpr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_exp\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"CREATEOBJECT\" ;* Createobject(\"DIR\")\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Aexpr)\xFE";
    z += "                Gattr.SYM_C = 'CreateObject(':Aexpr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_exp\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"CHECKSUM\" ;* Checksum(String)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Aexpr)\xFE";
    z += "                Gattr.SYM_C = 'Checksum(':Aexpr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_exp\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"SORT\" ;* Sort(Array {, sorttype}), Sort(Json[], Tag{, sorttype}) Or Sort(Jsonrec{, sorttype})\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr = Expr(Type_exp, 1, C_comma)\xFE";
    z += "                *\xFE";
    z += "                If Tkno = C_comma Then\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    Bexpr = Expr(Type_exp, 1, C_comma:C_rparen)\xFE";
    z += "                    \xFE";
    z += "                    If Tkno = C_comma Then\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Cexpr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                        Call Typestr(Type_vstr, Cexpr)\xFE";
    z += "                        Gattr.SYM_C = 'Sort(':Gattr.SYM_C:',':Bexpr.SYM_C:',':Cexpr.SYM_C:')'\xFE";
    z += "                        Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                    Else\xFE";
    z += "                        Gattr.SYM_C = 'Sort(':Gattr.SYM_C:',':Bexpr.SYM_C:')'\xFE";
    z += "                    End If\xFE";
    z += "                Else\xFE";
    z += "                    Gattr.SYM_C = 'Sort(':Gattr.SYM_C:')'\xFE";
    z += "                End If\xFE";
    z += "                \xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"REVERSE\" ;* Reverse(Array)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_exp, 1, C_rparen)\xFE";
    z += "                Gattr.SYM_C = 'Reverse(':Aexpr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_exp\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"SQL\" ;* Sql(ScalarCommand)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Aexpr)\xFE";
    z += "                Gattr.SYM_C = 'SQL(':Aexpr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_exp\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"SM\" Or Tkstr = \"AM\" Or Tkstr = \"VM\" Or Tkstr = \"SVM\" Or Tkstr = \"SSVM\" Or Tkstr = \"CRLF\" Or Tkstr = \"CR\" Or Tkstr = \"LF\"\xFE";
    z += "                Htk = savetk()\xFE";
    z += "                \xFE";
    z += "                Gattr.SYM_C = LCase(Tkstr)\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                \xFE";
    z += "                If Tkno <> C_lparen And Noparams Then Return Gattr\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                If Tkno <> C_rparen Then\xFE";
    z += "                    Call Restoret(Htk)\xFE";
    z += "                End If\xFE";
    z += "                \xFE";
    z += "            Case Tkstr = \"EXECUTEDOS\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Aexpr = Expr(Type_estr, 1, C_rparen)\xFE";
    z += "                Call Typestr(Type_vstr, Aexpr)\xFE";
    z += "                Gattr.SYM_C = 'ExecuteDos(':Aexpr.SYM_C:')'\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                \xFE";
    z += "            Case 1\xFE";
    z += "                Return Null\xFE";
    z += "        End Case\xFE";
    z += "    Next\xFE";
    z += "    \xFE";
    z += "    If Tkno = C_rparen Then Call Tcv(False) Else Call Err(\") expected;  Found \":Tkstr)\xFE";
    z += "    Return Gattr\xFE";
    z += "End Subroutine\xFE";
    z += ""
    window.cached_jsb2js["dofuncs"] = z;
    var z = "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "// Return GAttr\xFE";
    z += "function Expr(Byval ExpectedType, Byval Parse_rels, Byval Stoptokens)\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "* PARSE_RELS = 1 ;* EXPRESSIONS INCLUDING RELATIONAL OPERATORS\xFE";
    z += "* PARSE_RELS = 2 ;* EXPRESSIONS EXCLUDING RELATIONAL OPERATORS\xFE";
    z += "*\xFE";
    z += "    La = La:Stoptokens\xFE";
    z += "    firstTkNo = Tkno\xFE";
    z += "    \xFE";
    z += "    If Parse_rels = 1 Then\xFE";
    z += "        Gattr = Expr_AndOr(ExpectedType, Stoptokens)\xFE";
    z += "    Else\xFE";
    z += "        Gattr = Expr_ConCat(ExpectedType, Stoptokens)\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    // What follows an expression should be in STOPTOKENS\xFE";
    z += "    If Tkno = C_ident And firstTkNo <> C_lparen Then \xFE";
    z += "        Call Warning(\"Unexpected characters: '\":Tkstr:\"' found after \":Gattr.SYM_C)\xFE";
    z += "    end if\xFE";
    z += "    \xFE";
    z += "    La = La[1,Len(La)-Len(Stoptokens)]\xFE";
    z += "    Return Gattr\xFE";
    z += "End function\xFE";
    z += "\xFE";
    z += "function Expr_AndOr(ByVal ExpectedType, ByVal Stoptokens)\xFE";
    z += "    $Insert _comms\xFE";
    z += "    \xFE";
    z += "    Gattr = Expr_Matches(ExpectedType, Stoptokens)\xFE";
    z += "    \xFE";
    z += "    Loop While Index(C_and:C_or:C_andsign:C_bar,Tkno,1) Do\xFE";
    z += "        ExpectedType = Type_vnum\xFE";
    z += "        Eattr = Clone(Gattr)\xFE";
    z += "        // This is unique for the client library, allows both logical and binary and/or\xFE";
    z += "        Aop = Tkstr\xFE";
    z += "        If Tkno = C_and Then Aop = \"&&\"\xFE";
    z += "        If Tkno = C_or Then Aop = \"||\"\xFE";
    z += "        Call Tcv(False)\xFE";
    z += "        Gattr = Expr_Matches(ExpectedType, Stoptokens)\xFE";
    z += "        Call Makebool(Gattr)\xFE";
    z += "        Call Makebool(Eattr)\xFE";
    z += "        Gattr.SYM_C = Eattr.SYM_C:' ':Aop:' ':Gattr.SYM_C\xFE";
    z += "        Gattr.SYM_TYPE = Type_eBool\xFE";
    z += "    Repeat\xFE";
    z += "    Return Gattr\xFE";
    z += "End function\xFE";
    z += "\xFE";
    z += "function Expr_Matches(ByVal ExpectedType, ByVal Stoptokens)\xFE";
    z += "    $Insert _comms\xFE";
    z += "    \xFE";
    z += "    Gattr = Expr_RelOps(ExpectedType, Stoptokens)\xFE";
    z += "    \xFE";
    z += "    Loop While Tkno = C_matches Do\xFE";
    z += "        ExpectedType = Type_vnum\xFE";
    z += "        Eattr = Clone(Gattr)\xFE";
    z += "        Call Tcv(False)\xFE";
    z += "        Gattr = Expr_RelOps(ExpectedType, Stoptokens)\xFE";
    z += "        Gattr.SYM_C= 'Matches(':Eattr.SYM_C:',':Gattr.SYM_C:')'\xFE";
    z += "        Gattr.SYM_TYPE = Type_eBool\xFE";
    z += "    Repeat\xFE";
    z += "    Return Gattr\xFE";
    z += "End function\xFE";
    z += "\xFE";
    z += "function Expr_RelOps(ByVal ExpectedType, ByVal Stoptokens)\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "    \xFE";
    z += "    Gattr = Expr_ConCat(ExpectedType, Stoptokens)\xFE";
    z += "    \xFE";
    z += "    Loop While Index(C_equal:C_pound:C_great:C_less:C_eq:C_ne:C_le:C_ge:C_gt:C_lt,Tkno,1) Do\xFE";
    z += "        Rattr = Clone(Gattr)\xFE";
    z += "        ExpectedType = Rattr.SYM_TYPE\xFE";
    z += "        Rop = Tkno\xFE";
    z += "        Ptkno = Peektk()\xFE";
    z += "        If (Tkno = C_great And Ptkno = C_equal) Or (Tkno = C_equal And Ptkno = C_great) Then\xFE";
    z += "            Rop = C_ge\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "        End Else If Tkno = C_less And Ptkno = C_great Then\xFE";
    z += "            Rop = C_ne\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "        End Else\xFE";
    z += "            Ptkno = Peektk()\xFE";
    z += "            If (Tkno = C_less And Ptkno = C_equal) Or (Tkno = C_equal And Ptkno = C_less) Then\xFE";
    z += "                Rop = C_le\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "            End\xFE";
    z += "        End\xFE";
    z += "        Call Tcv(False)\xFE";
    z += "        Gattr = Expr_ConCat(ExpectedType, Stoptokens)\xFE";
    z += "        Call Relcmp(Rattr, Gattr, Rop)\xFE";
    z += "    Repeat\xFE";
    z += "    \xFE";
    z += "    Return Gattr\xFE";
    z += "End function\xFE";
    z += "\xFE";
    z += "function Expr_ConCat(ByVal ExpectedType, ByVal Stoptokens)\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "    \xFE";
    z += "    Catcnt = 0\xFE";
    z += "    Makeexpr = 0\xFE";
    z += "    Kstr = ''\xFE";
    z += "    \xFE";
    z += "    Loop\xFE";
    z += "        If Mr83 Then Gattr = Expr_Fmt(ExpectedType, Stoptokens) Else Gattr = Expr_PlusMinus(ExpectedType, Stoptokens)\xFE";
    z += "\xFE";
    z += "        ExpectedType = Type_estr\xFE";
    z += "        Ptkno = Peektk()\xFE";
    z += "        \xFE";
    z += "    Until Tkno<>C_colon Or Instr(La, Ptkno) Or Instr(Stoptokens, Tkno) Do\xFE";
    z += "        \xFE";
    z += "        Makeexpr = 1\xFE";
    z += "        Call Tcv(False) ;* Skip :\xFE";
    z += "        Call Makestr(Type_dc, Gattr)\xFE";
    z += "        If Catcnt = 0 Then\xFE";
    z += "            Catstr = \"new Array(\"\xFE";
    z += "            Catstr2 = \"\"\xFE";
    z += "        End Else\xFE";
    z += "            Catstr = Catstr:\",\"\xFE";
    z += "            Catstr2 = Catstr2:\" + \"\xFE";
    z += "        End If\xFE";
    z += "        \xFE";
    z += "        Catstr2 = Catstr2:Gattr.SYM_C\xFE";
    z += "        Catstr  = Catstr:Gattr.SYM_C\xFE";
    z += "        Catcnt = Catcnt + 1\xFE";
    z += "    Repeat\xFE";
    z += "    \xFE";
    z += "    If Catcnt Then\xFE";
    z += "        Call Makestr(Type_dc, Gattr)\xFE";
    z += "\xFE";
    z += "        Catstr = Catstr:\",\":Gattr.SYM_C\xFE";
    z += "        Catstr2 = Catstr2:\" + \":Gattr.SYM_C\xFE";
    z += "\xFE";
    z += "        If Catcnt > 133 Then\xFE";
    z += "            Gattr.SYM_C = Catstr:\").join('')\"\xFE";
    z += "        End Else\xFE";
    z += "            Gattr.SYM_C = Catstr2\xFE";
    z += "        End If\xFE";
    z += "        Gattr.SYM_TYPE = Type_estr\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    Return Gattr\xFE";
    z += "End function\xFE";
    z += "\xFE";
    z += "function Expr_Fmt(ByVal ExpectedType, ByVal Stoptokens)\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "    \xFE";
    z += "    Gattr = Expr_PlusMinus(ExpectedType, Stoptokens)\xFE";
    z += "    \xFE";
    z += "    Nextc = Left(Tkstr, 1)\xFE";
    z += "    If Instr(Stoptokens, Tkno) = 0 And (Isalpha(Nextc) Or Instr(\" `'\":'\"', Nextc)) > 1 Then\xFE";
    z += "        Fattr = Clone(Gattr)\xFE";
    z += "        Gattr = Expr_PlusMinus(ExpectedType, Stoptokens)\xFE";
    z += "        Gattr.SYM_C = 'Fmt(':Fattr.SYM_C:', ':Gattr.SYM_C:')'\xFE";
    z += "        Gattr.SYM_TYPE = Type_estr\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    Return Gattr\xFE";
    z += "End function\xFE";
    z += "\xFE";
    z += "function Expr_PlusMinus(ByVal ExpectedType, ByVal Stoptokens)\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "    \xFE";
    z += "    Gattr = Expr_MulDiv(ExpectedType, Stoptokens)\xFE";
    z += "    \xFE";
    z += "    Loop While Index(C_plus:C_minus,Tkno,1) Do\xFE";
    z += "        Pop = Tkstr\xFE";
    z += "        Call Tcv(False)\xFE";
    z += "        Pattr = Clone(Gattr)\xFE";
    z += "        Gattr = Expr_MulDiv(ExpectedType, Stoptokens)\xFE";
    z += "        \xFE";
    z += "        Call Makenum(Type_vnum, Pattr)\xFE";
    z += "        Call Makenum(Type_vnum, Gattr)\xFE";
    z += "        Gattr.SYM_C=Pattr.SYM_C:Pop:Gattr.SYM_C\xFE";
    z += "        Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "    Repeat\xFE";
    z += "    \xFE";
    z += "    Return Gattr\xFE";
    z += "End function\xFE";
    z += "\xFE";
    z += "function Expr_MulDiv(ByVal ExpectedType, ByVal Stoptokens)\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "    \xFE";
    z += "    Gattr = Expr_PwrOf(ExpectedType, Stoptokens)\xFE";
    z += "    \xFE";
    z += "    Loop While Index(C_fslash:C_asterisk:C_mod:C_percent,Tkno,1) Do\xFE";
    z += "        Mop = Tkstr\xFE";
    z += "        If Tkno = C_mod Or Tkno = C_percent Then Mop = \" % \"\xFE";
    z += "        Call Tcv(False)\xFE";
    z += "        Mattr = Clone(Gattr)\xFE";
    z += "\xFE";
    z += "        ExpectedType = Type_vnum\xFE";
    z += "        Gattr = Expr_PwrOf(ExpectedType, Stoptokens)\xFE";
    z += "        \xFE";
    z += "        Call Makenum(Type_vnum, Mattr)\xFE";
    z += "        Call Makenum(Type_vnum, Gattr)\xFE";
    z += "        Gattr.SYM_C=Mattr.SYM_C:Mop:Gattr.SYM_C\xFE";
    z += "        Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "    Repeat\xFE";
    z += "    \xFE";
    z += "    Return Gattr\xFE";
    z += "End function\xFE";
    z += "\xFE";
    z += "function Expr_PwrOf(ByVal ExpectedType, ByVal Stoptokens)\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "    \xFE";
    z += "    Gattr = Expr_Uniary(ExpectedType, Stoptokens)\xFE";
    z += "    \xFE";
    z += "    Loop While Index(C_circumflex,Tkno,1) Do\xFE";
    z += "        ExpectedType = Type_vnum\xFE";
    z += "        Cattr = Clone(Gattr)\xFE";
    z += "        Call Tcv(False)\xFE";
    z += "        Gattr = Expr_Uniary(ExpectedType, Stoptokens)\xFE";
    z += "\xFE";
    z += "        Call Makenum(Type_vnum, Cattr)\xFE";
    z += "        Call Makenum(Type_vnum, Gattr)\xFE";
    z += "        Gattr.SYM_C= \"Math.pow(\":Cattr.SYM_C:\",\":Gattr.SYM_C:\")\"\xFE";
    z += "        Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "    Repeat\xFE";
    z += "    \xFE";
    z += "    Return Gattr\xFE";
    z += "End function\xFE";
    z += "\xFE";
    z += "function Expr_Uniary(ByVal ExpectedType, ByVal Stoptokens)\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "    \xFE";
    z += "    If Tkno = C_minus Then\xFE";
    z += "        Negit = 1\xFE";
    z += "        Call Tcv(False)\xFE";
    z += "    End Else If Tkno = C_plus Then\xFE";
    z += "        Negit = 0\xFE";
    z += "        Call Tcv(False)\xFE";
    z += "    End Else Negit = 0\xFE";
    z += "\xFE";
    z += "    Gattr = Atom(ExpectedType, Stoptokens)\xFE";
    z += "    \xFE";
    z += "    If Negit Then\xFE";
    z += "        Call Makenum(Type_vnum, Gattr)\xFE";
    z += "        Gattr.SYM_C='-':Gattr.SYM_C\xFE";
    z += "    End\xFE";
    z += "    \xFE";
    z += "    Return Gattr\xFE";
    z += "End function\xFE";
    z += "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "function Atom(ByVal ExpectedType, ByVal Stoptokens)\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "* ( EXPR )   ABS()  ID  STR  NUMBER\xFE";
    z += "*\xFE";
    z += "    Gattr = {}\xFE";
    z += "    Gattr.SYM_FLAVOR = Flavor_temp\xFE";
    z += "    Gattr.SYM_TYPE = Type_var\xFE";
    z += "    Gattr.SYM_INCLEVEL = Incfile\xFE";
    z += "    Gattr.SYM_ATRNO = 0\xFE";
    z += "\xFE";
    z += "    Begin Case\xFE";
    z += "        Case Tkstr = \"NEW\"\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "            Pattr = Readsym(Tkstr)\xFE";
    z += "            \xFE";
    z += "            If Tkstr = \"ARRAY\" Then\xFE";
    z += "                Gattr.SYM_C = \"new Array()\"\xFE";
    z += "                Gattr.SYM_TYPE = Type_exp\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                \xFE";
    z += "            Else If Mid(Tkline, Tkpos, 1) = Mobjectdelemeter Or Pattr.SYM_FLAVOR = Flavor_external Or Pattr.SYM_JSOBJ Then\xFE";
    z += "                // javascript new\xFE";
    z += "                Gattr = Expr(Type_estr, 1, C_then:C_else:C_lbrace)\xFE";
    z += "                Gattr.SYM_C = `new `:Gattr.SYM_C\xFE";
    z += "                Gattr.SYM_TYPE = Type_exp\xFE";
    z += "                \xFE";
    z += "            Else\xFE";
    z += "                * NEW OBJECT\xFE";
    z += "                Clsname = Tkstr\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                \xFE";
    z += "                Oc<-1> = Space(Indent):`_new`:Clsname:` = { '_fileName': '` :Cur_fname: `', '_clsName': '` :Clsname:`' } `\xFE";
    z += "                Oc<-1> = Space(Indent)\xFE";
    z += "                \xFE";
    z += "                \xFE";
    z += "                Newhold = Savetk()\xFE";
    z += "                \xFE";
    z += "                * Call CUR_FNAME!CLSNAME._new()\xFE";
    z += "                Params = Mid(Tkline, Tkstartpos)\xFE";
    z += "                \xFE";
    z += "                * Call CUR_FNAME!CLSNAME._new(WITH PARAMS)\xFE";
    z += "                If Left(Params, 2) = \"()\" Then\xFE";
    z += "                    Params = `(me._new`:Clsname:`)`:Mid(Params, 3)\xFE";
    z += "                    \xFE";
    z += "                ElseIf Left(Params, 1) = \"(\" Then\xFE";
    z += "                    Params = `(me._new`:Clsname:`, `:Mid(Params, 2)\xFE";
    z += "                    \xFE";
    z += "                Else\xFE";
    z += "                    Params = `(me._new`:Clsname:`) `:Mid(Params, 2)\xFE";
    z += "                End If\xFE";
    z += "\xFE";
    z += "                ;* Call Base\xFE";
    z += "                Tkline = \"@\":Cur_fname:\".\":Clsname:`__NEW(me._new`:Clsname:`)`\xFE";
    z += "                \xFE";
    z += "                ;* Re-Parse\xFE";
    z += "                Tkpos = 1; Tkno = ''; Call Tcv(False)\xFE";
    z += "                AExpr = DoCall(false)\xFE";
    z += "                \xFE";
    z += "                ;* Build Subsitution\xFE";
    z += "                Tkline = \"@\":Cur_fname:\".\":Clsname:\"_NEW\":Params\xFE";
    z += "                \xFE";
    z += "                ;* Re-Parse\xFE";
    z += "                Tkpos = 1; Tkno = ''; Call Tcv(False)\xFE";
    z += "                AExpr = DoCall(false)\xFE";
    z += "                \xFE";
    z += "                ;* Setup Return\xFE";
    z += "                Gattr = {}\xFE";
    z += "                Gattr.SYM_FLAVOR = Flavor_temp\xFE";
    z += "                Gattr.SYM_TYPE = Type_exp\xFE";
    z += "                Gattr.SYM_INCLEVEL = Incfile\xFE";
    z += "                Gattr.SYM_ATRNO = 0\xFE";
    z += "                Gattr.SYM_C = `me._new`:Clsname\xFE";
    z += "                \xFE";
    z += "            End If\xFE";
    z += "            \xFE";
    z += "        Case Tkno >= C_ident\xFE";
    z += "            * FUNCTION CALL?\xFE";
    z += "            S1 = Tkstr\xFE";
    z += "            Htk = Savetk()\xFE";
    z += "            Nc = Left(Trim(Tkline[Tkpos, 99]), 1)\xFE";
    z += "            \xFE";
    z += "            If Nc = \"(\" Or Nc = \"{\" Then\xFE";
    z += "                //Gattr.SYMNAME = Tkstr\xFE";
    z += "                //Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                \xFE";
    z += "                ' Standard function?\xFE";
    z += "                Gattr = Dofuncs(ExpectedType, False)\xFE";
    z += "                \xFE";
    z += "                ' Not a standard function?\xFE";
    z += "                If !Gattr Then\xFE";
    z += "                    Locate Tkstr In UC_externals_purejs_list Setting X Then\xFE";
    z += "                        Gattr = DoCall(true)\xFE";
    z += "                    End Else\xFE";
    z += "                        Gattr = Parsevar(0, 1, '', 1)\xFE";
    z += "                    End If\xFE";
    z += "                End If\xFE";
    z += "            End Else\xFE";
    z += "                Gattr = Parsevar(0, 1, '', 1)\xFE";
    z += "            End\xFE";
    z += "            \xFE";
    z += "            If Tkno = C_lparen Then\xFE";
    z += "                ' IF S1 IS ALREADY DECLARED AS A VARIABLE, THEN THIS IS NOT A CALL\xFE";
    z += "                Pattr = Readsym(S1)\xFE";
    z += "                if Pattr.SYM_FLAVOR <> Flavor_external Then\xFE";
    z += "                    If !readSymFound Or Left(Trim(Tkline[Tkpos, 99]), 1) = \")\" Then\xFE";
    z += "                        Call Restoret(Htk)\xFE";
    z += "                        La = La:C_less:C_lbrack\xFE";
    z += "                        Gattr = DoCall(true)\xFE";
    z += "                        La = La[1,Len(La)-2]\xFE";
    z += "                    End If\xFE";
    z += "                End If\xFE";
    z += "            End If\xFE";
    z += "\xFE";
    z += "            If Tkstr = Mobjectdelemeter Or Tkno = C_lparen Or Tkno = C_lbrack Or S1 = \"$\" Or S1 = \"@\" Then\xFE";
    z += "                Call Objectparse(Gattr)\xFE";
    z += "                /*\xFE";
    z += "                If !Gattr.SYM_JSOBJ And Gattr.SYM_FLAVOR <> Flavor_external And Tkstr = Mobjectdelemeter And NotASyncFunction = 0 Then\xFE";
    z += "                    Htk2 = Savetk()\xFE";
    z += "                    Call Tcv(False) ;* Skip .\xFE";
    z += "                    ObjMethod = Otkstr\xFE";
    z += "                    Call Tcv(False) ;* Skip Method\xFE";
    z += "                    If Tkno = C_lparen Then\xFE";
    z += "                        Call Restoret(Htk)\xFE";
    z += "                        Gattr = DoCall(1, \"'\":ObjMethod:\"'\")\xFE";
    z += "                    Else\xFE";
    z += "                        Call Restoret(Htk2)\xFE";
    z += "                        If Tkstr = Mobjectdelemeter Then\xFE";
    z += "                            Call Objectparse(Gattr)\xFE";
    z += "                        End If\xFE";
    z += "                    End If\xFE";
    z += "\xFE";
    z += "                Else\xFE";
    z += "                    Call Objectparse(Gattr)\xFE";
    z += "                End If\xFE";
    z += "                */\xFE";
    z += "            End If\xFE";
    z += "            \xFE";
    z += "        Case Tkno = C_lbrack ;*  Literal Array\xFE";
    z += "            Gattr.SYM_TYPE = Type_exp\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "            Gattr.SYM_C = \"[undefined, \" ;* this Makes Constant Arrays Start At 1\xFE";
    z += "\xFE";
    z += "            La = La:C_comma:C_rbrack\xFE";
    z += "            ' Loop on each PATTR\xFE";
    z += "            Loop While 1 Do\xFE";
    z += "                Loop While Tkno = C_am Do\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    Gattr.SYM_C = Gattr.SYM_C:Am\xFE";
    z += "                Repeat\xFE";
    z += "                If Tkno = C_rbrack Then Exit Do\xFE";
    z += "                Cattr = Expr(Type_estr, 1, C_comma:C_am)\xFE";
    z += "                Gattr.SYM_C = Gattr.SYM_C:Cattr.SYM_C\xFE";
    z += "                Loop While Tkno = C_am Do\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    Gattr.SYM_C = Gattr.SYM_C:Am\xFE";
    z += "                Repeat\xFE";
    z += "                If Tkno <> C_comma Then Exit Do\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr.SYM_C = Gattr.SYM_C:\", \"\xFE";
    z += "            Repeat\xFE";
    z += "            La = La[1,Len(La)-2]\xFE";
    z += "            If Tkno <> C_rbrack Then Call Err(\"] expected\") Else Call Tcv(False)\xFE";
    z += "            Gattr.SYM_C = Gattr.SYM_C:\"]\"\xFE";
    z += "\xFE";
    z += "        Case Tkno = C_lbrace\xFE";
    z += "\xFE";
    z += "            ' Check for JSON \xFE";
    z += "            Json =\"\"\xFE";
    z += "            Loop\xFE";
    z += "                Json = Json:Tkstr\xFE";
    z += "                Call Tcv(False) ;' Skip , or {\xFE";
    z += "\xFE";
    z += "                If Tkno = C_am Then Json = Json:Am\xFE";
    z += "\xFE";
    z += "                Call SkipOverComments(False)\xFE";
    z += "\xFE";
    z += "                If Tkno = C_rbrace Then Exit Do\xFE";
    z += "\xFE";
    z += "                ' Identifier\xFE";
    z += "                If Tkno < C_ident And Tkno <> C_str Then Call Err(\"Tag Identifier expected\")\xFE";
    z += "                If Tkno = C_str Then\xFE";
    z += "                    Json = Json:Tkline[Tkstartpos, Tkpos - Tkstartpos]\xFE";
    z += "                Else\xFE";
    z += "                    Json = Json:'\"':Tkline[Tkstartpos, Tkpos - Tkstartpos]:'\"'\xFE";
    z += "                End If\xFE";
    z += "                \xFE";
    z += "                Call Tcv(False)\xFE";
    z += "\xFE";
    z += "                If Tkno <> C_colon Then Call Err(\": expected\")\xFE";
    z += "                Json = Json:\":\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "\xFE";
    z += "                Otkstr = Tkstr\xFE";
    z += "                If Tkno = C_lbrack Then\xFE";
    z += "                    Loop\xFE";
    z += "                        Json = Json:Tkstr\xFE";
    z += "                        Call Tcv(False) ;' Skip , or {\xFE";
    z += "\xFE";
    z += "                        If Tkno = C_am Then Json = Json:Am\xFE";
    z += "                        Call SkipOverComments(False)\xFE";
    z += "\xFE";
    z += "                        If Tkno = C_rbrack Then Exit Do\xFE";
    z += "                        Nattr = Expr(Type_vstr, 1, C_rbrack:C_comma)\xFE";
    z += "                        Json = Json:Nattr.SYM_C\xFE";
    z += "\xFE";
    z += "                        If Tkno = C_am Then Json = Json:Am\xFE";
    z += "                        Call SkipOverComments(False)\xFE";
    z += "                    While Tkno = C_comma Do Repeat\xFE";
    z += "\xFE";
    z += "                    If Tkno = C_rbrack Then Call Tcv(False) Else Call Err(\"] expected\")\xFE";
    z += "                    Json = Json:\"]\"\xFE";
    z += "                Else\xFE";
    z += "                    Nattr = Expr(Type_vstr, 1, C_rbrack:C_comma)\xFE";
    z += "                    Json = Json:Nattr.SYM_C\xFE";
    z += "                End If\xFE";
    z += "\xFE";
    z += "                If Tkno = C_am Then Json = Json:Am\xFE";
    z += "                Call SkipOverComments(False)\xFE";
    z += "            While Tkno = C_comma Do Repeat\xFE";
    z += "\xFE";
    z += "            If Tkno = C_rbrace Then Call Tcv(False) Else Call Err(\"} expected\")\xFE";
    z += "            Json = Json:\"}\"\xFE";
    z += "\xFE";
    z += "            Gattr.SYM_ISCONST = 1\xFE";
    z += "            Gattr.SYM_TYPE = Type_exp\xFE";
    z += "            Gattr.SYM_C = Json\xFE";
    z += "            If Tkno = C_period Or Tkno = C_lparen Then Call Objectparse(Gattr)\xFE";
    z += "\xFE";
    z += "        Case Tkno = C_bang ;* !\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "            Gattr = Expr(Type_eNum, 2, C_rparen)\xFE";
    z += "            Call MakeNot(Gattr)\xFE";
    z += "\xFE";
    z += "        Case Tkno = C_andsign And UCase(Tkline[Tkpos,1]) = \"H\";* &Hff\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "            Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "            Gattr.SYM_C = \"0x\":Mid(Tkstr, 2)\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "\xFE";
    z += "        Case Tkstr = \"0\" And UCase(Tkline[Tkpos,1]) = \"X\";* 0Xff\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "            Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "            Gattr.SYM_C = \"0x\":Mid(Tkstr, 2)\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "\xFE";
    z += "        Case Tkno = C_str\xFE";
    z += "            Gattr.SYM_ISCONST = 1\xFE";
    z += "            Gattr.SYMNAME = Tkstr\xFE";
    z += "            Strng = Tkstr\xFE";
    z += "            C = Strng[1,1]\xFE";
    z += "            Strng=Strng[2,Len(Strng)-2]\xFE";
    z += "            \xFE";
    z += "            If C = \"`\" Then\xFE";
    z += "                Strng = Change(Strng, `\\`, `\\\\`)\xFE";
    z += "                Strng = Change(Strng, `'`, `\\'`)\xFE";
    z += "                Strng = Change(Strng, `<`, `\\<`)\xFE";
    z += "                Strng = Change(Strng, `>`, `\\>`)\xFE";
    z += "            Else\xFE";
    z += "                For I = 1 to 255\xFE";
    z += "                    C = Chr(I)\xFE";
    z += "                    if !InStr(Strng, C) Then Break\xFE";
    z += "                Next\xFE";
    z += "                \xFE";
    z += "                // Preserve \\\\\xFE";
    z += "                Strng = Change(Strng, `\\\\`, C)\xFE";
    z += "                \xFE";
    z += "                // Mask HTML characters\xFE";
    z += "                Strng = Change(Strng, `'`, `\\'`)\xFE";
    z += "                Strng = Change(Strng, `<`, `\\<`)\xFE";
    z += "                Strng = Change(Strng, `>`, `\\>`)\xFE";
    z += "                \xFE";
    z += "                Strng = Change(Strng, `\\\\`, `\\`) // avoid any that the user has already escaped\xFE";
    z += "                \xFE";
    z += "                // Extra Pickish stuff to escape\xFE";
    z += "                Strng = Change(Strng, `\\a`,  `\\xFE`) // convert to js hex codes\xFE";
    z += "                Strng = Change(Strng, `\\v`,  `\\xFD`)\xFE";
    z += "                Strng = Change(Strng, `\\s`,  `\\xFC`)\xFE";
    z += "            \xFE";
    z += "                // Restore \\\\\xFE";
    z += "                Strng = Change(Strng, C, `\\\\`)\xFE";
    z += "            End If\xFE";
    z += "\xFE";
    z += "            Strng = Change(Strng, Chr(13):Chr(10), `\\r\\n\\`:Chr(13):Chr(10))\xFE";
    z += "            Strng = Change(Strng, Chr(10):Chr(13), `\\r\\n\\`:Chr(13):Chr(10))\xFE";
    z += "            \xFE";
    z += "            Gattr.SYM_TYPE = Type_cstr\xFE";
    z += "            Gattr.SYM_C = \"'\":Strng:\"'\"\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "            \xFE";
    z += "        Case Tkno = C_number\xFE";
    z += "            Gattr.SYM_ISCONST = 1\xFE";
    z += "            Nmbr = Tkstr + 0\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "            If Tkno = C_period Then\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr.SYM_TYPE = Type_cnum\xFE";
    z += "                If Tkno = C_number Then\xFE";
    z += "                    Nmbr = (Nmbr:\".\":Tkstr)+0\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                End Else\xFE";
    z += "                    Nmbr = Nmbr:'.0'\xFE";
    z += "                End\xFE";
    z += "            End\xFE";
    z += "            Gattr.SYM_TYPE = Type_cnum\xFE";
    z += "            Gattr.SYMNAME = Nmbr\xFE";
    z += "            Gattr.SYM_C = Nmbr\xFE";
    z += "            Return Gattr\xFE";
    z += "            \xFE";
    z += "        Case Tkno = C_period\xFE";
    z += "            Gattr.SYM_ISCONST = 1\xFE";
    z += "            Gattr.SYM_TYPE = Type_cnum\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "            Gattr.SYMNAME = \".\":Tkstr\xFE";
    z += "            Gattr.SYM_C = \"0.\":Tkstr\xFE";
    z += "            If Tkno <> C_number Then\xFE";
    z += "                Call Err('Number expected')\xFE";
    z += "                Gattr.SYMNAME = 0\xFE";
    z += "            End Else Call Tcv(False)\xFE";
    z += "            Return Gattr\xFE";
    z += "\xFE";
    z += "        Case Tkno = C_at\xFE";
    z += "            Htk = Savetk()\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "\xFE";
    z += "            If Tkno = C_at Then\xFE";
    z += "                Call Restoret(Htk)\xFE";
    z += "                Gattr = DoCall(true)\xFE";
    z += "\xFE";
    z += "            Else If Tkno = C_ident Then\xFE";
    z += "                Begin Case\xFE";
    z += "                    Case Tkstr = \"REQUEST\" Or Tkstr = \"RESPONSE\" Or Tkstr = \"SERVER\" Or Tkstr = \"USER\" Or Tkstr = \"MEMBERSHIP\" Or Tkstr = \"APPLICATION\" Or Tkstr = \"SESSION\"\xFE";
    z += "                        Call Restoret(Htk)\xFE";
    z += "                        Gattr = Parsevar(0, 1, '', 1)\xFE";
    z += "                        If Tkstr = Mobjectdelemeter Or Tkno = C_lparen Then Call Objectparse(Gattr)\xFE";
    z += "\xFE";
    z += "                    Case Tkstr = \"SENTENCE\" Or Tkstr = \"ERRORS\" Or Tkstr = \"ERROR\" Or Tkstr = \"FILENAME\" Or Tkstr = \"FILE\" Or Tkstr = \"PAGE\" Or Tkstr = \"ROLES\" Or Tkstr = \"USER\"\xFE";
    z += "                        Call Restoret(Htk)\xFE";
    z += "                        Gattr = Parsevar(0, 1, '', 1)\xFE";
    z += "                        If Tkstr = Mobjectdelemeter Or Tkno = C_lparen Then Call Objectparse(Gattr)\xFE";
    z += "\xFE";
    z += "                    Case Tkstr = \"RECORD\" Or Tkstr = \"PROMPT\" Or Tkstr = \"INPUT\" Or Tkstr = \"ECHO\" Or Tkstr = \"MV\" Or Tkstr = \"NI\" Or Tkstr = \"ID\" Or Tkstr = \"NV\" Or Tkstr = \"NB\" Or Tkstr = \"ND\" Or Tkstr = \"STATUS\"  Or Tkstr = \"RESTFUL_RESULT\"\xFE";
    z += "                        Call Restoret(Htk)\xFE";
    z += "                        Gattr = Parsevar(0, 1, '', 1)\xFE";
    z += "                        If Tkstr = Mobjectdelemeter Or Tkno = C_lparen Then Call Objectparse(Gattr)\xFE";
    z += "\xFE";
    z += "                    Case Tkstr = \"AM\" Or Tkstr = \"VM\" Or Tkstr = \"SVM\" Or Tkstr = \"SSVM\"\xFE";
    z += "                        Call Restoret(Htk)\xFE";
    z += "                        Gattr = Parsevar(0, 1, '', 1)\xFE";
    z += "                        If Tkstr = Mobjectdelemeter Or Tkno = C_lparen Then Call Objectparse(Gattr)\xFE";
    z += "\xFE";
    z += "                    Case 1\xFE";
    z += "                        * ASSUME FUNCTION CALL\xFE";
    z += "                        Call Restoret(Htk)\xFE";
    z += "                        Gattr = DoCall(true)\xFE";
    z += "                End Case\xFE";
    z += "                \xFE";
    z += "            Else If Tkno = C_lparen Then\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                \xFE";
    z += "                If Tkno = C_lparen Then\xFE";
    z += "                    Call Restoret(Htk)\xFE";
    z += "                    Gattr = DoCall(true)\xFE";
    z += "                Else\xFE";
    z += "                    *\xFE";
    z += "                    * @(X, Y)\xFE";
    z += "                    *\xFE";
    z += "                    Gattr = Expr(Type_estr, 1, C_comma:C_rparen)\xFE";
    z += "                    Call Typenum(Type_vstr, Gattr)\xFE";
    z += "                    If Tkno = C_comma Then\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Nattr = Expr(Type_estr, 1, C_comma:C_rparen)\xFE";
    z += "                        Call Typenum(Type_vstr, Nattr)\xFE";
    z += "                        Gattr.SYM_C = 'AtXY(':Gattr.SYM_C:',':Nattr.SYM_C:')'\xFE";
    z += "                        Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                    Else\xFE";
    z += "                        Gattr.SYM_C = 'At(':Gattr.SYM_C:')'\xFE";
    z += "                        Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                    End If\xFE";
    z += "                    If Tkno = C_rparen Then Call Tcv(False) Else Call Err(') EXPECTED')\xFE";
    z += "                End If\xFE";
    z += "            Else\xFE";
    z += "                Call Err(\"??\")\xFE";
    z += "            End If\xFE";
    z += "            \xFE";
    z += "        Case Tkno = C_lparen\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "            Gattr = Expr(ExpectedType, 1, C_rparen)\xFE";
    z += "            If Tkno <> C_rparen Then Call Err(') expected') Else\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "            End\xFE";
    z += "            If Index(Type_vstr:Type_cstr:Type_estr,Gattr.SYM_TYPE,1) = 0 Then\xFE";
    z += "                Gattr.SYM_C='(':Gattr.SYM_C:')'\xFE";
    z += "                if Gattr.SYM_TYPE = Type_var then Gattr.SYM_TYPE = Type_exp \xFE";
    z += "                if Gattr.SYM_TYPE = Type_vnum then Gattr.SYM_TYPE = Type_enum \xFE";
    z += "                if Gattr.SYM_TYPE = Type_vstr then Gattr.SYM_TYPE = Type_estr \xFE";
    z += "            End\xFE";
    z += "            \xFE";
    z += "        Case 1\xFE";
    z += "            Call Err('Variable Identifier expected')\xFE";
    z += "            Return Gattr\xFE";
    z += "    End Case\xFE";
    z += "*\xFE";
    z += "* CHECK FOR <EXPR{,EXPR{,EXPR}}>\xFE";
    z += "*\xFE";
    z += "    Amattr = {}\xFE";
    z += "    Amattr.SYM_C=0\xFE";
    z += "    Amattr.SYM_TYPE=Type_cnum\xFE";
    z += "    Amattr.SYMNAME=0\xFE";
    z += "    Sattr = Clone(Amattr) ; Lenattr = Clone(Amattr)\xFE";
    z += "    Vmattr = Clone(Amattr)\xFE";
    z += "    Svmattr = Clone(Amattr)\xFE";
    z += "*\xFE";
    z += "    If Tkno = C_less And Instr(Stoptokens, C_less) = 0 Then\xFE";
    z += "        Ptkno = Peektk()\xFE";
    z += "        If Index(C_equal:C_less:C_great,Ptkno,1) Then Return Gattr\xFE";
    z += "        Htk = Savetk()\xFE";
    z += "        Call Tcv(False)\xFE";
    z += "        \xFE";
    z += "        Amattr = Expr(Type_eNum, 2, C_comma:C_great)\xFE";
    z += "        \xFE";
    z += "        // Must have a matching >\xFE";
    z += "        If Tkno <> C_comma And Tkno <> C_great Then\xFE";
    z += "            Call Restoret(Htk)\xFE";
    z += "            Return Gattr\xFE";
    z += "        End\xFE";
    z += "        \xFE";
    z += "        If Tkno = C_comma Then\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "            Vmattr = Expr(Type_eNum, 2, C_comma:C_great)\xFE";
    z += "            If Tkno = C_comma Then\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Svmattr = Expr(Type_eNum, 2, C_comma:C_great)\xFE";
    z += "            End\xFE";
    z += "        End\xFE";
    z += "        If Tkno = C_great Then\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "        End Else Call Err('\">\" Expected')\xFE";
    z += "        \xFE";
    z += "        Call Typestr(Type_vstr, Gattr)\xFE";
    z += "        Call Typenum(Type_vnum, Amattr)\xFE";
    z += "        Call Typenum(Type_vnum, Vmattr)\xFE";
    z += "        Call Typenum(Type_vnum, Svmattr)\xFE";
    z += "        Gattr.SYM_C = 'Extract(':Gattr.SYM_C:',':Amattr.SYM_C:',':Vmattr.SYM_C:',':Svmattr.SYM_C:')'\xFE";
    z += "        Gattr.SYM_TYPE=Type_estr\xFE";
    z += "    End\xFE";
    z += "*\xFE";
    z += "* CHECK FOR STRING EXTRACTION [EXPR,EXPR] - NEED TO RETHINK THIS - MAYBE REMOVE IT, AS CONFLICT WITH VB6 [ARRAY] - CHANGE MY ARRAYS(X,Y) TO ARRAYS[X,Y]\xFE";
    z += "*\xFE";
    z += "    If Tkno = C_lbrack Then\xFE";
    z += "        Htk = Savetk()\xFE";
    z += "        Call Tcv(False)\xFE";
    z += "        Sattr = Expr(Type_eNum,1,C_comma:C_rparen)\xFE";
    z += "        If Tkno <> C_comma Then\xFE";
    z += "            Call Restoret(Htk)\xFE";
    z += "            Call Objectparse(Gattr)\xFE";
    z += "            Return Gattr\xFE";
    z += "        End If\xFE";
    z += "\xFE";
    z += "        Call Tcv(False)\xFE";
    z += "        Lenattr = Expr(Type_eNum, 2, C_rbrack)\xFE";
    z += "        If Tkno <> C_rbrack Then Call Err('] expected') Else Call Tcv(False)\xFE";
    z += "        \xFE";
    z += "        Call Typenum(Type_vnum, Sattr)\xFE";
    z += "        Call Typenum(Type_vnum, Lenattr)\xFE";
    z += "        Call Typestr(Type_dc, Gattr)\xFE";
    z += "        Gattr.SYM_C = 'Mid1':'(':Gattr.SYM_C:', ':Sattr.SYM_C:', ':Lenattr.SYM_C:')'\xFE";
    z += "        Gattr.SYM_TYPE = Type_estr\xFE";
    z += "    End\xFE";
    z += "    Return Gattr\xFE";
    z += "\xFE";
    z += "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "Sub Objectparse(ByVal Gattr)\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "\xFE";
    z += "    Hascallback = 0\xFE";
    z += "    Objcall = Gattr.SYM_C\xFE";
    z += "    isAtResponse = ObjCall = \"At_Response\"\xFE";
    z += "    \xFE";
    z += "    Loop While Tkstr = Mobjectdelemeter Or Tkno = C_lparen Or Tkno = C_lbrack Do\xFE";
    z += "        Gattr.SYM_TYPE = Type_exp\xFE";
    z += "        If Tkstr = Mobjectdelemeter Then\xFE";
    z += "            Call Tcv(False) ;* Skip \".\"\xFE";
    z += "            If Tkno < C_ident Then\xFE";
    z += "                Call Err(\"Object's Method Identifier expected\")\xFE";
    z += "                Return\xFE";
    z += "            End If\xFE";
    z += "            if isAtResponse And tkstr = \"REDIRECT\" then Objcall = \"return \":Objcall\xFE";
    z += "            objCall := \".\":Otkstr\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "        End If\xFE";
    z += "\xFE";
    z += "        If Tkno = C_lparen Or Tkno = C_lbrack Then\xFE";
    z += "            If Tkno = C_lparen Then\xFE";
    z += "                Stopon = C_rparen\xFE";
    z += "            Else\xFE";
    z += "                Stopon = C_rbrack\xFE";
    z += "                Htk = Savetk()\xFE";
    z += "                Saveobjcall = Objcall\xFE";
    z += "            End If\xFE";
    z += "            objCall := Tkstr\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "            Pcnt = 0\xFE";
    z += "            If Tkno <> Stopon Then\xFE";
    z += "                * Loop on each parameter\xFE";
    z += "                Loop \xFE";
    z += "                    Pcnt += 1\xFE";
    z += "                    Iscallback = Tkstr = \"CALLBACK\"\xFE";
    z += "                    If Iscallback Then\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Hascallback += 1\xFE";
    z += "                        PrmList = \"\"\xFE";
    z += "                        cbAssign = \"\"\xFE";
    z += "                        If Tkno = C_lparen Then\xFE";
    z += "                            Call Tcv(False) ;* Skip (\xFE";
    z += "                            If Tkno <> C_rparen Then\xFE";
    z += "                                Loop\xFE";
    z += "                                    Pattr = Parsevar(1, 0, La:C_comma, 1)\xFE";
    z += "                                    Pname = Pattr.SYM_C\xFE";
    z += "                                    PrmList := \"_\":Pname\xFE";
    z += "                                    cbAssign := Pname:\" = _\":Pname:\"; \"\xFE";
    z += "                                While Tkno = C_comma Do\xFE";
    z += "                                    PrmList := \", \"\xFE";
    z += "                                    Call Tcv(False) ;* Skip ,\xFE";
    z += "                                Repeat\xFE";
    z += "                            End If\xFE";
    z += "                            If Tkno = C_rparen Then Call Tcv(False) Else Call Err(\"Missing )\")\xFE";
    z += "                        End If\xFE";
    z += "                        cbAssign := \"Callbacknumber = \":Hascallback:\"; resolve(Callbacknumber)\"\xFE";
    z += "                        Objcall := \"function (\":PrmList:\") { \":cbAssign:\" }\"\xFE";
    z += "\xFE";
    z += "                    End Else\xFE";
    z += "                        Pattr = Expr(Type_vstr, 1, Stopon)\xFE";
    z += "                        If Stopon = C_rbrack And Pattr.SYM_C = \"-1\" Then Pattr.SYM_C = Saveobjcall:'.length'\xFE";
    z += "                        objCall := Pattr.SYM_C\xFE";
    z += "                    End If\xFE";
    z += "                    Call SkipOverComments(False)\xFE";
    z += "                    \xFE";
    z += "                While Tkstr = \",\" Do\xFE";
    z += "                    Call Tcv(False) \xFE";
    z += "                    Call SkipOverComments(False)\xFE";
    z += "                    objCall := \",\"\xFE";
    z += "                Repeat\xFE";
    z += "                \xFE";
    z += "                If Pcnt = 2 And Stopon = C_rbrack Then\xFE";
    z += "                    Objcall = Saveobjcall\xFE";
    z += "                    Call Restoret(Htk)\xFE";
    z += "                    Break\xFE";
    z += "                End If\xFE";
    z += "            End If\xFE";
    z += "\xFE";
    z += "            If Tkno = Stopon Then\xFE";
    z += "                objCall := Tkstr\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "            Else\xFE";
    z += "                If Stopon = C_rparen Then Call Err(\"Missing closing symbol )\") Else Call Err(\"Missing closing symbol ]\")\xFE";
    z += "            End If\xFE";
    z += "        End If\xFE";
    z += "    Repeat\xFE";
    z += "\xFE";
    z += "    If Hascallback Then\xFE";
    z += "        if NotASyncFunction Then\xFE";
    z += "            Call Err('Routines with CallBacks() can not use $options IJS')\xFE";
    z += "        End If\xFE";
    z += "        objCall = \"await new Promise(resolve => \":objCall:\")\"\xFE";
    z += "        Pattr = Readsym(\"CALLBACKNUMBER\")\xFE";
    z += "        If !readSymFound Then Call Writesym(Pattr, Pattr.SYMNAME)\xFE";
    z += "        Call Uses(Pattr)\xFE";
    z += "        hasPromises[-1] = \"Has a CALLBACK\"\xFE";
    z += "    End If\xFE";
    z += "\xFE";
    z += "    Gattr.SYM_C = Objcall\xFE";
    z += "End Sub\xFE";
    z += ""
    window.cached_jsb2js["expr"] = z;
    var z = "Subroutine MakeAfromB(GattrA, GattrB)\xFE";
    z += "    $Insert _comms\xFE";
    z += "\xFE";
    z += "    Begin Case\xFE";
    z += "        Case GattrB.SYM_TYPE = Type_vnum\xFE";
    z += "            Call Typenum(Type_vnum, GattrA)\xFE";
    z += "            \xFE";
    z += "        Case Else\xFE";
    z += "            Call Typestr(Type_vstr, GattrA)\xFE";
    z += "    End Case\xFE";
    z += "End Sub\xFE";
    z += "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "Subroutine Makebool(byval Gattr, optional byval hardBool As boolean)\xFE";
    z += "    $Insert _comms\xFE";
    z += "\xFE";
    z += "    if Gattr.SYM_FLAVOR = Flavor_external Then Return\xFE";
    z += "    if Gattr.SYM_TYPE = Type_eBool Or Gattr.SYM_TYPE = Type_vBool then return\xFE";
    z += "    \xFE";
    z += "    if !hardBool Then   \xFE";
    z += "        if Index(Type_cnum:Type_vnum:Type_eNum:Type_cstr:Type_vstr:Type_estr,Gattr.SYM_TYPE,1) then return\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    Gattr.SYM_C = 'CBool(':Gattr.SYM_C:\")\"\xFE";
    z += "    Gattr.SYM_TYPE = Type_eBool\xFE";
    z += "    Return\xFE";
    z += "end sub\xFE";
    z += "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "Subroutine MakeNot(byval Gattr)\xFE";
    z += "    $Insert _comms\xFE";
    z += "\xFE";
    z += "    If Index(Type_vNum:Type_vBool:Type_eNum:Type_cnum:Type_eBool, Gattr.SYM_TYPE, 1) Then\xFE";
    z += "        Gattr.SYM_TYPE = Type_eBool\xFE";
    z += "        if InStr(Gattr.SYM_C, \" \") Then Gattr.SYM_C = \"(\":Gattr.SYM_C:\")\"\xFE";
    z += "        Gattr.SYM_C = '!':Gattr.SYM_C\xFE";
    z += "        Return\xFE";
    z += "    end if\xFE";
    z += "    \xFE";
    z += "    Call Typenum(Type_vnum, Gattr)\xFE";
    z += "\xFE";
    z += "    Gattr.SYM_TYPE = Type_eBool\xFE";
    z += "    Gattr.SYM_C = 'Not(':Gattr.SYM_C:')'\xFE";
    z += "    Return\xFE";
    z += "end sub\xFE";
    z += "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "Subroutine Makenum(byval Suggest_type, byval Gattr)\xFE";
    z += "*\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "    Begin Case\xFE";
    z += "            * -------------- UNKNOWN TYPE ------------------------\xFE";
    z += "        Case Gattr.SYM_TYPE = Type_var\xFE";
    z += "            Gattr.SYM_C = ' +':Gattr.SYM_C\xFE";
    z += "\xFE";
    z += "            * Anything that is a Variable, can receive a typing suggestion\xFE";
    z += "            If Suggest_type # Type_dc Then\xFE";
    z += "                If Not(Index(Gattr.SYM_TYPES,Suggest_type,1)) Then\xFE";
    z += "                    Gattr.SYM_TYPES=Gattr.SYM_TYPES:Suggest_type\xFE";
    z += "                    Call Writevsym(Gattr.SYM_TYPES, Gattr.SYMNAME, \"SYM_TYPES\")\xFE";
    z += "                End\xFE";
    z += "            End\xFE";
    z += "\xFE";
    z += "            * -------------- NUMERIC ------------------------\xFE";
    z += "        Case Index(Type_cnum:Type_vNum:Type_vBool:Type_eNum:Type_eBool,Gattr.SYM_TYPE,1)\xFE";
    z += "            Return\xFE";
    z += "\xFE";
    z += "            * -------------- STRINGS------------------------\xFE";
    z += "        Case Gattr.SYM_TYPE = Type_cstr And Gattr.SYM_C = \"\"\xFE";
    z += "            Gattr.SYM_C = \"0\"\xFE";
    z += "            Gattr.SYM_TYPE = Type_cnum\xFE";
    z += "            Return\xFE";
    z += "\xFE";
    z += "        Case Index(Type_cstr:Type_vstr,Gattr.SYM_TYPE,1)\xFE";
    z += "            Gattr.SYM_C = ' +':Gattr.SYM_C\xFE";
    z += "\xFE";
    z += "        Case 1 ;* Type_exp Or String (Type_cstr:Type_vstr)\xFE";
    z += "            * EXP must use CNum in case of a undefined, which +undefined turns to NaN, and we want 0\xFE";
    z += "            Gattr.SYM_C = 'CNum(':Gattr.SYM_C:\")\"\xFE";
    z += "\xFE";
    z += "    End Case\xFE";
    z += "    Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "    Return\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "Subroutine Makestr(byval Suggest_type, byval Gattr)\xFE";
    z += "*\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "    Begin Case\xFE";
    z += "            * -------------- UNKNOWN TYPE ------------------------\xFE";
    z += "        Case Gattr.SYM_TYPE = Type_var\xFE";
    z += "            If Suggest_type # Type_dc Then\xFE";
    z += "                If Not(Index(Gattr.SYM_TYPES, Suggest_type, 1)) Then\xFE";
    z += "                    Gattr.SYM_TYPES=Gattr.SYM_TYPES:Suggest_type\xFE";
    z += "                    Call Writevsym(Gattr.SYM_TYPES, Gattr.SYMNAME, \"SYM_TYPES\")\xFE";
    z += "                End\xFE";
    z += "            End\xFE";
    z += "\xFE";
    z += "        Case Index(Type_cstr:Type_estr,Gattr.SYM_TYPE,1)\xFE";
    z += "            Return\xFE";
    z += "            \xFE";
    z += "        Case Gattr.SYM_TYPE = Type_vstr\xFE";
    z += "            // We will ASSUME that if this code has assigned a value to this variable, it is not 'undefined'\xFE";
    z += "            If Gattr.SYM_ASSIGNED Then return\xFE";
    z += "           \xFE";
    z += "    End Case\xFE";
    z += "\xFE";
    z += "    Gattr.SYM_C = \"CStr(\":Gattr.SYM_C:\")\"\xFE";
    z += "    Gattr.SYM_TYPE = Type_estr\xFE";
    z += "    Return\xFE";
    z += ""
    window.cached_jsb2js["makeafromb"] = z;
    var z = "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "Sub Objectparse(ByVal Gattr)\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "\xFE";
    z += "    Hascallback = 0\xFE";
    z += "    Objcall = Gattr.SYM_C\xFE";
    z += "    isAtResponse = ObjCall = \"At_Response\"\xFE";
    z += "    \xFE";
    z += "    Loop While Tkstr = Mobjectdelemeter Or Tkno = C_lparen Or Tkno = C_lbrack Do\xFE";
    z += "        Gattr.SYM_TYPE = Type_exp\xFE";
    z += "        If Tkstr = Mobjectdelemeter Then\xFE";
    z += "            Call Tcv(False) ;* Skip \".\"\xFE";
    z += "            If Tkno < C_ident Then\xFE";
    z += "                Call Err(\"Object's Method Identifier expected\")\xFE";
    z += "                Return\xFE";
    z += "            End If\xFE";
    z += "            if isAtResponse And tkstr = \"REDIRECT\" then Objcall = \"return \":Objcall\xFE";
    z += "            objCall := \".\":Otkstr\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "        End If\xFE";
    z += "\xFE";
    z += "        If Tkno = C_lparen Or Tkno = C_lbrack Then\xFE";
    z += "            If Tkno = C_lparen Then\xFE";
    z += "                Stopon = C_rparen\xFE";
    z += "            Else\xFE";
    z += "                Stopon = C_rbrack\xFE";
    z += "                Htk = Savetk()\xFE";
    z += "                Saveobjcall = Objcall\xFE";
    z += "            End If\xFE";
    z += "            objCall := Tkstr\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "            Pcnt = 0\xFE";
    z += "            If Tkno <> Stopon Then\xFE";
    z += "                * Loop on each parameter\xFE";
    z += "                Loop \xFE";
    z += "                    Pcnt += 1\xFE";
    z += "                    Iscallback = Tkstr = \"CALLBACK\"\xFE";
    z += "                    If Iscallback Then\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Hascallback += 1\xFE";
    z += "                        PrmList = \"\"\xFE";
    z += "                        cbAssign = \"\"\xFE";
    z += "                        If Tkno = C_lparen Then\xFE";
    z += "                            Call Tcv(False) ;* Skip (\xFE";
    z += "                            If Tkno <> C_rparen Then\xFE";
    z += "                                Loop\xFE";
    z += "                                    Pattr = Parsevar(1, 0, La:C_comma, 1)\xFE";
    z += "                                    Pname = Pattr.SYM_C\xFE";
    z += "                                    PrmList := \"_\":Pname\xFE";
    z += "                                    cbAssign := Pname:\" = _\":Pname:\"; \"\xFE";
    z += "                                While Tkno = C_comma Do\xFE";
    z += "                                    PrmList := \", \"\xFE";
    z += "                                    Call Tcv(False) ;* Skip ,\xFE";
    z += "                                Repeat\xFE";
    z += "                            End If\xFE";
    z += "                            If Tkno = C_rparen Then Call Tcv(False) Else Call Err(\"Missing )\")\xFE";
    z += "                        End If\xFE";
    z += "                        cbAssign := \"Callbacknumber = \":Hascallback:\"; resolve(Callbacknumber)\"\xFE";
    z += "                        Objcall := \"function (\":PrmList:\") { \":cbAssign:\" }\"\xFE";
    z += "\xFE";
    z += "                    End Else\xFE";
    z += "                        Pattr = Expr(Type_vstr, 1, Stopon)\xFE";
    z += "                        If Stopon = C_rbrack And Pattr.SYM_C = \"-1\" Then Pattr.SYM_C = Saveobjcall:'.length'\xFE";
    z += "                        objCall := Pattr.SYM_C\xFE";
    z += "                    End If\xFE";
    z += "                    Call SkipOverComments(False)\xFE";
    z += "                    \xFE";
    z += "                While Tkstr = \",\" Do\xFE";
    z += "                    Call Tcv(False) \xFE";
    z += "                    Call SkipOverComments(False)\xFE";
    z += "                    objCall := \",\"\xFE";
    z += "                Repeat\xFE";
    z += "                \xFE";
    z += "                If Pcnt = 2 And Stopon = C_rbrack Then\xFE";
    z += "                    Objcall = Saveobjcall\xFE";
    z += "                    Call Restoret(Htk)\xFE";
    z += "                    Break\xFE";
    z += "                End If\xFE";
    z += "            End If\xFE";
    z += "\xFE";
    z += "            If Tkno = Stopon Then\xFE";
    z += "                objCall := Tkstr\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "            Else\xFE";
    z += "                If Stopon = C_rparen Then Call Err(\"Missing closing symbol )\") Else Call Err(\"Missing closing symbol ]\")\xFE";
    z += "            End If\xFE";
    z += "        End If\xFE";
    z += "    Repeat\xFE";
    z += "\xFE";
    z += "    If Hascallback Then\xFE";
    z += "        if NotASyncFunction Then\xFE";
    z += "            Call Err('Routines with CallBacks() can not use $options IJS')\xFE";
    z += "        End If\xFE";
    z += "        objCall = \"await new Promise(resolve => \":objCall:\")\"\xFE";
    z += "        Pattr = Readsym(\"CALLBACKNUMBER\")\xFE";
    z += "        If !readSymFound Then Call Writesym(Pattr, Pattr.SYMNAME)\xFE";
    z += "        Call Uses(Pattr)\xFE";
    z += "        hasPromises[-1] = \"Has a CALLBACK\"\xFE";
    z += "    End If\xFE";
    z += "\xFE";
    z += "    Gattr.SYM_C = Objcall\xFE";
    z += "End Sub\xFE";
    z += ""
    window.cached_jsb2js["objectparse"] = z;
    var z = "*********************************************************************************************************************\xFE";
    z += "Subroutine Options\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "    Call Tcv(False) ;* Skip $Define Or $Options\xFE";
    z += "    \xFE";
    z += "    ForMe = False\xFE";
    z += "    NotForMe = False\xFE";
    z += "    GotSomething = False\xFE";
    z += "    \xFE";
    z += "    Loop While Tkstr <> \"\" Do\xFE";
    z += "        Ntkstr = Mid(Tkline, Tkpos, 1)\xFE";
    z += "        ExitDo = False\xFE";
    z += "        \xFE";
    z += "        Select Case Tkstr\xFE";
    z += "            Case \"R\", \"R83\"\xFE";
    z += "                Mr83 = Ntkstr <> \"-\"\xFE";
    z += "\xFE";
    z += "            Case \"S\", \"SUPPRESSDEBUGGING\", \"NODEBUG\"\xFE";
    z += "                Adddebugging = Ntkstr = \"-\"\xFE";
    z += "                \xFE";
    z += "                Ocpgms = Join(Ocpgm, Chr(254))\xFE";
    z += "                If !Adddebugging Then Ocpgms = Change(Ocpgms, \"await dbgCheck(me, \", \"// await dbgCheck(me,\")\xFE";
    z += "                Ocpgm = Split(Ocpgms, Chr(254))  \xFE";
    z += "                \xFE";
    z += "                \xFE";
    z += "            Case \"%\", \"CASESENSITIVE\"\xFE";
    z += "                Casesen = Ntkstr <> \"-\"\xFE";
    z += "\xFE";
    z += "            Case \"EXPLICIT\", \"E\"\xFE";
    z += "                Optionexplicit = Ntkstr <> \"-\"\xFE";
    z += "\xFE";
    z += "            Case \"H\", \"HUSH\"\xFE";
    z += "                Hush = Ntkstr <> \"-\"\xFE";
    z += "\xFE";
    z += "            Case \"JS\"\xFE";
    z += "                if Ntkstr = \"-\" Then \xFE";
    z += "                    NotForMe = True \xFE";
    z += "                    ForMe = False\xFE";
    z += "                    GotSomething = True\xFE";
    z += "                    ExitDo = True\xFE";
    z += "                Else \xFE";
    z += "                    ForMe = True\xFE";
    z += "                End If\xFE";
    z += "\xFE";
    z += "            Case \"ASPX\", \"GAE\", \"XXX\", \"ASPX_END\", \"ASPXEND\"\xFE";
    z += "                NotForMe = True\xFE";
    z += "\xFE";
    z += "            Case \"JS_END\", \"JSEND\", \"JS.END\"\xFE";
    z += "                ' NO MORE CODE IN THIS ROUTINE\xFE";
    z += "                Tkam = Findendofsub(Itemsrc, Tkam)\xFE";
    z += "                Skiprestofline()\xFE";
    z += "\xFE";
    z += "            Case \"GAE_END\", \"GAEEND\", \"JS_END\", \"JSEND\"\xFE";
    z += "\xFE";
    z += "            Case \";\", \"!\", \"*\"\xFE";
    z += "                ExitDo = True\xFE";
    z += "                Exit Do\xFE";
    z += "\xFE";
    z += "            Case \",\", \"ASPXC\"\xFE";
    z += "                \xFE";
    z += "            Case \"ASYNC\", \"AWAIT\"\xFE";
    z += "                // No setByRefValuess\xFE";
    z += "                NotASyncFunction = Ntkstr = \"-\"\xFE";
    z += " \xFE";
    z += "             Case \"IJS\"\xFE";
    z += "                // No setByRefValuess\xFE";
    z += "                NotASyncFunction = Ntkstr <> \"-\"\xFE";
    z += "                ByRefsNotAllowed = Ntkstr <> \"-\"\xFE";
    z += "                dontMorphFunctionName = Ntkstr <> \"-\"\xFE";
    z += "               \xFE";
    z += "            \xFE";
    z += "            Case \"EXTERNAL\", \"EXTERN\", \"INTERNAL\", \"LOCAL\", \"FUNCTION\"\xFE";
    z += "                GotSomething = False\xFE";
    z += "                ExitDo = True\xFE";
    z += "                Exit Do\xFE";
    z += "                \xFE";
    z += "                \xFE";
    z += "            Case Else\xFE";
    z += "            debug\xFE";
    z += "                GotSomething = False\xFE";
    z += "                ExitDo = True\xFE";
    z += "                Exit Do\xFE";
    z += "        End Select\xFE";
    z += "        If ExitDo Then Exit Do\xFE";
    z += "        \xFE";
    z += "        GotSomething = True\xFE";
    z += "        If Ntkstr = \"-\" Then Call Tcv(False)\xFE";
    z += "\xFE";
    z += "        Ntkstr = Left(LTrim(Mid(Tkline, Tkpos, 2)), 1)\xFE";
    z += "        If Ntkstr <> \",\" Then Exit Do\xFE";
    z += "        Call Tcv(False)\xFE";
    z += "        Call Tcv(False)\xFE";
    z += "    Repeat\xFE";
    z += "\xFE";
    z += "    If GotSomething Then\xFE";
    z += "        If NotForMe And Not(ForMe) Then\xFE";
    z += "            If !Subname Then\xFE";
    z += "                Tkam = UBound(Itemsrc) + 99\xFE";
    z += "            Else\xFE";
    z += "                Tkam = Findendofsub(Itemsrc, Tkam)\xFE";
    z += "            End If\xFE";
    z += "            functionType = 3 ; *  Make Po Not Do Anything\xFE";
    z += "            holdHush = hush; hush = true\xFE";
    z += "            Call Skiprestofline()\xFE";
    z += "            hush = holdHush\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "        Else\xFE";
    z += "            Call Skiprestofline()\xFE";
    z += "        End If\xFE";
    z += "        Return\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    hasExternalPrefix = Tkstr = 'EXTERNAL' Or Tkstr = 'EXTERN'\xFE";
    z += "    If hasExternalPrefix Then Call Tcv(False)\xFE";
    z += "\xFE";
    z += "    // Allow local variable of a specific name\xFE";
    z += "    optionsInternal = Tkstr = 'JAVASCRIPT' Or Tkstr = 'INTERNAL' Or Tkstr = 'LOCAL'\xFE";
    z += "    If optionsInternal Then Call Tcv(False)\xFE";
    z += "\xFE";
    z += "    isExternalFunction = Tkstr = 'FUNCTION' Or Tkstr = \"FUNC\"\xFE";
    z += "    isExternalSub = Tkstr = 'SUBROUTINE' Or Tkstr = \"SUB\"\xFE";
    z += "    \xFE";
    z += "    if !isExternalFunction And !isExternalSub Then\xFE";
    z += "        if hasExternalPrefix Then\xFE";
    z += "            Call Typedef(Flavor_external, True /* Process Commas */, optionsInternal /* isObject */)\xFE";
    z += "        Else\xFE";
    z += "            Call Typedef(Flavor_local, True /* Process Commas */, optionsInternal /* isObject */)\xFE";
    z += "        End If\xFE";
    z += "        Return\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    Call Tcv(False) ;* Skip Function\xFE";
    z += "    \xFE";
    z += "// ******************** CODE only for internal / external functions // ******************** \xFE";
    z += "*\xFE";
    z += "* Functions and subroutines that are internal or external\xFE";
    z += "*\xFE";
    z += "    Pdef = {}\xFE";
    z += "    Pdef.SUB_COMPILEDATE = 'Called on ':Timedate():' in ':Itemid\xFE";
    z += "    Pdef.SUB_ISEXTERNAL = true\xFE";
    z += "    Pdef.SUB_NOAWAITSALLOWED = optionsInternal or hasExternalPrefix\xFE";
    z += "    \xFE";
    z += "    If Tkno <> C_ident Then Call Err('Subroutine identifier expected')\xFE";
    z += "  \xFE";
    z += "    Pdef.SUB_CNAME = Otkstr \xFE";
    z += "    Pdef.SUB_SUBNAME = Tkstr\xFE";
    z += "    Call Tcv(False)\xFE";
    z += "*\xFE";
    z += "* Loop on each parameter, build PARAMTYPES\xFE";
    z += "*\xFE";
    z += "    Parami = 0\xFE";
    z += "    Paramtypes = ''\xFE";
    z += "    If Tkno = C_lparen Then\xFE";
    z += "        Call Tcv(False)\xFE";
    z += "        If Tkno <> C_rparen Then\xFE";
    z += "            La  = La:C_comma\xFE";
    z += "            Loop\xFE";
    z += "                Parami = Parami + 1\xFE";
    z += "                Pattr = {}\xFE";
    z += "                Pattr.SYMNAME = Tkstr\xFE";
    z += "                Pattr.SYM_FLAVOR = Flavor_parameter\xFE";
    z += "                Pattr.SYM_C = Makevarname(Otkstr)\xFE";
    z += "                Pattr.SYM_ISCONST = Docbadr\xFE";
    z += "                Pattr.SYM_ISBYVAL = hasExternalPrefix Or optionsInternal\xFE";
    z += "                \xFE";
    z += "                if tkstr = \"BYREF\" then\xFE";
    z += "                    Pattr.SYM_ISBYVAL = False\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    \xFE";
    z += "                elseif tkstr = \"BYVAL\" then\xFE";
    z += "                    Pattr.SYM_ISBYVAL = True\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    \xFE";
    z += "                else If Tkstr = 'CONST' Then\xFE";
    z += "                    Docbadr = 1\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                End Else\xFE";
    z += "                    Docbadr = 0\xFE";
    z += "                End\xFE";
    z += "\xFE";
    z += "                If Tkno < C_ident Then Call Err('Variable expected')\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                \xFE";
    z += "                *\xFE";
    z += "                * CHECK FOR DIM()'S\xFE";
    z += "                *\xFE";
    z += "                If Tkno = C_lparen Then\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    Lattr = Expr(Type_estr,1,C_comma:C_rparen)\xFE";
    z += "                    If Lattr.SYM_TYPE = Type_cnum Or (Lattr.SYM_TYPE = Type_eNum And Lattr.SYM_FLAVOR = Flavor_equate) Then\xFE";
    z += "                        Pattr.SYM_INDEX1 = Lattr.SYM_C\xFE";
    z += "                    End Else Call Err('Integer constant expected')\xFE";
    z += "                    *\xFE";
    z += "                    If Tkno = C_comma Then\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Lattr = Expr(Type_estr,1,C_comma:C_rparen)\xFE";
    z += "                        If Lattr.SYM_TYPE = Type_cnum Or (Lattr.SYM_TYPE = Type_eNum And Lattr.SYM_FLAVOR = Flavor_equate) Then\xFE";
    z += "                            Pattr.SYM_INDEX2 = Lattr.SYM_C\xFE";
    z += "                        End Else Call Err('Integer constant expected')\xFE";
    z += "                    End\xFE";
    z += "                    *\xFE";
    z += "                    If Tkno <> C_rparen Then Call Err(') expected') Else Call Tcv(False)\xFE";
    z += "                End\xFE";
    z += "                \xFE";
    z += "                If Pattr.SYM_ISCONST And Pattr.SYM_INDEX1 Then\xFE";
    z += "                    Call Err('MAT variables can not be CONST')\xFE";
    z += "                End\xFE";
    z += "                \xFE";
    z += "                Call parseAStype(Pattr)\xFE";
    z += "                                \xFE";
    z += "                *\xFE";
    z += "                * CHECK FOR FIXED LENGTH STRINGS[]'S\xFE";
    z += "                *\xFE";
    z += "                If Pattr.SYM_TYPE = Type_vstr Then\xFE";
    z += "                    Pattr.SYM_STRLEN = Dftstrlen\xFE";
    z += "                    If Tkno = C_lbrack Then\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Lattr = Expr(Type_estr,1,C_rparen)\xFE";
    z += "                        If Lattr.SYM_TYPE = Type_cnum Or (Lattr.SYM_TYPE = Type_eNum And Lattr.SYM_FLAVOR = Flavor_equate) Then\xFE";
    z += "                            Pattr.SYM_STRLEN = Lattr.SYM_C\xFE";
    z += "                        End Else Call Err('Integer constant expected')\xFE";
    z += "                        If Tkno <> C_rbrack Then Call Err('] expected') Else Call Tcv(False)\xFE";
    z += "                    End\xFE";
    z += "                End\xFE";
    z += "          \xFE";
    z += "                buildDecs = Builddec(Pattr)\xFE";
    z += "                Paramtypes<Parami> = UCase(buildDecs.Calldef) ;* Build Calldef - ByVal - uppercase\xFE";
    z += "                \xFE";
    z += "            While Tkno = C_comma Do\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "            Repeat\xFE";
    z += "            La = La[1,Len(La)-1]\xFE";
    z += "        End\xFE";
    z += "        If Tkno <> C_rparen Then Call Err(') expected') Else Call Tcv(False)\xFE";
    z += "    End\xFE";
    z += "    \xFE";
    z += "    // return type?\xFE";
    z += "    If isExternalFunction Then\xFE";
    z += "        Gattr = {}\xFE";
    z += "        if Tkstr = \"AS\" Then\xFE";
    z += "            Call parseAStype(Gattr) ;* Check For As Integer, As Long, Etc.\xFE";
    z += "            Gattr.SYM_FLAVOR = Flavor_function\xFE";
    z += "            Gattr.SYM_ISCONST = 1 ;* Can't assign to function name\xFE";
    z += "            buildDecs = Builddec(Gattr) ;* Build Calldef\xFE";
    z += "            Pdef.SUB_RTNTYPE = buildDecs.Calldef\xFE";
    z += "        Else\xFE";
    z += "            Pdef.SUB_RTNTYPE = Type_exp\xFE";
    z += "        End If\xFE";
    z += "    End\xFE";
    z += "    \xFE";
    z += "    Pdef.SUB_PARAMTYPES = Replace(Paramtypes, Am(), ',')\xFE";
    z += "    \xFE";
    z += "    * Need to make this available in XREFS without writing to the actual file\xFE";
    z += "    \xFE";
    z += "    xdefID = LCase(pcfname:\"_\":Pdef.SUB_SUBNAME)\xFE";
    z += "    if isExternalFunction Then xdefID := \"_fnc\" Else xdefID := \"_sub\"\xFE";
    z += "    xdefID := \".def\"\xFE";
    z += "    cached_XRefs[xdefID] = Pdef\xFE";
    z += "    Return\xFE";
    z += "    \xFE";
    z += "*\xFE";
    z += "* Make this $options external function visible\xFE";
    z += "*\xFE";
    z += "    Locate ucName In UC_externals_purejs_list Setting isExternalI Else isExternalI = 0\xFE";
    z += "    \xFE";
    z += "    If hasExternalPrefix Then\xFE";
    z += "        ucName = Pdef.SUB_CNAME\xFE";
    z += "        if isExternalI Then\xFE";
    z += "            If externals_purejs_list<isExternalI> <> Pdef.SUB_SUBNAME Then\xFE";
    z += "                Call Warning(\"You changed the name (case sensitive) declared in config_jsb2js from \":externals_purejs_list<isExternalI>:\" to \":Pdef.SUB_SUBNAME)\xFE";
    z += "            End If\xFE";
    z += "            UC_externals_purejs_list = Delete(UC_externals_purejs_list, isExternalI)\xFE";
    z += "            externals_purejs_list = Delete(externals_purejs_list, isExternalI)\xFE";
    z += "        End If\xFE";
    z += "        \xFE";
    z += "        externals_purejs_list<-1> = Pdef.SUB_SUBNAME\xFE";
    z += "        UC_externals_purejs_list<-1> = ucName\xFE";
    z += "    End If\xFE";
    z += "*\xFE";
    z += "    Return\xFE";
    z += "End Subroutine"
    window.cached_jsb2js["options"] = z;
    var z = "// Beginning of a functin, sub, or program parse\xFE";
    z += "\xFE";
    z += "Subroutine Parseprogram\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "\xFE";
    z += "    functionType = 0 ;* -1) Commons, 0) Program, 1) Subroutine, 2) function, 3) @@function (Server Only Compile), 4) Pick/RESTFUL function\xFE";
    z += "    Hadgosub = 0\xFE";
    z += "    First_subname = Tkstr\xFE";
    z += "    Truefirst_subname = Otkstr\xFE";
    z += "    \xFE";
    z += "    Calllist = []\xFE";
    z += "    Ispickfunction = 0\xFE";
    z += "    IsRestfulFunction = 0\xFE";
    z += "    IgnoreErrors = 0\xFE";
    z += "    Endclause = \"\"\xFE";
    z += "    Docatalog = 0\xFE";
    z += "    Paramlist = []\xFE";
    z += "    NotASyncFunction = Instr(Options, '@')\xFE";
    z += "    hasPromises = []\xFE";
    z += "    Haslbl = 0\xFE";
    z += "    \xFE";
    z += "    NotASyncFunction = false\xFE";
    z += "    ByRefsNotAllowed = false\xFE";
    z += "    literalName = false\xFE";
    z += "    dontMorphFunctionName = false\xFE";
    z += "    \xFE";
    z += "    Oc = ''\xFE";
    z += "    Blankok = 0\xFE";
    z += "    Cpassthru = 0\xFE";
    z += "    Ocpgm = []\xFE";
    z += "    \xFE";
    z += "    Lcllbl = 10000                  ; * Local Labels\xFE";
    z += "    Funcattr = {}\xFE";
    z += "\xFE";
    z += "    Call Skipovercomments(True)\xFE";
    z += "\xFE";
    z += "    If Tkstr = \"RESTFUL\" Then\xFE";
    z += "        IsRestfulFunction = 1\xFE";
    z += "        Call Tcv(False)\xFE";
    z += "        If Tkstr <> \"FUNCTION\" Then Call Err(\"FUNCTION EXPECTED\")\xFE";
    z += "        Tkstr = \"PROGRAM\"\xFE";
    z += "        Endclause = \"END FUN\"\xFE";
    z += "\xFE";
    z += "    End Else If Tkstr = \"PICK\" Then\xFE";
    z += "        Ispickfunction = 1\xFE";
    z += "        functionType = 0 ;* Program\xFE";
    z += "        Docatalog = 1\xFE";
    z += "        Call Tcv(False)\xFE";
    z += "        If Tkstr <> \"FUNCTION\" Then Call Err(\"FUNCTION EXPECTED\")\xFE";
    z += "        Tkstr = \"PROGRAM\"\xFE";
    z += "        Endclause = \"END FUN\"\xFE";
    z += "    End If\xFE";
    z += "\xFE";
    z += "    Subtype = Tkstr\xFE";
    z += "    Subname = \"\"\xFE";
    z += "    Truesubname = \"\"\xFE";
    z += "    if Mid(tkline, tkpos + 1, 1) = `\\` Then \xFE";
    z += "        literalName = true\xFE";
    z += "        dontMorphFunctionName = true\xFE";
    z += "    end if\xFE";
    z += "    \xFE";
    z += "    If Tkstr = \"FUNCTION\" Or Tkstr = \"FUNC\" Then\xFE";
    z += "        Endclause = \"END FUN\"\xFE";
    z += "        If IsRestfulFunction Or Ispickfunction Then functionType = 4 Else functionType = 2\xFE";
    z += "\xFE";
    z += "\xFE";
    z += "        Call Tcv(False) ; * Skip Func\xFE";
    z += "        \xFE";
    z += "        Loop\xFE";
    z += "            Subname = Subname:Tkstr\xFE";
    z += "            Truesubname = Truesubname:Otkstr\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "        While Tkstr = Mobjectdelemeter Do\xFE";
    z += "            Subname = Subname:Mobjectdelemeter\xFE";
    z += "            Truesubname = Truesubname:Mobjectdelemeter\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "        Repeat\xFE";
    z += "        If Insideclass Then Subname = Classname:\"_\":Subname\xFE";
    z += "\xFE";
    z += "        Funcattr.SYMNAME = Subname\xFE";
    z += "        Call parseAStype(Funcattr)\xFE";
    z += "        Funcattr.SYM_C = \"_functionResult\"\xFE";
    z += "        Funcattr.SYM_FLAVOR = Flavor_function\xFE";
    z += "        Funcattr.SYM_C = Makesubname(Funcattr.SYM_C)\xFE";
    z += "\xFE";
    z += "    End Else If Tkstr = \"SUBROUTINE\" Or Tkstr = \"SUB\" Then\xFE";
    z += "        Endclause = \"END SUB\"\xFE";
    z += "        functionType = 1 // Subroutine\xFE";
    z += "        Call Tcv(False) ; * Skip \"SUBROUTINE\"\xFE";
    z += "        Loop\xFE";
    z += "            Subname = Subname:Tkstr\xFE";
    z += "            Truesubname = Truesubname:Otkstr\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "        While Tkstr = Mobjectdelemeter Do\xFE";
    z += "            Subname = Subname:Tkstr\xFE";
    z += "            Truesubname = Truesubname:Mobjectdelemeter\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "        Repeat\xFE";
    z += "        If Insideclass Then Subname = Classname:\"_\":Subname\xFE";
    z += "\xFE";
    z += "    End Else If Tkstr = \"PROGRAM\" Then\xFE";
    z += "        functionType = 0 // Program\xFE";
    z += "        If !Endclause Then Endclause = \"END PRO\"\xFE";
    z += "        Docatalog = 1\xFE";
    z += "        Call Tcv(False) ; * Skip Program\xFE";
    z += "        Loop\xFE";
    z += "            Subname = Subname:Tkstr\xFE";
    z += "            Truesubname = Truesubname:Otkstr\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "        While Tkstr = Mobjectdelemeter Do\xFE";
    z += "            Subname = Subname:Tkstr\xFE";
    z += "            Truesubname = Truesubname:Mobjectdelemeter\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "        Repeat\xFE";
    z += "\xFE";
    z += "    End Else If Tkstr = \"COMMONS\" Or Tkstr = \"GLOBALS\" Then\xFE";
    z += "        Endclause = \"END \":Left(Tkstr, 3)\xFE";
    z += "        functionType = -1 // Commons\xFE";
    z += "        Call Tcv(False) ; * Skip \"Globals\"\xFE";
    z += "        \xFE";
    z += "        if Tkno = C_ident Then\xFE";
    z += "            Subname = Tkstr\xFE";
    z += "            Truesubname = Otkstr\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "        End If\xFE";
    z += "\xFE";
    z += "    End Else\xFE";
    z += "        functionType = 0 // Program  \xFE";
    z += "        Endclause = \"END PRO\"\xFE";
    z += "        Subname = Itemid\xFE";
    z += "        Truesubname = Itemid\xFE";
    z += "    End\xFE";
    z += "\xFE";
    z += "    if !literalName Then Subname = makesubname(Subname)\xFE";
    z += "    \xFE";
    z += "*\xFE";
    z += "* a @@function ? (SKIP - NEEDS TO BE COMPILED ON SERVER)\xFE";
    z += "*\xFE";
    z += "    If (functionType > 0 And Tkno = C_at) Then\xFE";
    z += "        Scode = Tkline\xFE";
    z += "        If Tkno = C_at Then\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "            If Tkno = C_at Then Call Tcv(False)\xFE";
    z += "            Subname = Tkstr\xFE";
    z += "        End If\xFE";
    z += "\xFE";
    z += "        ' GET CODE\xFE";
    z += "        Loop Until UCase(Left(Trim(Tkline), 7)) = Endclause Or Tkam >= UBound(Itemsrc) Do\xFE";
    z += "            Tkam += 1\xFE";
    z += "            Tkline = Itemsrc[Tkam]\xFE";
    z += "        Repeat\xFE";
    z += "        functionType = 3  // @@function \xFE";
    z += "        Tkpos = 9999\xFE";
    z += "        Tkno = C_am\xFE";
    z += "\xFE";
    z += "        Call Tcv(False)\xFE";
    z += "\xFE";
    z += "        Call Skipovercomments(True)\xFE";
    z += "        \xFE";
    z += "        Ocpgm = []\xFE";
    z += "        Subname = \"\"\xFE";
    z += "        Return\xFE";
    z += "    End If\xFE";
    z += "*\xFE";
    z += "* Setup ME for classes\xFE";
    z += "*\xFE";
    z += "    If Insideclass Then\xFE";
    z += "        Gattr = {}\xFE";
    z += "        Gattr.SYM_FLAVOR = Flavor_parameter\xFE";
    z += "        Gattr.SYM_TYPE = Type_var\xFE";
    z += "        Gattr.SYM_INCLEVEL = Incfile\xFE";
    z += "        Gattr.SYM_ISCONST = 0\xFE";
    z += "        Gattr.SYM_ISBYVAL = False\xFE";
    z += "        Gattr.SYMNAME = \"ME\"\xFE";
    z += "        Gattr.SYM_C = \"me._p1\"\xFE";
    z += "\xFE";
    z += "        Call Writesym(Gattr, Gattr.SYMNAME)\xFE";
    z += "    Else\xFE";
    z += "        Paramlist = [] ;* Built By Typedef With FLAVOR_Parameters\xFE";
    z += "    End If\xFE";
    z += "*\xFE";
    z += "* Look ahead for options NotASyncFunction ( for TYPEDEF )\xFE";
    z += "*\xFE";
    z += "    A = savetk()\xFE";
    z += "    holdHush = hush\xFE";
    z += "    hush = true\xFE";
    z += "    Call Skiprestofline\xFE";
    z += "    Call Skipovercomments(True)\xFE";
    z += "    If functionType = 3 Then Return ;* @@function Server Side Rest Funciton (Or Rejected)\xFE";
    z += "    Call Restoret(A, true)\xFE";
    z += "    hush = holdHush\xFE";
    z += "    Ocpgm = []\xFE";
    z += "    Oc = \"\"\xFE";
    z += "    \xFE";
    z += "    If Not(Hush) Then Print Truesubname:\xFE";
    z += "*\xFE";
    z += "* PARSE POSSIBLE FUNCTION PARAMETERS\xFE";
    z += "*\xFE";
    z += "    Paramlist = [] // will be built by:  Call Typedef(Flavor_parameter, ...)\xFE";
    z += "    If Insideclass Then Paramlist[-1] = \"ME\"\xFE";
    z += "    optionalParamCnt = 0\xFE";
    z += "    hasByRefParamters = 0\xFE";
    z += "    \xFE";
    z += "    If Tkno = C_lparen Then\xFE";
    z += "        Call Tcv(False)\xFE";
    z += "        If Tkno = C_rparen Then\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "            If IsRestfulFunction Then\xFE";
    z += "                Tkline = \"Body = @Request\" : Mobjectdelemeter : \"Body; \" ; Tkpos = 1 ; Tkno = \"\" ; Call Tcv(False)\xFE";
    z += "                IsAtAtFunction = False\xFE";
    z += "            End If\xFE";
    z += "        Else\xFE";
    z += "            If IsRestfulFunction Or Ispickfunction Then\xFE";
    z += "                restSetup = \"\"\xFE";
    z += "                For ParamI = 1 To 999\xFE";
    z += "                    If Tkstr = 'BYVAL' Then Call Tcv(False) ;* All Parameters Are Considered Byval For Restful Functions\xFE";
    z += "                    restSetup := Tkstr : \" = @jsb_bf.ParamVar('\" : Tkstr : \"', \" : ParamI : \"); \"\xFE";
    z += "                    Call Typedef(Flavor_local, False /* Process Commas */, False /* isObject */)\xFE";
    z += "                    If Tkno = C_comma Then Call Tcv(False) Else Break\xFE";
    z += "                Next\xFE";
    z += "\xFE";
    z += "                If Tkno <> C_rparen Then Call Err(\") expected\") Else Call Tcv(False)\xFE";
    z += "\xFE";
    z += "                ' Re-Parse\xFE";
    z += "                Tkline = restSetup\xFE";
    z += "                Tkpos = 1 ; Tkno = \"\" ; Call Tcv(False)\xFE";
    z += "\xFE";
    z += "                IsAtAtFunction = False\xFE";
    z += "            Else\xFE";
    z += "                For ParamI = 1 To 999\xFE";
    z += "                    If Tkstr = 'OPTIONAL' Then\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        optionalParamCnt += 1\xFE";
    z += "                        \xFE";
    z += "                    ElseIf optionalParamCnt Then\xFE";
    z += "                        Call Err('Optional keyword expected')\xFE";
    z += "                        optionalParamCnt += 1\xFE";
    z += "                        \xFE";
    z += "                    End If\xFE";
    z += "                    \xFE";
    z += "                    If Tkstr = 'BYVAL' Then\xFE";
    z += "                        A = savetk()\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Call Restoret(A)\xFE";
    z += "                    Else\xFE";
    z += "                        If ByRefsNotAllowed Then Call Err('All parameters must be defined BYVAL with $options IJS')\xFE";
    z += "                        hasByRefParamters += 1\xFE";
    z += "                    End If\xFE";
    z += "                    \xFE";
    z += "                    Call Typedef(Flavor_parameter, False /* Process Commas */, False /* isObject */)\xFE";
    z += "                    If Tkno = C_comma Then Call Tcv(False) Else Break\xFE";
    z += "                Next\xFE";
    z += "\xFE";
    z += "                If Tkno <> C_rparen Then Call Err(\") expected\") Else Call Tcv(False)\xFE";
    z += "            End If\xFE";
    z += "        End\xFE";
    z += "    End\xFE";
    z += "\xFE";
    z += "    If Tkstr = \"AS\" Then Call ParseAsType(Funcattr)\xFE";
    z += "    \xFE";
    z += "    if !literalName Then Call afterHeaderParse()\xFE";
    z += "    \xFE";
    z += "    Indent = 4\xFE";
    z += "    Oc := Space(Indent)\xFE";
    z += "\xFE";
    z += "    If IsRestfulFunction Or Ispickfunction Then\xFE";
    z += "        Gattr = {}\xFE";
    z += "        Gattr.SYM_FLAVOR = Flavor_local\xFE";
    z += "        Gattr.SYM_TYPE = Type_var\xFE";
    z += "        Gattr.SYM_TYPES = Symtypes_stored\xFE";
    z += "        Gattr.SYM_USED = 1\xFE";
    z += "        Gattr.SYM_INCLEVEL = Incfile\xFE";
    z += "        Gattr.SYM_ISCONST = 0\xFE";
    z += "        Gattr.SYM_ISBYVAL = False\xFE";
    z += "        Gattr.SYMNAME = \"RESTFUL_RESULT\"\xFE";
    z += "        Gattr.SYM_C = \"Restful_Result\"\xFE";
    z += "        Call Writesym(Gattr, Gattr.SYMNAME)\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    if InStr(@Sentence, \"!\") Then Debug\xFE";
    z += "    \xFE";
    z += "    if Globals Then \xFE";
    z += "        ucIFileName = UCase(Pcfname)\xFE";
    z += "        ucIItemName = ucase(ItemId)\xFE";
    z += "    \xFE";
    z += "        CommonsName = \"Commons_\":ucIFileName // :\"_\":Makevarname(ItemId)\xFE";
    z += "        EquatesName = \"Equates_\":ucIFileName // :\"_\":Makevarname(ItemId)\xFE";
    z += "        includeSubName = `Include_`:ucIFileName:`_`:Makevarname(ItemId)\xFE";
    z += "    \xFE";
    z += "        // a predefined \"Commons\" block?\xFE";
    z += "        symList = incFilesSrc['DICT+':ucIFileName:\"+\":ucIItemName:'.sym']\xFE";
    z += "\xFE";
    z += "        symList = JSON(SymList)\xFE";
    z += "        Call Readinc(Symlist)\xFE";
    z += "\xFE";
    z += "        * CREATE A GLOBAL SYMBOL CALLED INAME, so we know if the commons was initted\xFE";
    z += "        Gattr = {}\xFE";
    z += "        Gattr.SYM_FLAVOR = Flavor_common\xFE";
    z += "        Gattr.SYM_INCLEVEL = Incfile + 1\xFE";
    z += "        Gattr.SYM_ISCONST = 0\xFE";
    z += "        Gattr.SYM_ISBYVAL = False\xFE";
    z += "        Gattr.SYMNAME = ucIItemName\xFE";
    z += "        Gattr.SYM_TYPE = Type_var\xFE";
    z += "        F = ItemId; F = Makevarname(F);  \xFE";
    z += "        Gattr.SYM_C = CommonsName\xFE";
    z += "        Call Writesym(Gattr, Gattr.SYMNAME)\xFE";
    z += "\xFE";
    z += "        // Should subs & funcs check if commons is there? - yes - possible that we are called from a different project\xFE";
    z += "        l = Space(Indent)\xFE";
    z += "        if NotASyncFunction Then l := 'await '\xFE";
    z += "        l := includeSubName\xFE";
    z += "        l := \"(\"\xFE";
    z += "        if functionType then l := \"false\" else l := \"true\"\xFE";
    z += "        l := \")\"\xFE";
    z += "        OcPgm[-1] = l\xFE";
    z += "    \xFE";
    z += "    end if   \xFE";
    z += "                \xFE";
    z += "    If Tkstr = \"{\" Then\xFE";
    z += "        Call Tcv(False)\xFE";
    z += "        Call States(1,\"\")\xFE";
    z += "        If Tkstr = \"}\" Then Call Tcv(False) Else Call Err(\"} expected - function ending\")\xFE";
    z += "    End Else\xFE";
    z += "        Call States(1,\"\")\xFE";
    z += "    End If\xFE";
    z += "\xFE";
    z += "    If IsRestfulFunction Or Ispickfunction Then\xFE";
    z += "        ' Re-Parse\xFE";
    z += "        Tkline = Space(3) : \"restful_ServerExit: window.ClearScreen(); r = window.JSON.stringify(Restful_Result); cb = @paramvar('callback'); if cb Then Print cb:'(':r:')': Else Print r:\"\xFE";
    z += "        Tkpos = 1 ; Tkno = \"\" ; Call Tcv(False)\xFE";
    z += "        Call States(1, \"\")\xFE";
    z += "        If Tkno = C_end Then Call Tcv(False)\xFE";
    z += "    End If\xFE";
    z += "\xFE";
    z += "    If Len(La) # 2 Then Call Err('Length of LA incorrect')\xFE";
    z += "    If Tkno = C_end Then\xFE";
    z += "        Htk = savetk()\xFE";
    z += "        Call Tcv(False)\xFE";
    z += "        If Tkstr = \"RESTFUL\" Then Call Tcv(False)\xFE";
    z += "        If Tkstr = \"FUNCTION\" Or Tkstr = \"SUBROUTINE\" Or Tkstr = \"FUNC\" Or Tkstr = \"SUB\" Or Tkstr = \"PROGRAM\" Or Tkstr = \"GLOBALS\" Or Tkstr = \"COMMONS\" Then\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "        Else\xFE";
    z += "            Call Restoret(Htk)\xFE";
    z += "        End If\xFE";
    z += "    End If\xFE";
    z += "\xFE";
    z += "    Call Skipovercomments(True)\xFE";
    z += "\xFE";
    z += "    Return\xFE";
    z += "End Sub\xFE";
    z += "\xFE";
    z += "function cspc_truefilename(byval fname)\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "    \xFE";
    z += "    ucFName = UCase(fname)\xFE";
    z += "    if ucFName = \"HTML\" Then Return \"JSB_HTML\"\xFE";
    z += "    if ucFName = \"BF\" Then Return \"JSB_BF\"\xFE";
    z += "    if ucFName = \"CTLS\" Then Return \"JSB_CTLS\"\xFE";
    z += "    if ucFName = \"TCL\" Then Return \"JSB_TCL\"\xFE";
    z += "    if ucFName = \"ODB\" Then Return \"JSB_ODB\"\xFE";
    z += "    if ucFName = \"THEMES\" Then Return \"JSB_THEMES\"\xFE";
    z += "    if ucFName = \"CSPC\" Then Return \"jsb2js\"\xFE";
    z += "    if ucFName = \"JSB_CSPC\" Then Return \"jsb2js\"\xFE";
    z += "    if ucFName = \"MDL\" Then Return \"JSB_MDL\"\xFE";
    z += "    if ucFName = \"DEMOS\" Then Return \"JSB_DEMOS\"\xFE";
    z += "    if ucFName = Cur_fname then Return Cur_realfname\xFE";
    z += "    if ucFName = Pcfname then Return Realpcfname\xFE";
    z += "    \xFE";
    z += "    return fname // can't call truefilename as this is an NotASyncFunction routine\xFE";
    z += "end function\xFE";
    z += "            \xFE";
    z += "*\xFE";
    z += "* Called once per Item - not sub\xFE";
    z += "*\xFE";
    z += "Subroutine Baseconv(byval Fname, byval Iid)\xFE";
    z += "*\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "    Dim F_temp As Long\xFE";
    z += "    Dim I As Long\xFE";
    z += "*\xFE";
    z += "    Cur_fname = Null\xFE";
    z += "    Cur_realfname = Null\xFE";
    z += "    Itemsrc = Null\xFE";
    z += "\xFE";
    z += "    Open \"\", Fname To F_temp Else\xFE";
    z += "        Print 'File not found: ':Fname\xFE";
    z += "        F_temp = ''\xFE";
    z += "        Return\xFE";
    z += "    End\xFE";
    z += "*\xFE";
    z += "    F_file = F_temp\xFE";
    z += "    Open \"DICT\", Fname To D_file Else\xFE";
    z += "        Print 'File not found: DICT':Fname\xFE";
    z += "        Stop\xFE";
    z += "    End\xFE";
    z += "*\xFE";
    z += "    Read Itemsrc From F_file, Iid Else\xFE";
    z += "        Print 'Item not found ':Iid\xFE";
    z += "        Return\xFE";
    z += "    End\xFE";
    z += "\xFE";
    z += "    Cur_fname = Fname\xFE";
    z += "    Cur_realfname = Truefilename(Fname)\xFE";
    z += "    Cur_realfname = makesubname(Cur_realfname)\xFE";
    z += "\xFE";
    z += "*\xFE";
    z += "* Setup new program file & itemid\xFE";
    z += "*\xFE";
    z += "    Itemid = Iid\xFE";
    z += "\xFE";
    z += "    Supress = 0\xFE";
    z += "    Tkline = ''\xFE";
    z += "    Tkam = 0\xFE";
    z += "    Tkpos = 0\xFE";
    z += "    Tkno = C_am\xFE";
    z += "    Lineno = 1\xFE";
    z += "\xFE";
    z += "    incFilesSrc = {}\xFE";
    z += "*\xFE";
    z += "    Itemsrc = CleanupText(Itemsrc)\xFE";
    z += "    Itemsrc = Split(Itemsrc, Am)\xFE";
    z += "*\xFE";
    z += "* read all include files\xFE";
    z += "*\xFE";
    z += "    for each Line in ItemSrc\xFE";
    z += "        lline = ltrim(line)\xFE";
    z += "        tkstr = ucase(field(lline, \" \", 1))\xFE";
    z += "        if tkstr = \"*\" then \xFE";
    z += "            lline = ltrim(dropleft(lline, \" \"))\xFE";
    z += "            tkstr = ucase(field(lline, \" \", 1))\xFE";
    z += "        end if\xFE";
    z += "        \xFE";
    z += "        if tkstr = \"INCLUDE\" Or tkstr = \"$INCLUDE\" Or tkstr = \"INSERT\" Or tkstr = \"$INSERT\" then\xFE";
    z += "            iFileName = ucase(field(lline, \" \", 2))\xFE";
    z += "            iItemName = ucase(field(lline, \" \", 3))\xFE";
    z += "            if !iItemName then\xFE";
    z += "                iItemName = iFileName\xFE";
    z += "                iFileName = UCase(Cur_fname)\xFE";
    z += "            end if\xFE";
    z += "            \xFE";
    z += "            open iFileName to fHandle then\xFE";
    z += "                read iItem from fHandle, iItemName then\xFE";
    z += "                    incFilesSrc[ifilename:\"+\":iItemName] = iItem\xFE";
    z += "                end if\xFE";
    z += "            end if\xFE";
    z += "            \xFE";
    z += "            open \"dict\", iFileName to fHandle then\xFE";
    z += "                read iItem from fHandle, iItemName:\".sym\" then\xFE";
    z += "                    iItem = CleanupText(iItem)\xFE";
    z += "                    incFilesSrc['DICT+':ifilename:\"+\":iItemName:'.sym'] = iItem\xFE";
    z += "                end if\xFE";
    z += "            end if\xFE";
    z += "        end if\xFE";
    z += "    next\xFE";
    z += "                \xFE";
    z += "    Call Tcv(False)\xFE";
    z += "*\xFE";
    z += "    Return\xFE";
    z += "end sub\xFE";
    z += "\xFE";
    z += "Subroutine Incfile(byval ifilename, byval iItemName)\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "\xFE";
    z += "*\xFE";
    z += "* Setup new program file & itemid\xFE";
    z += "*\xFE";
    z += "* Is this a commons / equate only file? Do a quick read\xFE";
    z += "*\xFE";
    z += "    // read commons_Symtab from D_file, Subname:\".SYM\" Else Stop @Errors\xFE";
    z += "\xFE";
    z += "    ucIFileName = UCase(ifilename)\xFE";
    z += "    ucIItemName = ucase(iitemname)\xFE";
    z += "\xFE";
    z += "    CommonsName = \"Commons_\":ucIFileName // :\"_\":Makevarname(iItemName)\xFE";
    z += "    EquatesName = \"Equates_\":ucIFileName // :\"_\":Makevarname(iItemName)\xFE";
    z += "    includeSubName = `Include_`:ucIFileName:`_`:Makevarname(iItemName)\xFE";
    z += "\xFE";
    z += "    // a predefined \"Commons\" block?\xFE";
    z += "    symList = incFilesSrc['DICT+':ucIFileName:\"+\":ucIItemName:'.sym']\xFE";
    z += "    \xFE";
    z += "    if symList and (functionType = -1 Or functionType > 0) Then\xFE";
    z += "        symList = JSON(SymList)\xFE";
    z += "        Call Readinc(Symlist)\xFE";
    z += "\xFE";
    z += "        * CREATE A GLOBAL SYMBOL CALLED INAME, so we know if the commons was initted\xFE";
    z += "        Gattr = {}\xFE";
    z += "        Gattr.SYM_FLAVOR = Flavor_common\xFE";
    z += "        Gattr.SYM_INCLEVEL = Incfile + 1\xFE";
    z += "        Gattr.SYM_ISCONST = 0\xFE";
    z += "        Gattr.SYM_ISBYVAL = False\xFE";
    z += "        Gattr.SYMNAME = ucIItemName\xFE";
    z += "        Gattr.SYM_TYPE = Type_var\xFE";
    z += "        F = iItemName; F = Makevarname(F);  \xFE";
    z += "        Gattr.SYM_C = CommonsName\xFE";
    z += "        Call Writesym(Gattr, Gattr.SYMNAME)\xFE";
    z += "\xFE";
    z += "        // Should subs & funcs check if commons is there? - yes - possible that we are called from a different project\xFE";
    z += "        if NotASyncFunction Then\xFE";
    z += "            OcPgm[-1] = Space(Indent):includeSubName:\"(false)\"\xFE";
    z += "        Else\xFE";
    z += "            OcPgm[-1] = Space(Indent):`await `:includeSubName:\"(false)\"\xFE";
    z += "        End If\xFE";
    z += "        Return\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    // Only a functionType = 0 (PROGRAM) from here on\xFE";
    z += "    // Save current stuff\xFE";
    z += "    if Trim(Oc) <> \"\" Then Ocpgm[-1] = Oc; Oc = \"\"\xFE";
    z += "    hItemSrc = ItemSrc; \xFE";
    z += "    Holdpgm = Ocpgm; Ocpgm = []\xFE";
    z += "\xFE";
    z += "    hFname = CUR_FNAME\xFE";
    z += "    hCur_realfname = Cur_realfname\xFE";
    z += "    hIName = ITEMID\xFE";
    z += "    Svtk = savetk()\xFE";
    z += "    hadLbl = hasLbl\xFE";
    z += "    HAddDebugging = Adddebugging\xFE";
    z += "    hHardcode = Hardcode\xFE";
    z += "    \xFE";
    z += "    Itemsrc = incFilesSrc[ucIFileName:\"+\":ucIItemName]\xFE";
    z += "    if !Itemsrc then\xFE";
    z += "        ItemSrc = hItemSrc\xFE";
    z += "        Call Err('Missing include file: ':ifilename:\" \":iItemName); \xFE";
    z += "        Return\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    If Not(Hush) Then Print '; Incfile: ':ifilename:' ':iItemName:\" \":\xFE";
    z += "    Incfile = Incfile + 1\xFE";
    z += "\xFE";
    z += "   ' Setup new source\xFE";
    z += "    Adddebugging = 0\xFE";
    z += "    Cur_fname = LCase(ifilename)\xFE";
    z += "    Cur_realfname = cspc_truefilename(ifilename)\xFE";
    z += "    Cur_realfname = makesubname(Cur_realfname)\xFE";
    z += "    Itemid = LCase(iItemName)\xFE";
    z += "    \xFE";
    z += "    Itemsrc = Split(Itemsrc, Am)\xFE";
    z += "    Tkline = ''\xFE";
    z += "    Tkam = 0\xFE";
    z += "    Tkpos = 0\xFE";
    z += "    Tkno = C_am\xFE";
    z += "    Lineno = 1\xFE";
    z += "    hasLbl = 0\xFE";
    z += "    Hardcode = 0\xFE";
    z += "    \xFE";
    z += "    // Prime\xFE";
    z += "    Call Tcv(False)\xFE";
    z += "    Call States(1,\"\")\xFE";
    z += "    If Not(Index(C_end:C_sm,Tkno,1)) Then Call Err('End of commons expected')\xFE";
    z += "\xFE";
    z += "    if Trim(Oc) <> \"\" Then Ocpgm[-1] = Oc; Oc = \"\"\xFE";
    z += "    \xFE";
    z += "    open \"dict\", ifilename to d_iFile else stop @errors\xFE";
    z += "\xFE";
    z += "    // can I make this a seperate file?\xFE";
    z += "    if hasLbl = 0 And !Hardcode then\xFE";
    z += "        // No real code - only definitions\xFE";
    z += "        Header = [`async function `:includeSubName:`(forceReset) {`]\xFE";
    z += "        Header[-1] = Space(Indent):`forceReset |= (typeof `:CommonsName:` == \"undefined\") || (typeof `:EquatesName:` == \"undefined\"); `\xFE";
    z += "        Header[-1] = Space(Indent):`if (!forceReset) return; `\xFE";
    z += "        Header[-1] = ``\xFE";
    z += "        Header[-1] = Space(Indent):`var me = new jsbRoutine(\"`:ifilename:`\", \"`:ifilename:`.js\", \"`:includeSubName:`\"); me.localValue = function (varName) { return eval(varName) }; `\xFE";
    z += "        Header[-1] = Space(Indent):CommonsName:` = {}; `\xFE";
    z += "        Header[-1] = Space(Indent):EquatesName:` = {}; `\xFE";
    z += "        Header[-1] = ``\xFE";
    z += "        \xFE";
    z += "        OcPgm[-1] = Space(Indent):`return true; `\xFE";
    z += "        OcPgm[-1] = \"}\"   \xFE";
    z += "        \xFE";
    z += "        Src = Join(Header, crlf()):Join(Ocpgm, crlf())\xFE";
    z += "        call UpdateJScode(Src, pcFName, includeSubName, \"\") // Write Src On d_iFile, iItemName:'_cmns.js' else stop @errors\xFE";
    z += "        \xFE";
    z += "        Cmns = {}\xFE";
    z += "        theseTypes = ' ':Flavor_common:Flavor_function:Flavor_equate:Flavor_external\xFE";
    z += "        For Each Id In Symtab\xFE";
    z += "            Gattr = Symtab[Id]\xFE";
    z += "            If InStr(theseTypes, Gattr.SYM_FLAVOR) > 1 Then Cmns[id] = Gattr\xFE";
    z += "        Next\xFE";
    z += "        \xFE";
    z += "        Writejson Cmns On d_iFile, iItemName:\".sym\" Else Stop @Errors\xFE";
    z += "        incFilesSrc['DICT+':ucIFileName:\"+\":ucIItemName:'.sym'] = Cmns\xFE";
    z += "    \xFE";
    z += "        // Restore previous source\xFE";
    z += "        Ocpgm = Holdpgm\xFE";
    z += "        OcPgm[-1] = ``\xFE";
    z += "        OcPgm[-1] = `    await `:includeSubName:`(true); `\xFE";
    z += "        OcPgm[-1] = ``\xFE";
    z += "    Else\xFE";
    z += "        Holdpgm[-1] = `    // Include `:ifilename:` `:iItemName\xFE";
    z += "        for I = 1 to UBound(Ocpgm)\xFE";
    z += "            Holdpgm[-1] = OcPgm[I]\xFE";
    z += "        next\xFE";
    z += "        OcPgm = Holdpgm\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    Holdpgm = ''\xFE";
    z += "    hasLbl += hadLbl\xFE";
    z += "    \xFE";
    z += "    CUR_FNAME = hFname\xFE";
    z += "    ITEMID = hIName\xFE";
    z += "    Itemsrc = hItemSrc\xFE";
    z += "    Cur_realfname = hCur_realfname\xFE";
    z += "    Call Restoret(svtk, true)\xFE";
    z += "    Adddebugging = HAddDebugging\xFE";
    z += "    Hardcode = hHardcode\xFE";
    z += "    \xFE";
    z += "    Incfile = Incfile - 1\xFE";
    z += "    \xFE";
    z += "    Return\xFE";
    z += "end sub\xFE";
    z += "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "Subroutine Skiprestofline()\xFE";
    z += "    $Insert _comms\xFE";
    z += "\xFE";
    z += "    if Tkpos <> 99999 Then\xFE";
    z += "        Tkpos = 99999; Tkno = C_am\xFE";
    z += "        If Incfile = 0 And Adddebugging And !NotASyncFunction Then\xFE";
    z += "            If Trim(Oc) <> '' Then Ocpgm[-1] = Oc; Oc = \"\"\xFE";
    z += "            Ocpgm[-1] = Space(Indent):'await dbgCheck(me, ':Tkam+1:'); ' ;* Tkam+1 Because this Is Preceeding The Next Line\xFE";
    z += "        End If\xFE";
    z += "        \xFE";
    z += "        If Trim(Oc) <> '' Then Ocpgm[-1] = Oc; Oc = Space(Indent)\xFE";
    z += "        \xFE";
    z += "        If Tkam Mod 10 = 0 And Not(Hush)Then Print '-':\xFE";
    z += "        If System(1) = 'js' Then @Server.Flush\xFE";
    z += "    end if\xFE";
    z += "End Subroutine\xFE";
    z += "\xFE";
    z += "function Findendofsub(Byval Src, Byval startLineno)\xFE";
    z += "    $Insert _comms\xFE";
    z += "\xFE";
    z += "    Srca = Split(UCase(Src), Chr(254))\xFE";
    z += "    For Linei = startLineno + 1 To UBound(Srca)\xFE";
    z += "        Line = Srca[Linei]\xFE";
    z += "        if left(Line, 1) = \" \" Then Line = Mid(Line, 2)\xFE";
    z += "        F1 = Field(Line, \" \", 1)\xFE";
    z += "        If F1 = \"SUBROUTINE\" Or F1 = \"FUNCTION\" Or F1 = \"PROGRAM\" Or F1 = \"FUNC\" Or F1 = \"SUB\" Or F1 = \"COMMONS\" Or F1 = \"GLOBALS\" Then Return Linei - 1\xFE";
    z += "        If F1 = \"END\" Then\xFE";
    z += "            F2 = Field(Line, \" \", 2)\xFE";
    z += "            If F2 = \"SUBROUTINE\" Or F2 = \"FUNCTION\" Or F2 = \"PROGRAM\" Or F2 = \"FUNC\" Or F2 = \"SUB\" Or F2 = \"COMMONS\" Or F2 = \"GLOBALS\" Then Return Linei\xFE";
    z += "        End If\xFE";
    z += "    Next\xFE";
    z += "    Return Linei\xFE";
    z += "End function\xFE";
    z += "\xFE";
    z += "Subroutine SkipOverComments(byval includeStringMarker)\xFE";
    z += "    $Insert _comms\xFE";
    z += "\xFE";
    z += "    Skipper = C_am:C_asterisk:C_bang:C_dblSlash:C_CmtBlock\xFE";
    z += "    If includeStringMarker Then Skipper := C_str \xFE";
    z += "    \xFE";
    z += "    Specials = ['$DEFINE',\"$OPTIONS\",\"$OPTION\"]\xFE";
    z += "\xFE";
    z += "    Loop While Index(Skipper, Tkno, 1) Do\xFE";
    z += "        If Tkno = C_asterisk Then\xFE";
    z += "            Ntkstr = UCase(Field(LTrim(Tkline[Tkpos, 20]), \" \", 1))\xFE";
    z += "            Locate Ntkstr In Specials Then\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Options\xFE";
    z += "            Else\xFE";
    z += "                Call Skiprestofline()\xFE";
    z += "            End If\xFE";
    z += "            \xFE";
    z += "        ElseIf Tkno = C_bang Or Tkno = C_str Or Tkno = C_dblSlash Then\xFE";
    z += "        \xFE";
    z += "            Call Skiprestofline()\xFE";
    z += "            \xFE";
    z += "        Else\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "            Locate Tkstr In Specials Then Call Options\xFE";
    z += "        End If\xFE";
    z += "    Repeat\xFE";
    z += "End Sub\xFE";
    z += "\xFE";
    z += "Subroutine ResetGlobalOpts()\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "    Addcmt = False\xFE";
    z += "    Showlist = False\xFE";
    z += "    Mr83 = False\xFE";
    z += "    Optionexplicit = False\xFE";
    z += "    Adddebugging = System(1) = \"js\"\xFE";
    z += "    Hush = False\xFE";
    z += "    \xFE";
    z += "    If Instr(Options, \"L\") Then Showlist = True\xFE";
    z += "    If Instr(Options, \"R\") Then Mr83 = Instr(Options, \"R\")\xFE";
    z += "    If Instr(Options, \"E\") Then Optionexplicit = True\xFE";
    z += "    If Instr(Options, \"S\") Then Adddebugging = System(1) <> \"js\"\xFE";
    z += "    If Instr(Options, \"H\") Then Hush = True\xFE";
    z += "    If Instr(Options, \"C\") Then Addcmt = True\xFE";
    z += "\xFE";
    z += "    If Instr(Options, \"L-\") Then Showlist = False\xFE";
    z += "    If Instr(Options, \"S-\") Then Adddebugging = True\xFE";
    z += "    If Instr(Options, \"R-\") Then Mr83 = False\xFE";
    z += "    If Instr(Options, \"H-\") Then Hush = False\xFE";
    z += "    If Instr(Options, \"E-\") Then Optionexplicit = False\xFE";
    z += "    If Instr(Options, \"C-\") Then Addcmt = False\xFE";
    z += "\xFE";
    z += "    If Mr83 Then Mobjectdelemeter = \"|\" Else Mobjectdelemeter = \".\"\xFE";
    z += "    If Mr83 Then Simplestrings = True Else Simplestrings = False\xFE";
    z += "End Subroutine\xFE";
    z += "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "Function Lddynadr()\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "* CHECK FOR <PARSEVAR{,PARSEVAR{,PARSEVAR}}>\xFE";
    z += "*\xFE";
    z += "    Avs = ''\xFE";
    z += "    If Tkno = C_less Then\xFE";
    z += "        Call Tcv(False)\xFE";
    z += "        Lattr = Expr(Type_eNum,2,C_comma:C_great)\xFE";
    z += "        Call Typenum(Type_vnum, Lattr)\xFE";
    z += "        Avs = Lattr.SYM_C\xFE";
    z += "        If Tkno = C_comma Then\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "            Lattr = Expr(Type_eNum,2,C_comma:C_great)\xFE";
    z += "            Call Typenum(Type_vnum, Lattr)\xFE";
    z += "            Avs = Avs:',':Lattr.SYM_C\xFE";
    z += "            If Tkno = C_comma Then\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Lattr = Expr(Type_eNum,2,C_comma:C_great)\xFE";
    z += "                Call Typenum(Type_vnum, Lattr)\xFE";
    z += "                Avs = Avs:',':Lattr.SYM_C\xFE";
    z += "            End Else Avs=Avs:',':\"0\"\xFE";
    z += "        End Else Avs=Avs:',':\"0\":',':\"0\"\xFE";
    z += "        If Tkno = C_great Then\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "        End Else Call Err('\">\" Expected')\xFE";
    z += "    End\xFE";
    z += "    Return Avs\xFE";
    z += "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "Function Readsym(byval Symname)\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "\xFE";
    z += "    Rec = Symtab[Symname]\xFE";
    z += "    If !Rec Then\xFE";
    z += "        Rec = Definesym(Symname, false)\xFE";
    z += "        readSymFound = 0\xFE";
    z += "        If Optionexplicit Then Call Warning(\"SYMBOL '\":Symname:\"' NOT DEFINED\")\xFE";
    z += "        Return Rec\xFE";
    z += "    End If\xFE";
    z += "    readSymFound = 1\xFE";
    z += "    Return Clone(Rec)\xFE";
    z += "end function\xFE";
    z += "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "Function Definesym(byval Symname, byval isUsed)\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "\xFE";
    z += "    Rec = {}\xFE";
    z += "    If Symname = \"\" Then Return Rec\xFE";
    z += "    Rec.SYMNAME = Symname\xFE";
    z += "    Rec.SYM_FLAVOR = Flavor_local\xFE";
    z += "    Rec.SYM_INDEX1 = ''\xFE";
    z += "    Rec.SYM_INDEX2 = ''\xFE";
    z += "    Rec.isDefinedInOutput = isUsed\xFE";
    z += "*\xFE";
    z += "    Rec.SYM_INCLEVEL = Incfile\xFE";
    z += "    // 1) Commons, 0) Program, 1) Subroutine, 2) function, 3) @@function (Server Only Compile), 4) Pick/RESTFUL function\xFE";
    z += "    If functionType >= 2 And Symname = Subname Then\xFE";
    z += "        Rec.SYM_TYPE = Funcattr.SYM_TYPE\xFE";
    z += "    End Else\xFE";
    z += "        Rec.SYM_TYPE = Type_var\xFE";
    z += "    End\xFE";
    z += "    Sname = Symname\xFE";
    z += "    Sname = Makevarname(Sname)\xFE";
    z += "    If ByRefsNotAllowed Then\xFE";
    z += "        If Tkstr = Symname Then Rec.SYM_C = Otkstr Else Rec.SYM_C = Symname\xFE";
    z += "    Else\xFE";
    z += "        Rec.SYM_C = Sname\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    If isUsed Then\xFE";
    z += "        Rec.SYM_USED = True\xFE";
    z += "        Rec.SYM_TYPES = Symtypes_stored\xFE";
    z += "    End if\xFE";
    z += "    \xFE";
    z += "    Return Rec\xFE";
    z += "end function\xFE";
    z += "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "Subroutine Writesym(byval Rec, byval Symname)\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "\xFE";
    z += "    Symtab[Symname] = Clone(Rec)\xFE";
    z += "    Return\xFE";
    z += "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "Subroutine Writevsym(byval Value, byval Symname, byval Tag)\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "\xFE";
    z += "    If !Symname Then Return\xFE";
    z += "    Rec = Symtab[Symname]\xFE";
    z += "    If !Rec Then Return\xFE";
    z += "    Rec[Tag] = Value\xFE";
    z += "    Symtab[Symname] = Rec\xFE";
    z += "    Return\xFE";
    z += "\xFE";
    z += "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "* Valid interchangeable characters are: \xFE";
    z += "*    s (string), v (variant), b (boolean), n (real/number), i (integer), j (json), a (array), ? (object), l (select-list)\xFE";
    z += "*    \xFE";
    z += "*    result.Calldef: this is used to define the type of a parameter\xFE";
    z += "*    result.Var:     name to define (used in js)\xFE";
    z += "*    result.Cinit:   init for local variables\xFE";
    z += "*\xFE";
    z += "function Builddec(byval SAttr) \xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "\xFE";
    z += "    result = {}\xFE";
    z += "    result.Var = Trim(SAttr.SYM_C)\xFE";
    z += "    result.Cinit = ''\xFE";
    z += "\xFE";
    z += "    Begin Case\xFE";
    z += "        Case SAttr.SYM_TYPE = Type_cnum Or SAttr.SYM_TYPE = Type_vnum Or SAttr.SYM_TYPE = Type_eNum Or SAttr.SYM_TYPE = Type_eBool \xFE";
    z += "            If SAttr.SYM_ISCONST Then result.Calldef=Type_eNum Else result.Calldef=Type_vnum\xFE";
    z += "            result.Cinit = '0'\xFE";
    z += "\xFE";
    z += "        Case SAttr.SYM_ISCONST ;* All Strings (Type_cnum constants handled above)\xFE";
    z += "            result.Calldef=Type_cstr\xFE";
    z += "\xFE";
    z += "        Case SAttr.SYM_TYPE = Type_cstr Or SAttr.SYM_TYPE = Type_vstr Or SAttr.SYM_TYPE = Type_estr\xFE";
    z += "            result.Calldef = Type_vstr\xFE";
    z += "            result.Cinit = \"''\"\xFE";
    z += "\xFE";
    z += "        Case 1\xFE";
    z += "            result.Calldef = Type_var\xFE";
    z += "\xFE";
    z += "    End Case\xFE";
    z += "\xFE";
    z += "    If SAttr.SYM_INDEX1 # \"\" Then\xFE";
    z += "        If !result.Cinit Then result.Cinit = \"null\"\xFE";
    z += "        If SAttr.SYM_INDEX2 Then result.Cinit = 'createArray(':result.Cinit:', ':SAttr.SYM_INDEX1:', ':SAttr.SYM_INDEX2:')' Else result.Cinit = 'createArray(':result.Cinit:', ':SAttr.SYM_INDEX1:')'\xFE";
    z += "        result.Calldef = 'M':SAttr.SYM_INDEX1:'X':SAttr.SYM_INDEX2:result.Calldef\xFE";
    z += "    End\xFE";
    z += "\xFE";
    z += "    if SAttr.SYM_FLAVOR == Flavor_Equate And SAttr.SYM_INCLEVEL = -1 Then\xFE";
    z += "        result.Cinit = \" = \":SAttr.SYM_EQUATE\xFE";
    z += "    \xFE";
    z += "    else If Len(result.Cinit) Then \xFE";
    z += "        result.Cinit = \" = \":result.Cinit\xFE";
    z += "    end if\xFE";
    z += "\xFE";
    z += "    Return result\xFE";
    z += "end function\xFE";
    z += "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "Subroutine Uselbl(byval Lbl)\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "    Linkrec = readsym('%%':Lbl)\xFE";
    z += "    If Not(readSymFound) Then\xFE";
    z += "        Linkrec = {}\xFE";
    z += "        Linkrec.SYMNAME = '%%':Lbl\xFE";
    z += "        Linkrec.SYM_FLAVOR = Flavor_gotolbl\xFE";
    z += "        Linkrec.SYM_TYPE = Symtypes_temp\xFE";
    z += "        Linkrec.SYM_INCLEVEL = 0\xFE";
    z += "        Call Writesym(Linkrec,'%%':Lbl)\xFE";
    z += "    End\xFE";
    z += "    Return\xFE";
    z += "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "Subroutine Deflbl(byval Lbl, byval Userlbl)\xFE";
    z += "*\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "    If Userlbl Then\xFE";
    z += "        Linkrec = readsym('%%':Lbl)\xFE";
    z += "        If Not(readSymFound) Then Linkrec = { SYM_INCLEVEL: 0 }\xFE";
    z += "\xFE";
    z += "        If Linkrec.SYM_USED Then Call Err('Duplicate lable')\xFE";
    z += "\xFE";
    z += "        Linkrec.SYM_USED = 1\xFE";
    z += "        Linkrec.SYM_FLAVOR = Flavor_gotolbl\xFE";
    z += "        Linkrec.SYM_TYPE = Symtypes_temp\xFE";
    z += "        Linkrec.SYMNAME = '%%':Lbl\xFE";
    z += "\xFE";
    z += "        Call Writesym(Linkrec,'%%':Lbl)\xFE";
    z += "    End If\xFE";
    z += "\xFE";
    z += "    Oc<-1> = Space(Indent-4):'case \"':Lbl:'\": ':Am:Space(Indent)\xFE";
    z += "    \xFE";
    z += "    If Instr(Options, \"@\") Then\xFE";
    z += "        Call Warning('LABEL DEFINED HERE ':Lbl)\xFE";
    z += "    Else\xFE";
    z += "        Haslbl = 1\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    Return"
    window.cached_jsb2js["parseprogram"] = z;
    var z = "function PassThruJavascript()\xFE";
    z += "*\xFE";
    z += "* SKIP FROM { TO } AND RETURN CONTENTS\xFE";
    z += "* TKSTR SHOULD BE \"{\" ON ENTERING THIS ROUTINE\xFE";
    z += "*\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "    Contents = []\xFE";
    z += "    Lpcnt = 1\xFE";
    z += "    Oline = Otkstr\xFE";
    z += "*\xFE";
    z += "    Loop\xFE";
    z += "        C = Tkline[Tkpos,1]\xFE";
    z += "        Tkpos = Tkpos + 1\xFE";
    z += "        Oline = Oline:C\xFE";
    z += "\xFE";
    z += "        If C = \"\" Then\xFE";
    z += "            Tkam += 1\xFE";
    z += "            Contents[-1] = Oline\xFE";
    z += "            Oline = \"\"\xFE";
    z += "            If Tkam > UBound(Itemsrc) Then\xFE";
    z += "                Call Err(\"Missing } terminator\")\xFE";
    z += "                Break\xFE";
    z += "            End If\xFE";
    z += "            Tkline = Itemsrc[Tkam]\xFE";
    z += "            Tkpos = 1\xFE";
    z += "\xFE";
    z += "        Else If C = \"{\" Then\xFE";
    z += "            Lpcnt = Lpcnt + 1\xFE";
    z += "            \xFE";
    z += "        Else If C = \"}\" Then\xFE";
    z += "            Lpcnt = Lpcnt - 1\xFE";
    z += "            If Lpcnt = 0 Then Break ;* Done!\xFE";
    z += "            \xFE";
    z += "        End Else If C= \"'\" Or C = '\"' Or C = \"`\" Then\xFE";
    z += "            Loop\xFE";
    z += "                C2 = Tkline[Tkpos,1]\xFE";
    z += "                Tkpos = Tkpos + 1\xFE";
    z += "                Oline = Oline:C2\xFE";
    z += "                \xFE";
    z += "                If C2 = C Then Break\xFE";
    z += "                If C2 = \"\" Then\xFE";
    z += "                    If C <> \"`\" Then\xFE";
    z += "                        If C = '\"' Then Call Err(\"Missing string \":C:\" terminator\")\xFE";
    z += "                        Break\xFE";
    z += "                    End If\xFE";
    z += "                    Tkam += 1\xFE";
    z += "                    Contents[-1] = Oline\xFE";
    z += "                    Oline = \"\"\xFE";
    z += "                    If Tkam > UBound(Itemsrc) Then\xFE";
    z += "                        Call Err(\"Missing } terminator\")\xFE";
    z += "                        Break\xFE";
    z += "                    End If\xFE";
    z += "                    Tkline = Itemsrc[Tkam]\xFE";
    z += "                    Tkpos = 1\xFE";
    z += "                End If\xFE";
    z += "            While 1 Do Repeat\xFE";
    z += "        End ;* Strings\xFE";
    z += "    While 1 Do Repeat\xFE";
    z += "    Call Tcv(False)\xFE";
    z += "    \xFE";
    z += "    OkToTrim = True\xFE";
    z += "    if trim(oline) = \"}\" Then\xFE";
    z += "        lline = Contents[UBound(Contents)]\xFE";
    z += "        if InStr(lline, \"//\") Then OkToTrim = false\xFE";
    z += "    end if\xFE";
    z += "    \xFE";
    z += "    Contents[-1] = Oline\xFE";
    z += "    Contents = RTrim(LTrim(Join(Contents, crlf())))\xFE";
    z += "    \xFE";
    z += "    if Left(Contents, 1) = \"{\" and Right(Contents, 1) = \"}\" Then\xFE";
    z += "        Contents = LTrim(Mid(Contents, 2, len(Contents) - 2))\xFE";
    z += "        if OkToTrim Then Contents = RTrim(Contents)\xFE";
    z += "    end if\xFE";
    z += "    \xFE";
    z += "    Return Contents\xFE";
    z += "end function\xFE";
    z += ""
    window.cached_jsb2js["passthrujavascript"] = z;
    var z = "*\xFE";
    z += "* Errors are surrounded with Chr(14)\xFE";
    z += "* Warnings are surrounded with Chr(15)\xFE";
    z += "* Summary with CHR(16) - :SUBNAME:\" nnn bytes or had errors\":chr(16)\xFE";
    z += "*\xFE";
    z += "Program Pc\xFE";
    z += "    $Insert _comms\xFE";
    z += "\xFE";
    z += "    If  !IsAdmin() Then Stop \"You are not an administrator\"\xFE";
    z += "    \xFE";
    z += "    If !ParseSelect(@Sentence, \"\", Top, Columns, Dict, givenfname, FilterBy, OrderBY, givenOptions, AllItems, F_ffile, False /* parseColumnNames */, False /* Ignorefilenotfound */, Null) Then\xFE";
    z += "        If @Errors Then Stop @Errors\xFE";
    z += "        Print \"PC FILENAME ITEMNAME(S) (OPTIONS)\"\xFE";
    z += "        Print '   OPTIONS:'\xFE";
    z += "        Print '      (C) Add source lines as javascript comments'\xFE";
    z += "        if system(1) = \"js\" then\xFE";
    z += "            Print '      (S) Suppress debugging info'\xFE";
    z += "        Else\xFE";
    z += "            Print '      (S) Add debugging info'\xFE";
    z += "        end if\xFE";
    z += "        \xFE";
    z += "        Print '      (E) Option Explicit implied'\xFE";
    z += "        Print '      (L) Dump listing to screen'\xFE";
    z += "        Print '      (R) R83 compatable - (Object Seperator is !, no \"\\\\\" string escapes, and expr expr (format) allowed)'\xFE";
    z += "        Print '      (X) execute program after compiling (RUN)'\xFE";
    z += "        If @IsAdmin Then Print '      (@) attempt pure javascript converstion'\xFE";
    z += "        Print\xFE";
    z += "        Print 'You may add a DICT item to your file called options.txt which will appended to any command line options'\xFE";
    z += "        Stop\xFE";
    z += "    End If\xFE";
    z += "\xFE";
    z += "    If Dict Then Stop 'Bad DICT syntax'\xFE";
    z += "    \xFE";
    z += "    If !FilterBy And !System(11) Then\xFE";
    z += "        If !AllItems Then Stop\xFE";
    z += "        If OrderBY Then FilterBy = LTrim(RTrim(FilterBy:\" order by \":OrderBY))\xFE";
    z += "        Select LTrim(Top:' '):Columns From F_ffile Where FilterBy To Ss Else Stop @Errors\xFE";
    z += "    End If\xFE";
    z += "\xFE";
    z += "    Itemlist = GetList(Ss)\xFE";
    z += "    if !isArray(Itemlist) Then Itemlist = SPlit(Itemlist, am())\xFE";
    z += "    \xFE";
    z += "    *\xFE";
    z += "    * PARSE FILE NAME & ITEMNAMES\xFE";
    z += "    *\xFE";
    z += "    givenfname = LCase(truefilename(givenfname))\xFE";
    z += "    D_ffile = @Fhandle(\"DICT\", givenfname, True)\xFE";
    z += "    open \"jsb_jsxrefs\" to fXRefs else fXRefs = Null\xFE";
    z += "    \xFE";
    z += "    If AllItems Then\xFE";
    z += "        // Don't delete anything out from under us\xFE";
    z += "        If fXRefs Then\xFE";
    z += "            for each ID in fSelect(D_ffile)\xFE";
    z += "                ID = LCase(ID)\xFE";
    z += "                Ext = Right(ID, 4)\xFE";
    z += "                If Ext[2,1] = \".\" Then Ext = Ext[2,3]\xFE";
    z += "                If Ext = \".js\" Or Ext = \".err\" Or Ext = \".lst\" Or Ext = \".wrn\" Then Delete D_ffile, ID Else Alert(@Errors)\xFE";
    z += "            Next\xFE";
    z += "            \xFE";
    z += "            // If we are recompiling everything, clear out any references that have SUB_CALLSTO and SUB_ISCALLEDBY\xFE";
    z += "            If fXRefs And System(1) = \"aspx\" And Left(givenfname, 4) = \"jsb_\" Then\xFE";
    z += "                for each ID in fSelect(fXRefs)\xFE";
    z += "                    ReadJson xDef From fXRefs, ID Then\xFE";
    z += "                        if xDef.SUB_FNAME = givenfname Then\xFE";
    z += "                            xDef.SUB_CALLSTO = \"\"\xFE";
    z += "                            xDef.SrcEdit = \"\"\xFE";
    z += "                            xDef.SUB_ISCALLEDBY = \"\"\xFE";
    z += "                            WriteJson xDef on fXRefs, ID Else Alert(@Errors)\xFE";
    z += "                        end if\xFE";
    z += "                    end if\xFE";
    z += "                next\xFE";
    z += "            End If\xFE";
    z += "        End If\xFE";
    z += "\xFE";
    z += "        Print @(-1):\xFE";
    z += "    End If\xFE";
    z += "\xFE";
    z += "    Print 'JSon Basic Compiler by Randy Walsh'\xFE";
    z += "    Print 'Source: ':givenfname:\"; OPTIONS: \":givenOptions\xFE";
    z += "    Print @Html(`<style>#jsb { word-wrap: break-all; white-space: normal } </style>`):\xFE";
    z += "\xFE";
    z += "    \xFE";
    z += "    fJsbConfig = fHandle(\"jsb_config\")\xFE";
    z += "    Read externals_txt From fJsbConfig, 'config_jsb2js' Else\xFE";
    z += "        MsgBox(\"I'm unable to find your config_jsb2js file in Jsb_Config\")\xFE";
    z += "        Stop\xFE";
    z += "    End If\xFE";
    z += "\xFE";
    z += "    \xFE";
    z += "    Loop While UBound(ItemList) Do\xFE";
    z += "        Itemid = Itemlist[1]\xFE";
    z += "        Itemlist = Delete(Itemlist, 1)\xFE";
    z += "\xFE";
    z += "        if InStr(ItemID, Vm()) Then\xFE";
    z += "            NewPcfname = LCase(truefilename(ItemID<1,1>))\xFE";
    z += "            ItemID = ItemID<1,2>\xFE";
    z += "        Else\xFE";
    z += "            NewPcfname = givenfname\xFE";
    z += "        End If\xFE";
    z += "        \xFE";
    z += "        If NewPcfname <> pcfname Then\xFE";
    z += "            Pcfname = NewPcfname\xFE";
    z += "            Realpcfname = Makesubname(UCase(Pcfname))\xFE";
    z += "            D_ffile = @Fhandle(\"DICT\", Pcfname, True)\xFE";
    z += "            Options = Mcu(givenOptions)\xFE";
    z += "            Read Dftopts From D_ffile, \"options.txt\" Then \xFE";
    z += "                Options = Options:Mcu(Dftopts)\xFE";
    z += "            ElseIf Left(Pcfname, 4) = \"jsb_\" Or Pcfname = \"tmp\" Then\xFE";
    z += "                Write 'R-' On D_ffile, 'options.txt'\xFE";
    z += "                Options := \"R-\"\xFE";
    z += "            End If\xFE";
    z += "        End If\xFE";
    z += "        \xFE";
    z += "        If Itemid[1,1] <> \"_\" Or Pcfname = \"jsb_ctls\" Then\xFE";
    z += "            *\xFE";
    z += "            * Reset variables for next item\xFE";
    z += "            *\xFE";
    z += "            Incfile = 0\xFE";
    z += "            Ocpgm = []\xFE";
    z += "            cached_XRefs = {}\xFE";
    z += "            \xFE";
    z += "            La = C_end:C_sm\xFE";
    z += "            Errcnt = 0\xFE";
    z += "            Errline = ''\xFE";
    z += "            Errpos = 0\xFE";
    z += "            *\xFE";
    z += "            Nxtlbl = 1\xFE";
    z += "            Ocfile = \"\"\xFE";
    z += "            *\xFE";
    z += "            Call Baseconv(Pcfname, Itemid) ; * Inits Tkline, Tkam, Tkpos, Tkno, Lineno\xFE";
    z += "            \xFE";
    z += "            If !Itemsrc Then\xFE";
    z += "                Print \"Item \":Itemid:\" not found.\"\xFE";
    z += "                Continue\xFE";
    z += "            End If\xFE";
    z += "            OrginalSrcCnt = UBound(Itemsrc)\xFE";
    z += "            \xFE";
    z += "            *\xFE";
    z += "            Subname = Itemid ;* Default In Case One Isn'T PROVIDED\xFE";
    z += "            Subname = makesubname(Subname)\xFE";
    z += "\xFE";
    z += "            Firstone = 1\xFE";
    z += "            *\xFE";
    z += "            * Allow multiple subroutines and functions in same file\xFE";
    z += "            *\xFE";
    z += "            Loop While Firstone = 1 Or Tkstr = \"SUBROUTINE\" Or Tkstr = \"SUB\" Or Tkstr = \"FUNCTION\" Or Tkstr = \"PROGRAM\" Or Tkstr = \"GLOBALS\" Or Tkstr = \"COMMONS\" Or Tkstr = \"CLASS\" Or Tkstr = \"PARTIAL\" Or Tkstr = \"RESTFUL\" Or Tkstr = \"PICK\" Do\xFE";
    z += "                ' @Sentence Options which are Reset each function are cleared here - (all others in Parseprogram)\xFE";
    z += "                Call ResetGlobalOpts()\xFE";
    z += "                \xFE";
    z += "\xFE";
    z += "                Symtab = {}\xFE";
    z += "                //for each rec in Globals\xFE";
    z += "                //    Rec = Clone(Rec)\xFE";
    z += "                //    Rec.SYM_INCLEVEL = -1\xFE";
    z += "                //    Symtab[rec.SYMNAME] = rec\xFE";
    z += "                //next\xFE";
    z += "\xFE";
    z += "                Call SkipOverComments(True)\xFE";
    z += "                If Tkno = C_sm Then Exit Do\xFE";
    z += "\xFE";
    z += "                If Mr83 Then Mobjectdelemeter = \"|\" Else Mobjectdelemeter = \".\"\xFE";
    z += "                If Mr83 Then Simplestrings = True Else Simplestrings = False\xFE";
    z += "\xFE";
    z += "                If Firstone Then\xFE";
    z += "                    Firstone = 0\xFE";
    z += "                    'Subname = Itemid ;* Default In Case One Isn'T PROVIDED\xFE";
    z += "                    'Subname = makesubname(Subname)\xFE";
    z += "                    'Call Baseconv(Pcfname, Itemid)\xFE";
    z += "                End Else\xFE";
    z += "                    Subname = \"\" ;* Should Get From Subroutine Header\xFE";
    z += "                End If\xFE";
    z += "\xFE";
    z += "                If Tkstr = \"CLASS\" Then\xFE";
    z += "                    Insideclass = True\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    Classname = Tkstr\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    Call SkipOverComments(True)\xFE";
    z += "                    Firstclassdim = True\xFE";
    z += "                    \xFE";
    z += "                    ' LOOP ON CLASS METHODS\xFE";
    z += "                    Loop While True Do\xFE";
    z += "                        If Tkstr = \"DIM\" Or Tkstr = \"VAR\" And Firstclassdim Then\xFE";
    z += "                            ' FORCE DIM VARIABLES INTO FIRST SUBROUTINE _NEW\xFE";
    z += "                            Tkpos = Tkpos - Len(Tkstr)\xFE";
    z += "                            Tkline = Left(Tkline, Tkpos - Len(Tkstr) - 1) : \"Sub _NEW();\" : Mid(Tkline, Tkpos, 999)\xFE";
    z += "                            Tkno = C_ident\xFE";
    z += "                            Tkpos = Tkpos - 3 ;* Skip Back Over Sub\xFE";
    z += "                            Call Tcv(False) ;* Reset\xFE";
    z += "                            \xFE";
    z += "                        ElseIf Tkstr <> \"FUNCTION\" And Tkstr <> \"FUNC\" And Tkstr <> \"SUBROUTINE\" And Tkstr <> \"SUB\" And Tkstr <> \"END\" Then\xFE";
    z += "                            Call Err(\"Function or Subroutine Header expected\")\xFE";
    z += "                            Exit Do\xFE";
    z += "                        End If\xFE";
    z += "\xFE";
    z += "                        Serrcnt = Errcnt\xFE";
    z += "                        Firstlineno = Tkam\xFE";
    z += "                        \xFE";
    z += "                        Call Parseprogram ;* Parse Program\xFE";
    z += "                        \xFE";
    z += "                        If Firstlineno > OrginalSrcCnt Then Firstlineno = 0\xFE";
    z += "                        If Not(Hush) Then Print\xFE";
    z += "                        \xFE";
    z += "                        Call Po(Subname, Firstlineno, Appendage, Serrcnt)\xFE";
    z += "\xFE";
    z += "                        ' What follows us?\xFE";
    z += "                        Tkline = Tkline\xFE";
    z += "                        Tkno = Tkno\xFE";
    z += "                        \xFE";
    z += "                        If Tkstr = \"END\" Then\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            If Tkstr = \"PARTIAL\" Then Call Tcv(False)\xFE";
    z += "\xFE";
    z += "                            If Tkstr = \"CLASS\" Then\xFE";
    z += "                                Call Tcv(False)\xFE";
    z += "                            Else\xFE";
    z += "                                Call Err(\"END CLASS expected\")\xFE";
    z += "                            End If\xFE";
    z += "                            Exit Do\xFE";
    z += "                        Else\xFE";
    z += "                            If Tkno <> C_sm And Tkstr <> \"FUNCTION\" And Tkstr <> \"END\" And Tkstr <> \"FUNC\" And Tkstr <> \"SUBROUTINE\" And Tkstr <> \"SUB\" And Tkstr <> \"PROGRAM\" And Tkstr <> \"COMMONS\" And Tkstr <> \"GLOBALS\" And Tkstr <> \"RESTFUL\" And Tkstr <> \"PICK\" Then\xFE";
    z += "                                Call Err(\"END CLASS expected\")\xFE";
    z += "                                Exit Do\xFE";
    z += "                            End If\xFE";
    z += "                        End If\xFE";
    z += "                        \xFE";
    z += "                        Firstclassdim = False\xFE";
    z += "                    Repeat\xFE";
    z += "                Else\xFE";
    z += "                    Insideclass = False\xFE";
    z += "                    Serrcnt = Errcnt\xFE";
    z += "                    Firstlineno = Tkam\xFE";
    z += "                    Call Parseprogram ;* Parse Program\xFE";
    z += "                    \xFE";
    z += "                    If functionType = 3 Then ' IGNORE THIS ROUTINE (SERVER SIDE COMPILE)\xFE";
    z += "                        If Not(Hush) Then Print\xFE";
    z += "                    Else\xFE";
    z += "                        If Firstlineno > OrginalSrcCnt Then Firstlineno = 0\xFE";
    z += "                        Call Po(Subname, Firstlineno, Appendage, Serrcnt)\xFE";
    z += "                    End If\xFE";
    z += "                End If\xFE";
    z += "            Repeat\xFE";
    z += "            *\xFE";
    z += "            * Output all code to ITEMID.js\xFE";
    z += "            If Tkstr = Subname Then Call Tcv(False)\xFE";
    z += "            \xFE";
    z += "            Call SkipOverComments(True)\xFE";
    z += "\xFE";
    z += "            If Tkno <> C_sm And Tkstr <> \"SUBROUTINE\" And Tkstr <> \"SUB\" And Tkstr <> \"FUNCTION\" And Tkstr <> \"FUNC\" And Tkstr <> \"PROGRAM\" And Tkstr <> \"GLOBALS\" And Tkstr <> \"COMMONS\" And Tkstr <> \"COMMON\" And Tkstr <> \"RESTFUL\" And Tkstr <> \"PICK\" Then\xFE";
    z += "                Call Warning('Unknown code, end of code or another routine expected. ':TKSTR:Crlf():TKLINE)\xFE";
    z += "            End If\xFE";
    z += "            *\xFE";
    z += "            * Output Errors for all subs combined\xFE";
    z += "            *\xFE";
    z += "            Delete D_ffile, Itemid:\".err\" Else Null\xFE";
    z += "            Delete D_ffile, Itemid:\".wrn\" Else Null\xFE";
    z += "            if ErrCnt = 0 Then Write DateTime() On D_ffile, LCase(Itemid):\".pc.time\" Else Stop @Errors\xFE";
    z += "            \xFE";
    z += "            If Len(Errors) Then\xFE";
    z += "                If Errcnt = 0 Then\xFE";
    z += "                    Print 'Warnings detected'\xFE";
    z += "                    Write Errors On D_ffile, LCase(Itemid):\".wrn\" Else Stop @Errors\xFE";
    z += "                End Else\xFE";
    z += "                    If Errcnt = 1 Then Print \"One error detected.\" Else\xFE";
    z += "                        If Errcnt > 1 Then Print Errcnt:\" errors detected.\"\xFE";
    z += "                    End\xFE";
    z += "                    Write Errors On D_ffile, LCase(Itemid):\".err\" Else Stop @Errors\xFE";
    z += "                End\xFE";
    z += "                Errors = ''\xFE";
    z += "            End\xFE";
    z += "        End If\xFE";
    z += "        if @domain = \"sbwinforms.azurewebsites.net\" then sleep 10\xFE";
    z += "    Repeat ;* Next Item\xFE";
    z += "    Print\xFE";
    z += "    \xFE";
    z += "    If Index(Options, 'X') And System(1) = \"js\" Then Execute \"RUN \":Pcfname:\" \":Itemlist[1]\xFE";
    z += "end Program\xFE";
    z += "\xFE";
    z += ""
    window.cached_jsb2js["pc"] = z;
    var z = "*********************************************************************************************************************\xFE";
    z += "Subroutine Po(Ignored, Firstlineno, Appendage, Serrcnt)\xFE";
    z += "    $Insert _comms\xFE";
    z += "    \xFE";
    z += "    *\xFE";
    z += "    * = = = = = jsonBasic compiler output = = = = =\xFE";
    z += "    *\xFE";
    z += "    sOcPgm =  Join(OcPgm, AM)\xFE";
    z += "    OutputTryCatch = Instr(sOcpgm, 'onError':'Goto')\xFE";
    z += "    Adddebugging = InStr(socPgm, \"dbgCheck\")\xFE";
    z += "    Ocpgm = Split(sOcPgm, AM) ' Fix embedded AM's to be part of the array\xFE";
    z += "    sOcPgm = \"\"\xFE";
    z += "    \xFE";
    z += "    Loop While UBound(Ocpgm) > 0 Do\xFE";
    z += "        If Ocpgm[1] = \"\" Then Ocpgm.DELETE(1) Else Break\xFE";
    z += "    Repeat\xFE";
    z += "    Indent = 4\xFE";
    z += "    \xFE";
    z += "    *********************************************************************\xFE";
    z += "    * Process the SYMTAB file, and build the following lists:\xFE";
    z += "    *********************************************************************\xFE";
    z += "    **\xFE";
    z += "    * If we had no actual code, we are just a Symbol (COMMONS / EQUATES) files\xFE";
    z += "    *\xFE";
    z += "    If functionType = -1 Then\xFE";
    z += "        if (!subName) then\xFE";
    z += "            subName = ItemId\xFE";
    z += "            Globals = True\xFE";
    z += "        end if\xFE";
    z += "        \xFE";
    z += "        Writejson Symtab On D_file, Subname:\".SYM\" Else Stop @Errors\xFE";
    z += "        incFilesSrc['DICT+':ucase(Pcfname:\"+\":Subname):'.sym'] = Symtab\xFE";
    z += "        if !Globals Then return\xFE";
    z += "    Else\xFE";
    z += "        Delete D_file, Subname:\".SYM\" Else Null\xFE";
    z += "    end if\xFE";
    z += "    \xFE";
    z += "    If Subname = \"\" Then Subname = Itemid\xFE";
    z += "    if dontMorphFunctionName Then \xFE";
    z += "        CName = Truesubname\xFE";
    z += "        Appendage = \"\"\xFE";
    z += "    Else\xFE";
    z += "        Cname = Cur_realfname:\"_\":Subname\xFE";
    z += "        Cname = makesubname(Cname)\xFE";
    z += "        Appendage = calcAppendage(functionType)\xFE";
    z += "    End if\xFE";
    z += "\xFE";
    z += "    Pdef = {}\xFE";
    z += "    Pdef.SUB_COMPILEDATE = 'Compiled on ':Timedate():' in ':Itemid\xFE";
    z += "    Pdef.SUB_FNAME = LCase(Pcfname)\xFE";
    z += "    Pdef.SUB_INAME = LCase(Itemid)\xFE";
    z += "    Pdef.SUB_FIRSTLINE = Firstlineno\xFE";
    z += "    Pdef.SUB_RTNTYPE = \"\"\xFE";
    z += "    Pdef.SUB_MAYBEIJS = !hasPromises And !hasByRefParamters\xFE";
    z += "    Pdef.SUB_PARAMTYPES = \"\" ;* Will be computed below \xFE";
    z += "    Pdef.SUB_ISCALLEDBY = \"\"\xFE";
    z += "    Pdef.SrcEdit = Anchoredit(Pdef.SUB_FNAME, Pdef.SUB_INAME, Pdef.SUB_CNAME, \"\", \"\", Pdef.SUB_FIRSTLINE)\xFE";
    z += "    Pdef.SUB_CNAME = Cname:Appendage             ; * Name Used By C, As In Call\xFE";
    z += "    Pdef.SUB_SUBNAME = Subname                   ; * Name Used By Basic Call\xFE";
    z += "    Pdef.SUB_CALLSTO = Join(Calllist, \",\")\xFE";
    z += "    Pdef.SUB_ISFUNCTION = functionType\xFE";
    z += "    Pdef.SUB_NOAWAITSALLOWED = NotASyncFunction\xFE";
    z += "    Pdef.SUB_USINGASYNCFUNCS = Join(hasPromises, \",\")\xFE";
    z += "    Pdef.SUB_OPTIONALPARAMCNT = optionalParamCnt\xFE";
    z += "\xFE";
    z += "    If functionType = 3 Then Return ;* Server Side Rest Funciton\xFE";
    z += "\xFE";
    z += "    If functionType >= 2 Then\xFE";
    z += "        Rattr = Clone(Funcattr)\xFE";
    z += "        Rattr.SYM_ISCONST = 1\xFE";
    z += "        declaration = Builddec(Rattr) ;* returns declaration.Var, declaration.Calldef, and declaration.Cinit\xFE";
    z += "        Pdef.SUB_RTNTYPE = declaration.Calldef\xFE";
    z += "    End\xFE";
    z += "    \xFE";
    z += "    * Build list of Local variables\xFE";
    z += "    Locallist = [] \xFE";
    z += "    hasCommons = False\xFE";
    z += "    \xFE";
    z += "    LocalTypes = Flavor_local:Flavor_function:Flavor_Equate\xFE";
    z += "    For Each Id In Symtab\xFE";
    z += "        Rattr = Clone(Symtab[Id])\xFE";
    z += "        if Rattr.SYM_FLAVOR = Flavor_common Then hasCommons = True\xFE";
    z += "        \xFE";
    z += "        If Index(LocalTypes,Rattr.SYM_FLAVOR,1) Then\xFE";
    z += "            if !Rattr.isAlreadyDefined Then\xFE";
    z += "                declaration = Builddec(Rattr)  ;* returns declaration.Var, declaration.Calldef, and declaration.Cinit\xFE";
    z += "                Typedef = declaration.Var:declaration.Cinit\xFE";
    z += "                \xFE";
    z += "                Begin Case\xFE";
    z += "                    Case Rattr.SYM_FLAVOR = Flavor_local\xFE";
    z += "                        If Not(Index(Rattr.SYM_TYPES,Symtypes_stored,1)) And Rattr.SYM_INDEX1='' And Rattr.SYM_INCLEVEL = 0 Then\xFE";
    z += "                            Call Warning(\"Symbol \":Id:\" never assigned a value\")\xFE";
    z += "                        End\xFE";
    z += "                        LocalList[-1] = Typedef\xFE";
    z += "    \xFE";
    z += "                    Case Rattr.SYM_FLAVOR = Flavor_function\xFE";
    z += "                        LocalList[-1] = Typedef ;* Allow Functioname = Result\xFE";
    z += "    \xFE";
    z += "                    Case Rattr.SYM_FLAVOR = Flavor_Equate\xFE";
    z += "                        if Rattr.SYM_INCLEVEL = -1 Then LocalList[-1] = Typedef \xFE";
    z += "    \xFE";
    z += "                End Case\xFE";
    z += "            End If\xFE";
    z += "        End If\xFE";
    z += "    Next\xFE";
    z += "\xFE";
    z += "    *********************************************************************\xFE";
    z += "    * Actual subroutine, Compute FuncHeader and parameter string\xFE";
    z += "    *********************************************************************\xFE";
    z += "    If NotASyncFunction Then\xFE";
    z += "        if hasPromises Then\xFE";
    z += "            Call Err(\"ROUTINE CAN'T BE AN IJS ROUTINE.  Remove the $options IJS or fix errors: \":Join(hasPromises, \" * \"):\".\")\xFE";
    z += "        End If\xFE";
    z += "        FuncHeader = 'function ':Cname:Appendage // Subname\xFE";
    z += "    Else\xFE";
    z += "        FuncHeader = 'async function ':Cname:Appendage // Subname\xFE";
    z += "    End If\xFE";
    z += "        \xFE";
    z += "    Fparams = ''                       ; * On Procedure Definition\xFE";
    z += "    Cmd = \"\"\xFE";
    z += "    ByRefRTNRec = \"\"\xFE";
    z += "    SUB_PARAMTYPES = []\xFE";
    z += "    For Each ID, ParamI In ParamList\xFE";
    z += "        Rattr = readsym(Id)\xFE";
    z += "        declaration = Builddec(Rattr) ;* returns declaration.Var, declaration.Calldef (vsim...), and declaration.Cinit (var = nnn)\xFE";
    z += "        if Rattr.SYM_ISBYVAL Then declaration.Calldef = UCase(declaration.Calldef)\xFE";
    z += "        SUB_PARAMTYPES[ParamI] = declaration.Calldef\xFE";
    z += "\xFE";
    z += "        If Fparams Then Fparams = Fparams:\", \"\xFE";
    z += "        Fparams := declaration.Var\xFE";
    z += "        \xFE";
    z += "        // Need to build a script to is used for callbacks when we have ByRef variables\xFE";
    z += "        If !Rattr.SYM_ISBYVAL Then\xFE";
    z += "            if ByRefRTNRec Then ByRefRTNRec := \", \"\xFE";
    z += "            ByRefRTNRec := declaration.Var\xFE";
    z += "        End If\xFE";
    z += "    Next ParamI\xFE";
    z += "    \xFE";
    z += "    Pdef.SUB_PARAMTYPES = Join(SUB_PARAMTYPES, \",\") \xFE";
    z += "    \xFE";
    z += "    if ByRefRTNRec Then \xFE";
    z += "        If Fparams Then Fparams = Fparams:\", \"\xFE";
    z += "        Fparams := 'setByRefValues'\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    // -1) COMMONS, 0) PROGRAM, 1) SUBROUTINE, 2) FUNCTION, 3) @@FUNCTION, 4) PICK/RESTFUL FUNCTION \xFE";
    z += "    Select Case functionType\xFE";
    z += "        Case -1: Note = ' // COMMONS'\xFE";
    z += "        Case 0:  Note = ' // PROGRAM'\xFE";
    z += "        Case 1:  Note = ''\xFE";
    z += "        Case 2:  Note = ''\xFE";
    z += "        Case 3:  Note = ' // @@function'\xFE";
    z += "        Case 4:  Note = ' // restful function (or Pick Function)'\xFE";
    z += "    End Select\xFE";
    z += "    \xFE";
    z += "    FuncHeader := '(':Fparams:') { ':Note\xFE";
    z += "    Hpfx = [FuncHeader]\xFE";
    z += "    \xFE";
    z += "    If functionType <= 0 Then // Commons \xFE";
    z += "        ucIFileName = UCase(Pcfname)\xFE";
    z += "        \xFE";
    z += "        CommonsName = \"Commons_\":ucIFileName // :\"_\":Makevarname(ItemId)\xFE";
    z += "        EquatesName = \"Equates_\":ucIFileName // :\"_\":Makevarname(ItemId)\xFE";
    z += "        includeSubName = `Include_`:ucIFileName:`_`:Makevarname(ItemId)\xFE";
    z += "    \xFE";
    z += "        if functionType = -1 Then\xFE";
    z += "            Hpfx = [`async function `:includeSubName:`(forceReset) {`]\xFE";
    z += "            Hpfx[-1] = Space(Indent):`forceReset |= (typeof `:CommonsName:` == \"undefined\") || (typeof `:EquatesName:` == \"undefined\"); `\xFE";
    z += "            Hpfx[-1] = Space(Indent):`if (!forceReset) return; `\xFE";
    z += "            Hpfx[-1] = ``\xFE";
    z += "            Hpfx[-1] = Space(Indent):CommonsName:` = {}; `\xFE";
    z += "            Hpfx[-1] = Space(Indent):EquatesName:` = {}; `\xFE";
    z += "            Hpfx[-1] = ``\xFE";
    z += "        else\xFE";
    z += "            Hpfx[-1] = Space(Indent):CommonsName:` = {}; `\xFE";
    z += "            Hpfx[-1] = Space(Indent):EquatesName:` = {}; `\xFE";
    z += "            Hpfx[-1] = ``\xFE";
    z += "        end if\xFE";
    z += "        \xFE";
    z += "    end if\xFE";
    z += "        \xFE";
    z += "    *********************************************************************\xFE";
    z += "    * Build the startup prefix for the function\xFE";
    z += "    *********************************************************************\xFE";
    z += "    *\xFE";
    z += "    \xFE";
    z += "    if Adddebugging Or InsideClass Then\xFE";
    z += "        Hpfx[-1] = Space(Indent):'var me = new jsbRoutine(\"':Replace(UCase(Pcfname),`\\`, `\\\\`) :'\", \"':Itemid:'\", \"':Cname:Appendage:'\"); '\xFE";
    z += "        if Adddebugging And !NotASyncFunction Then Hpfx[-1] = Space(Indent):'me.localValue = function (varName) { return eval(varName) }'\xFE";
    z += "    End If\xFE";
    z += "\xFE";
    z += "    If Locallist Then\xFE";
    z += "        Hpfx[-1] = Space(Indent):'// local variables'\xFE";
    z += "        LL = \"\"\xFE";
    z += "        AddC = 0\xFE";
    z += "        For Each L, LI In Locallist\xFE";
    z += "            If Len(ll) > 60 Then AddC = 0\xFE";
    z += "            if !AddC Then\xFE";
    z += "                If LL Then Hpfx[-1] = LL:';'\xFE";
    z += "                LL = Space(Indent):'var '\xFE";
    z += "            End If\xFE";
    z += "            if addC Then LL := ', '\xFE";
    z += "            LL := L\xFE";
    z += "            addC = 1\xFE";
    z += "        Next\xFE";
    z += "        if LL Then Hpfx[-1] = LL:';'\xFE";
    z += "        Hpfx[-1] = ''\xFE";
    z += "        LL = \"\"\xFE";
    z += "    Endif\xFE";
    z += "    If OutputTryCatch Then Hpfx[-1] = Space(Indent):'   var onError;'\xFE";
    z += "    if Isrestfulfunction Then Hpfx[-1] = Space(Indent):'   var Restful_Result;'\xFE";
    z += "    \xFE";
    z += "    startIndent = indent\xFE";
    z += "    if hasLbl Then \xFE";
    z += "        Hpfx[-1] = Space(Indent):'var gotoLabel = \"\";'\xFE";
    z += "        Hpfx[-1] = Space(indent):'atgoto: while (true) {'\xFE";
    z += "        indent += 4\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    \xFE";
    z += "    If OutputTryCatch Then \xFE";
    z += "        Hpfx[-1] = Space(Indent):'try {'\xFE";
    z += "        Indent += 4\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    if hasLbl Then\xFE";
    z += "        Hpfx[-1] = Space(Indent):'switch (gotoLabel) {'\xFE";
    z += "        Indent += 4\xFE";
    z += "        Hpfx[-1] = Space(Indent):'case \"\":'\xFE";
    z += "        Indent += 4\xFE";
    z += "    end if\xFE";
    z += "        \xFE";
    z += "    extraIndent = Indent - startIndent\xFE";
    z += "    if extraIndent Then\xFE";
    z += "        Ocpgm = Split(Join(Ocpgm, Am()), Am())\xFE";
    z += "        for Li = 1 to UBound(Ocpgm)\xFE";
    z += "            Ocpgm[Li] = Space(extraIndent):Ocpgm[li]\xFE";
    z += "        next\xFE";
    z += "    end if\xFE";
    z += "    \xFE";
    z += "    if ByRefRTNRec then\xFE";
    z += "        Hpfx[-1] = Space(Indent):'function exit(v) {'\xFE";
    z += "        Hpfx[-1] = Space(Indent):\"    if (typeof setByRefValues == 'function') setByRefValues(\":ByRefRTNRec:\")\"\xFE";
    z += "        Hpfx[-1] = Space(Indent):'    return v'\xFE";
    z += "        Hpfx[-1] = Space(Indent):'}'\xFE";
    z += "    End If\xFE";
    z += "\xFE";
    z += "    if Adddebugging And !NotASyncFunction Then Hpfx[-1] = Space(Indent):'await dbgCheck(me, ':Firstlineno:', true /* modal */); '\xFE";
    z += "    \xFE";
    z += "    *\xFE";
    z += "    * Output return code to Ocpgm[]\xFE";
    z += "    *\xFE";
    z += "    lastLine = Split(Ocpgm[UBound(Ocpgm)], Crlf())\xFE";
    z += "    lastLine = LTrim(lastLine[UBound(lastLine)])\xFE";
    z += "    \xFE";
    z += "    if Left(lastLine, 7) <> \"return \" Then\xFE";
    z += "        // -1) COMMONS, 0) PROGRAM, 1) SUBROUTINE, 2) FUNCTION, 3) @@FUNCTION, 4) PICK/RESTFUL FUNCTION \xFE";
    z += "        \xFE";
    z += "        If functionType = -1 Then \xFE";
    z += "            // Ocpgm[-1] = Space(Indent):'Commons_':UCase(Cur_realfname):' = true; '\xFE";
    z += "            // Ocpgm[-1] = Space(Indent):'Commons_':UCase(Cur_realfname):'.':Makevarname(Subname):' = true; '\xFE";
    z += "            Ocpgm[-1] = Space(Indent):'return; '\xFE";
    z += "            \xFE";
    z += "        End Else If functionType=0 Then // Program\xFE";
    z += "            Ocpgm[-1] = Space(Indent):'return; '\xFE";
    z += "            \xFE";
    z += "        End Else  // Sub & function\xFE";
    z += "            if hasByRefParamters then\xFE";
    z += "                Ocpgm[-1] = Space(Indent):'return exit(); '\xFE";
    z += "            Else\xFE";
    z += "                // Ocpgm[-1] = Space(Indent):'return; '\xFE";
    z += "            End if\xFE";
    z += "            \xFE";
    z += "        //Else // function\xFE";
    z += "        //    Rattr = readsym(Funcattr.SYMNAME)\xFE";
    z += "        //    if hasByRefParamters then\xFE";
    z += "        //        Ocpgm[-1] = Space(Indent):'return exit(':Rattr.SYM_C:'); '\xFE";
    z += "        //    Else\xFE";
    z += "        //        Ocpgm[-1] = Space(Indent):'return ':Rattr.SYM_C:'; '\xFE";
    z += "        //    End if\xFE";
    z += "        \xFE";
    z += "        End If\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    if hasLbl Then\xFE";
    z += "        Ocpgm[-1] = ''\xFE";
    z += "        Ocpgm[-1] = ''\xFE";
    z += "        Indent -= 4\xFE";
    z += "        Ocpgm[-1] = Space(Indent):'default:'\xFE";
    z += "        Ocpgm[-1] = Space(Indent+ 4):'throw \"we entered an invalid gotoLabel: \" + gotoLabel; '\xFE";
    z += "        Indent -= 4\xFE";
    z += "        Ocpgm[-1] = Space(Indent):'} // switch'\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    If OutputTryCatch Then\xFE";
    z += "        Indent -= 4\xFE";
    z += "        Ocpgm[-1] = Space(Indent):\"} catch (err) {\"\xFE";
    z += "        Ocpgm[-1] = Space(Indent + 4):\"err = err2String(err);\"\xFE";
    z += "        Ocpgm[-1] = Space(Indent + 4):\"if (err.startsWith('*STOP*')) throw err;\"\xFE";
    z += "        Ocpgm[-1] = Space(Indent + 4):\"if (err.startsWith('*END*')) throw err;\"\xFE";
    z += "        Ocpgm[-1] = Space(Indent + 4):\"if (_onError\":\"Goto) { \"\xFE";
    z += "        Ocpgm[-1] = Space(Indent + 8):\"gotoLabel = _onError\":\"Goto; \"\xFE";
    z += "        Ocpgm[-1] = Space(Indent + 8):\"if (err.message) activeProcess.At_Errors = err.message; else activeProcess.At_Errors = err; \"\xFE";
    z += "        Ocpgm[-1] = Space(Indent + 4):\"} else throw err; \"\xFE";
    z += "        Ocpgm[-1] = Space(Indent):\"}\"\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    if hasLbl Then\xFE";
    z += "        Ocpgm[-1] = Space(Indent):'} // agoto while'\xFE";
    z += "        Indent -= 4\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    Ocpgm[-1] = '}'  // end of function\xFE";
    z += "    Ocpgm[-1] = ''\xFE";
    z += "\xFE";
    z += "    Src = Join(Hpfx, Crlf()):Crlf():Join(Ocpgm, Crlf())\xFE";
    z += "    \xFE";
    z += "    If Showlist Then Print; Print Src\xFE";
    z += "    \xFE";
    z += "    if SErrCnt <> ErrCnt Then\xFE";
    z += "        Print Chr(16):Subname:\" had errors, no .js file written\":Chr(16)\xFE";
    z += "        Return\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    call UpdateJScode(Src, Pcfname, Subname, Appendage)\xFE";
    z += "    \xFE";
    z += "    // Update cross references (and writes PDEF)   \xFE";
    z += "    Call updateCrossReference(Pdef)    \xFE";
    z += "End Subroutine\xFE";
    z += "\xFE";
    z += "// issub -1) common, 0) program, 1) sub, 2) function     \xFE";
    z += "Subroutine UpdateJScode(Src, fName, sName, Appendage)\xFE";
    z += "    $Insert _comms\xFE";
    z += "    \xFE";
    z += "    Loop c = right(Src, 1) while c = am() or c = chr(32) or c = cr() or c = lf() do\xFE";
    z += "        src = left(src, len(src)-1)\xFE";
    z += "    repeat\xFE";
    z += "    \xFE";
    z += "    outIName = LCase(sName:Appendage:\".js\")    \xFE";
    z += "    // Write Src On D_ffile, outIName Else Stop @Errors\xFE";
    z += "    \xFE";
    z += "    // If Not(Hush) Then Print Chr(16):outIName:\" \":anchorEdit(\"dict \":fName, outIName):\" \":Len(Src):\" bytes. Successful. \":UBound(ItemList):\" item(s) remaining.\":Chr(16)        \xFE";
    z += "    If Not(Hush) Then Print Chr(16):outIName:\" \":Len(Src):\" bytes. Successful. \":UBound(ItemList):\" item(s) remaining.\":Chr(16)        \xFE";
    z += "\xFE";
    z += "    ItemID = UCase(ItemID)\xFE";
    z += "\xFE";
    z += "    outputName = fName:\".js\"\xFE";
    z += "    Read LinkJS From D_ffile, outputName Else LinkJS =\"\"\xFE";
    z += "\xFE";
    z += "    Marker = \"// <\":UCase(sName):Appendage:\">\"\xFE";
    z += "    Marker2 = \"// </\":UCase(sName):Appendage:\">\"\xFE";
    z += "    \xFE";
    z += "    I = Instr(LinkJS, Marker)\xFE";
    z += "    If I Then\xFE";
    z += "        J = Instr(LinkJS, Marker2)\xFE";
    z += "        If !J Then I = 0\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    If I Then\xFE";
    z += "        LineNo = DCount(Left(LinkJS, I), am())\xFE";
    z += "        LinkJS = Left(LinkJS, I-1):Marker:am():Src:am():Mid(LinkJS, J)\xFE";
    z += "    Else\xFE";
    z += "        LinkJS := am():Marker:am():Src:am():Marker2:am()\xFE";
    z += "    End If\xFE";
    z += "\xFE";
    z += "    Write LinkJS On D_ffile, outputName Else Stop @Errors\xFE";
    z += "    Print anchorEdit(\"dict \":fName, outputName, \"Results writtien to dict \":fName:\" \":outputName, \"\", \"\", LineNo)\xFE";
    z += "\xFE";
    z += "            \xFE";
    z += "    // Update in memory copies           \xFE";
    z += "    If System(1) = \"js\" Then\xFE";
    z += "javascript {\xFE";
    z += "    await loadJsbStandardLibraries(ByRef_Fname);\xFE";
    z += "}\xFE";
    z += "\xFE";
    z += "        * IF PROGRAM - Catalog\xFE";
    z += "        If Docatalog  Then\xFE";
    z += "            Read Cdef From @Fhandle(\"MD\"), sName Else Cdef = \"\"\xFE";
    z += "            L1 = LCase(Cdef<1>)\xFE";
    z += "            Locate \"cv\" In L1<1> Setting Spot Else Null\xFE";
    z += "    \xFE";
    z += "            Cdef<1, Spot> = \"cv\"\xFE";
    z += "            Cdef<2, Spot> = fName\xFE";
    z += "            Cdef<3, Spot> = sName\xFE";
    z += "    \xFE";
    z += "            Write Cdef On @Fhandle(\"MD\"), sName Else Stop @Errors\xFE";
    z += "        End If\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "End Subroutine\xFE";
    z += "\xFE";
    z += "function calcAppendage(byval funcType)\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "    \xFE";
    z += "    // -1) COMMONS, 0) PROGRAM, 1) SUBROUTINE, 2) FUNCTION, 3) @@FUNCTION, 4) PICK/RESTFUL FUNCTION \xFE";
    z += "    \xFE";
    z += "    Select Case funcType\xFE";
    z += "        Case -1 // \xFE";
    z += "            Appendage = \"_Cmns\"\xFE";
    z += "            \xFE";
    z += "        Case 0\xFE";
    z += "            Appendage = \"_Pgm\"\xFE";
    z += "            \xFE";
    z += "        Case 1\xFE";
    z += "            Appendage = \"_Sub\"\xFE";
    z += "            \xFE";
    z += "        Case 2\xFE";
    z += "            Appendage = \"\"\xFE";
    z += "            \xFE";
    z += "        Case Else\xFE";
    z += "            Return \"_AtAt\"\xFE";
    z += "    End Select\xFE";
    z += "    \xFE";
    z += "    Return Appendage\xFE";
    z += "End function\xFE";
    z += "\xFE";
    z += ""
    window.cached_jsb2js["po"] = z;
    window.cached_jsb2js["readxref"] = "function readXRef(byval xdefID as string)\xFE\xFE    \xFE    $Insert _comms\xFE    \xFE    xdefID = LCase(xdefID)\xFE    d = cached_XRefs[xdefID]\xFE    if !d then\xFE        readjson d from fXRefs, xdefID else d = {}\xFE        cached_XRefs[xdefID] = d\xFE    end if\xFE    \xFE    return d\xFEend function\xFE";
    var z = "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "Subroutine Relcmp(ByVal Lattr, ByVal Gattr, ByVal Rop)\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "\xFE";
    z += "    Nullchk = \"\"\xFE";
    z += "    Begin Case\xFE";
    z += "        Case Rop = C_equal Or Rop = C_eq\xFE";
    z += "            // comparing gattr to \"\"?\xFE";
    z += "            If Lattr.SYM_C = \"''\" Or Lattr.SYM_C = '\"\"' Or Lattr.SYM_C = \"``\" Then\xFE";
    z += "                Gattr.SYM_TYPE=Type_eBool\xFE";
    z += "                If Gattr.SYM_TYPE = Type_estr Or Gattr.SYM_TYPE = Type_vstr Or Gattr.SYM_TYPE = Type_cstr Then \xFE";
    z += "                    if InStr(Gattr.SYM_C, ' ') Then Gattr.SYM_C = \"!(\":Gattr.SYM_C:\")\" Else Gattr.SYM_C = \"!\":Gattr.SYM_C:\"\"\xFE";
    z += "                Else\xFE";
    z += "                     Gattr.SYM_C = \"isEmpty(\":Gattr.SYM_C:\")\"\xFE";
    z += "                End if\xFE";
    z += "                \xFE";
    z += "                Return\xFE";
    z += "            End If\xFE";
    z += "\xFE";
    z += "            // comparing \"\" to gattr?\xFE";
    z += "            If Gattr.SYM_C = \"''\" Or Gattr.SYM_C = '\"\"' Or Gattr.SYM_C = \"``\" Then\xFE";
    z += "                Gattr.SYM_TYPE=Type_eBool\xFE";
    z += "                If Lattr.SYM_TYPE = Type_estr Or Lattr.SYM_TYPE = Type_vstr Or Lattr.SYM_TYPE = Type_cstr Then \xFE";
    z += "                    if InStr(Gattr.SYM_C, ' ') Then Gattr.SYM_C = \"!(\":Lattr.SYM_C:\")\" Else Gattr.SYM_C = \"!\":Lattr.SYM_C\xFE";
    z += "                Else\xFE";
    z += "                    Gattr.SYM_C = \"isEmpty(\":Lattr.SYM_C:\")\"\xFE";
    z += "                End If\xFE";
    z += "                \xFE";
    z += "                Return\xFE";
    z += "            End If\xFE";
    z += "            \xFE";
    z += "            Rsy='=='\xFE";
    z += "            \xFE";
    z += "        Case Rop = C_pound Or Rop = C_ne\xFE";
    z += "            // comparing gattr to \"\"?\xFE";
    z += "            If Lattr.SYM_C = \"''\" Or Lattr.SYM_C = '\"\"' Or Lattr.SYM_C = \"``\" Then\xFE";
    z += "                Gattr.SYM_TYPE=Type_eBool\xFE";
    z += "                if Gattr.SYM_TYPE = Type_estr Or Gattr.SYM_TYPE = Type_vstr Or Gattr.SYM_TYPE = Type_cstr Then \xFE";
    z += "                    if InStr(Gattr.SYM_C, ' ') Then Gattr.SYM_C = \"(\":Gattr.SYM_C:\")\"\xFE";
    z += "                Else\xFE";
    z += "                     Gattr.SYM_C = \"!isEmpty(\":Gattr.SYM_C:\")\"\xFE";
    z += "                End if\xFE";
    z += "                \xFE";
    z += "                Return\xFE";
    z += "            End If\xFE";
    z += "            \xFE";
    z += "            // comparing \"\" to gattr?\xFE";
    z += "            If Gattr.SYM_C = \"''\" Or Gattr.SYM_C = '\"\"' Or Gattr.SYM_C = \"``\" Then\xFE";
    z += "                Gattr.SYM_TYPE=Type_eBool\xFE";
    z += "                If Lattr.SYM_TYPE = Type_estr Or Lattr.SYM_TYPE = Type_vstr Or Lattr.SYM_TYPE = Type_cstr Then \xFE";
    z += "                    if InStr(Lattr.SYM_C, ' ') Then Gattr.SYM_C = \"(\":Lattr.SYM_C:\")\" Else Gattr.SYM_C = Lattr.SYM_C\xFE";
    z += "                Else\xFE";
    z += "                    Gattr.SYM_C = \"!isEmpty(\":Lattr.SYM_C:\")\"\xFE";
    z += "                End If\xFE";
    z += "                \xFE";
    z += "                Return\xFE";
    z += "            End If\xFE";
    z += "            \xFE";
    z += "            Rsy='!='\xFE";
    z += "        Case Rop = C_great Or Rop = C_gt\xFE";
    z += "            Rsy='>'\xFE";
    z += "        Case Rop = C_less  Or Rop = C_lt\xFE";
    z += "            Rsy='<'\xFE";
    z += "        Case Rop = C_ge\xFE";
    z += "            Rsy='>='\xFE";
    z += "        Case Rop = C_le\xFE";
    z += "            Rsy='<='\xFE";
    z += "    End Case\xFE";
    z += "*\xFE";
    z += "    // Both string expressions\xFE";
    z += "    If Gattr.SYM_TYPE = Type_estr Or Lattr.SYM_TYPE = Type_estr Then\xFE";
    z += "        Gattr.SYM_C=Lattr.SYM_C:Rsy:Gattr.SYM_C\xFE";
    z += "        Gattr.SYM_TYPE=Type_eBool\xFE";
    z += "        Return\xFE";
    z += "    End\xFE";
    z += "*\xFE";
    z += "    // Both numbers?\xFE";
    z += "    Gnum = Index(Type_cnum:Type_vNum:Type_vBool:Type_eNum:Type_eBool,Gattr.SYM_TYPE,1)\xFE";
    z += "    Lnum = Index(Type_cnum:Type_vNum:Type_vBool:Type_eNum:Type_eBool,Lattr.SYM_TYPE,1)\xFE";
    z += "    If Gnum And Lnum Then\xFE";
    z += "        Gattr.SYM_C=Lattr.SYM_C:Rsy:Gattr.SYM_C\xFE";
    z += "        Gattr.SYM_TYPE=Type_eBool\xFE";
    z += "        Return\xFE";
    z += "    End If\xFE";
    z += "\xFE";
    z += "    // if one is a string constant of at least 1 char\xFE";
    z += "    If (Gattr.SYM_TYPE = Type_cstr and Len(Gattr.SYM_C)) Or (Lattr.SYM_TYPE = Type_cstr and Len(Lattr.SYM_C)) Then\xFE";
    z += "        Gattr.SYM_C= Lattr.SYM_C:Rsy:Gattr.SYM_C\xFE";
    z += "        Gattr.SYM_TYPE=Type_eBool\xFE";
    z += "        Return\xFE";
    z += "    End\xFE";
    z += "    \xFE";
    z += "    // Both strings?\xFE";
    z += "    Gstr = Index(Type_vstr:Type_cstr:Type_estr,Gattr.SYM_TYPE,1)\xFE";
    z += "    Lstr = Index(Type_vstr:Type_cstr:Type_estr,Lattr.SYM_TYPE,1)\xFE";
    z += "    If Gstr And Lstr Then\xFE";
    z += "        Gattr.SYM_C=Lattr.SYM_C:Rsy:Gattr.SYM_C\xFE";
    z += "        Gattr.SYM_TYPE=Type_eBool\xFE";
    z += "        Return\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    * MisMatch Types \xFE";
    z += "    * If one or the other is numeric, and they can both be converted to a number, do a numeric compare, else do a string compare\xFE";
    z += "    *    - here, in the compiler, we make a null into a '', and 0 into a string '0', if possible, javascript will make them numeric if need be\xFE";
    z += "    *\xFE";
    z += "    \xFE";
    z += "    If Lattr.SYM_C = \"null\" Then Lattr.SYM_C = \"''\"\xFE";
    z += "    If Gattr.SYM_C = \"null\" Then Gattr.SYM_C = \"''\"\xFE";
    z += "    If Lattr.SYM_C = \"0\" Then Lattr.SYM_C = \"'0'\"\xFE";
    z += "    If Gattr.SYM_C = \"0\" Then Gattr.SYM_C = \"'0'\"\xFE";
    z += "    \xFE";
    z += "    If InStr(Type_vstr:Type_var:Type_exp, Lattr.SYM_TYPE) Then Lattr.SYM_C = \"Null0(\":Lattr.SYM_C:\")\"\xFE";
    z += "    If InStr(Type_vstr:Type_var:Type_exp, Gattr.SYM_TYPE) Then Gattr.SYM_C = \"Null0(\":Gattr.SYM_C:\")\"\xFE";
    z += "  \xFE";
    z += "    Gattr.SYM_C=Lattr.SYM_C:Rsy:Gattr.SYM_C\xFE";
    z += "    Gattr.SYM_TYPE=Type_eBool\xFE";
    z += "    Return\xFE";
    z += "End Sub"
    window.cached_jsb2js["relcmp"] = z;
    var z = "Subroutine states(byval Ep, byval Lb)\xFE";
    z += "*\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "    La = La:Lb:C_dblSlash:C_Asterisk\xFE";
    z += "    begin case\xFE";
    z += "        case ep = 1 \xFE";
    z += "            Call stmProgramBlock(Lb)\xFE";
    z += "        case ep = 2\xFE";
    z += "            Call stmThenBlock(Lb)\xFE";
    z += "        case ep = 3\xFE";
    z += "            Call stmStatement(Lb)\xFE";
    z += "        case ep = 4\xFE";
    z += "            Call stmAfterThen(Lb)\xFE";
    z += "    end case\xFE";
    z += "    La = La[1,Len(La)-Len(Lb)-2]\xFE";
    z += "End Subroutine\xFE";
    z += "\xFE";
    z += "Subroutine stmProgramBlock(byval Lb)\xFE";
    z += "*\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "\xFE";
    z += "    *\xFE";
    z += "    * Outer most level (Program Block)\xFE";
    z += "    * Assumed beginning of line\xFE";
    z += "    *\xFE";
    z += "    Loop\xFE";
    z += "        If Tkno = C_am Then\xFE";
    z += "            Call Skiprestofline() ;* Flush Oc To Ocpgm\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "            \xFE";
    z += "            Dline = LTrim(Tkline[Index(Tkline, Trim(Tkline)[1,1], 1), 999])\xFE";
    z += "            \xFE";
    z += "            If Dline = '' Then\xFE";
    z += "                If Blankok Then \xFE";
    z += "                    OcPgm[-1] = \"\"\xFE";
    z += "                    Blankok = 0\xFE";
    z += "                End If\xFE";
    z += "            Else\xFE";
    z += "                * Comment?\xFE";
    z += "                If (Dline[1,1]='!' Or Dline[1,1]='*' Or Dline[1,1]=\"'\" Or Dline[1,2]='//') Then\xFE";
    z += "                    Dline = Dline[2,99999]\xFE";
    z += "                    Dline = Dline[Index(Dline, Trim(Dline)[1,1], 1), 999]\xFE";
    z += "                    Ud7 = UCase(Left(Dline, 7))\xFE";
    z += "                    If Ud7 # '$DEFINE' And Ud7 # '$OPTION' And Ud7 # '$INCLUD' Then\xFE";
    z += "                        loop \xFE";
    z += "                            dline = ltrim(dline)\xFE";
    z += "                        while left(dline, 1) = \"/\" do \xFE";
    z += "                            dline = mid(dline, 2)\xFE";
    z += "                        repeat\xFE";
    z += "                        \xFE";
    z += "                        If Trim(Dline) = '' Then\xFE";
    z += "                            If Blankok Then Ocpgm[-1] = \"\"\xFE";
    z += "                            Blankok = 0\xFE";
    z += "                        Else\xFE";
    z += "                            If Incfile = 0 Or functionType = 0 Then Ocpgm[-1] = Space(Indent):'// ':Dline\xFE";
    z += "                            Blankok = 1\xFE";
    z += "                        End\xFE";
    z += "                        Tkpos = 9999\xFE";
    z += "                        Tkno = C_am\xFE";
    z += "                    End\xFE";
    z += "                Else\xFE";
    z += "                    If Incfile = 0 Or functionType = 0 Then\xFE";
    z += "                        If Addcmt Then Ocpgm[UBound(Ocpgm)+2] = Space(Indent):'// ***** ':Dline\xFE";
    z += "                    End If\xFE";
    z += "                    Blankok = 1\xFE";
    z += "                End If\xFE";
    z += "            End If\xFE";
    z += "        End\xFE";
    z += "        *\xFE";
    z += "        * check for labels\xFE";
    z += "        *\xFE";
    z += "        If Tkno = C_number Or (Mid(Tkline, Tkpos, 1) = \":\" And Mid(Tkline, Tkpos, 1) <> \"=\") Then\xFE";
    z += "            * a LABEL\xFE";
    z += "            Tkstr = makesubname(Tkstr)\xFE";
    z += "            Call Deflbl(Tkstr, 1)\xFE";
    z += "            If Right(Oc,1) # ' ' Then OC := ' '\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "            If Tkno = C_colon Then Call Tcv(False)\xFE";
    z += "        End\xFE";
    z += "        \xFE";
    z += "        If Tkno <> C_am And Tkno <> C_sm Then \xFE";
    z += "            La = La:C_am ; Call stmStatement(lb) ; La = La[1,Len(La)-1]\xFE";
    z += "        End If\xFE";
    z += "        \xFE";
    z += "        If Index(C_str:C_dblSlash:C_asterisk:C_bang:C_fslash, Tkno, 1) Then Call Skiprestofline()\xFE";
    z += "        \xFE";
    z += "    While Tkno = C_am Do Repeat\xFE";
    z += "    If Trim(Oc) # \"\" Then Ocpgm[-1] = Oc; Oc = \"\"\xFE";
    z += "End Subroutine\xFE";
    z += "\xFE";
    z += "Subroutine stmAfterThen(byval Lb)\xFE";
    z += "*\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "    If Tkno <> C_am And Tkno <> C_sm Then\xFE";
    z += "        La = La:C_am ; Call stmStatement(Lb) ; La = La[1,Len(La)-1]\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    If Tkno = C_am then Call stmProgramBlock(lb)\xFE";
    z += "End Subroutine\xFE";
    z += "\xFE";
    z += "Subroutine stmThenBlock(byval Lb)\xFE";
    z += "*\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "\xFE";
    z += "    * THEN block (Statements to EOL or NULL + Program Block)\xFE";
    z += "    If Tkno = C_am Or Tkno = C_semi Or Tkstr[1,1] = \"'\" Or Tkstr = \"{\" Or Tkno = C_fslash Or Tkno = C_asterisk Or Tkno = C_dblSlash Then\xFE";
    z += "        If Tkno = C_semi Then\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "            If Tkno <> C_am Then\xFE";
    z += "                * check for comment\xFE";
    z += "                If Tkno <> C_asterisk And Tkno <> C_bang And Tkno <> C_dblSlash And Tkno <> C_str And Tkno <> C_fslash Then Call Err(\"Invalid characters\")\xFE";
    z += "                Call Skiprestofline()\xFE";
    z += "                Call Tcv(False) ;* Skip Over Am\xFE";
    z += "            End If\xFE";
    z += "        ElseIf Tkstr[1,1] = \"'\" Or Tkno = C_fslash Or Tkno = C_asterisk Or Tkno = C_dblSlash Then\xFE";
    z += "            Call Skiprestofline()\xFE";
    z += "            Call Tcv(False) ;* Skip Over Am\xFE";
    z += "        End\xFE";
    z += "        \xFE";
    z += "        Call ResetI(3)\xFE";
    z += "        If Tkstr = \"{\" Then\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "            Call stmProgramBlock(Lb)\xFE";
    z += "            If Tkstr = \"}\" Then Call Tcv(False) Else Call Err(\"} EXPECTED\")\xFE";
    z += "        Else\xFE";
    z += "            La = La:C_end:C_else ; Call stmProgramBlock(Lb) ; La = La[1,Len(La)-2]\xFE";
    z += "            If Tkno = C_end Then\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                If Tkstr = \"IF\" Then Call Tcv(False)\xFE";
    z += "            Else\xFE";
    z += "                If Tkno <> C_else Then Call Err('END expected')\xFE";
    z += "            End\xFE";
    z += "        End If\xFE";
    z += "        Call ResetI(-3)\xFE";
    z += "    Else \xFE";
    z += "        Call stmStatement(lb) \xFE";
    z += "    end if\xFE";
    z += "End Subroutine\xFE";
    z += "\xFE";
    z += "Subroutine stmStatement(byval Lb)\xFE";
    z += "    $Insert _comms\xFE";
    z += "    \xFE";
    z += "    Tmpvari = 0\xFE";
    z += "    La = La:C_semi\xFE";
    z += "    \xFE";
    z += "    Loop\xFE";
    z += "        For Breakcase=1 To 1\xFE";
    z += "            Hardstuff = 0\xFE";
    z += "            Begin Case\xFE";
    z += "                Case Tkno = C_bang Or Tkno = C_dblSlash Or Tkno = C_asterisk Or Tkno = C_str\xFE";
    z += "                    If Tkno = C_str Then Cmt = Tkstr Else Cmt = Trim(Tkline[Tkpos, 999])\xFE";
    z += "                    If Tkno = C_fslash Then Cmt = LTrim(Cmd[2,999])\xFE";
    z += "                    Ud7 = UCase(Left(Cmt, 7))\xFE";
    z += "                    if Ud7 = '$INCLUD' Then\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Hardstuff = 1\xFE";
    z += "                        \xFE";
    z += "                    ElseIf Ud7 = '$DEFINE' Or Ud7 = \"$OPTION\" Then\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Call Options\xFE";
    z += "                        \xFE";
    z += "                    Else\xFE";
    z += "                        If Incfile = 0 Then OC := \"// \":Cmt\xFE";
    z += "                        Tkpos = 9999\xFE";
    z += "                        Tkno = C_am\xFE";
    z += "                    End If\xFE";
    z += "                    \xFE";
    z += "                Case Tkstr = '$DEFINE' Or Tkstr = \"$OPTIONS\" Or Tkstr = \"$OPTION\"\xFE";
    z += "                    Call Options\xFE";
    z += "                    \xFE";
    z += "                Case Tkstr = \"COMMON\" Or Tkstr = \"COM\"\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    Call Typedef(Flavor_common, True /* Process Commas */, False /* isObject */)\xFE";
    z += "                    \xFE";
    z += "                Case Tkstr = \"EQUATE\" Or Tkstr = \"EQU\" Or Tkstr = \"CONST\"\xFE";
    z += "                    Call Defineequates\xFE";
    z += "                    \xFE";
    z += "                Case Tkstr = \"SUB\" Or Tkstr = \"SUBROUTINE\" Or Tkstr = \"VOID\" Or Tkstr = \"PROGRAM\" Or Tkstr = \"FUNCTION\" Or Tkstr = \"FUNC\" Or Tkstr = \"COMMONS\" Or Tkstr = \"GLOBALS\" Or Tkstr = \"CLASS\" Or Tkstr = \"PARTIAL\" Or Tkstr = \"PICK\" Or Tkstr = \"RESTFUL\"\xFE";
    z += "                    NextC = Left(LTrim(TKLINE[TKPOS,5]), 1)\xFE";
    z += "                    if InStr(\"=+-*/:<>[]()\", NextC) Then Hardstuff = 1\xFE";
    z += "                    \xFE";
    z += "                Case Tkstr = \"REM\"\xFE";
    z += "                    Loop While Tkno <> C_am And Tkno <> C_sm Do\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                    Repeat\xFE";
    z += "                    \xFE";
    z += "                Case Tkno = C_pound\xFE";
    z += "                    Call Macro\xFE";
    z += "                Case Tkno = C_semi\xFE";
    z += "                    Null\xFE";
    z += "                    \xFE";
    z += "                Case Tkstr = ''\xFE";
    z += "                    La = La[1,Len(La)-1]\xFE";
    z += "                    Return\xFE";
    z += "                Case 1\xFE";
    z += "                    Hardstuff = 1\xFE";
    z += "            End Case\xFE";
    z += "        Next\xFE";
    z += "        \xFE";
    z += "        If Hardstuff Then\xFE";
    z += "            * Peek ahead (but not past comments)\xFE";
    z += "            If Index(C_str:C_dblSlash:C_asterisk:C_bang, Tkno, 1) Then\xFE";
    z += "                Ptkno = C_question\xFE";
    z += "            Else\xFE";
    z += "                // Check for -=, +=, *=, := /= assignment\xFE";
    z += "                Ptkno = Peektk()\xFE";
    z += "                If Index(C_plus:C_minus:C_fslash:C_asterisk:C_Colon, Ptkno, 1)  Then\xFE";
    z += "                    FL = Mid(LTrim(Mid(Tkline, TkPos)), 2, 1)\xFE";
    z += "                    if FL <> \"=\" Then PtkNo = C_question\xFE";
    z += "                End if\xFE";
    z += "            End\xFE";
    z += "            \xFE";
    z += "            For Breakcase=1 To 1\xFE";
    z += "                Hardcode = 1\xFE";
    z += "                \xFE";
    z += "                If Tkstr = \"SELECT\" Then\xFE";
    z += "                    Htk = savetk()\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    If Tkstr = \"CASE\" Then \xFE";
    z += "                        Call Restoret(Htk)\xFE";
    z += "                    Else\xFE";
    z += "                        Call Restoret(Htk)\xFE";
    z += "                        TkStr = \"SELECTFILE\"\xFE";
    z += "                    End If\xFE";
    z += "                end if\xFE";
    z += "                \xFE";
    z += "                Begin Case\xFE";
    z += "                    Case Index(C_equal:C_less:C_lbrack:C_plus:C_minus:C_fslash:C_asterisk:C_Colon, Ptkno, 1) And Tkstr <> \"PRINT\" And Tkstr <> \"RETURN\" And Tkstr <> \"FORMLIST\" And Tkstr <> \"SAVELIST\" And Tkstr <> \"WRITELIST\" And Tkstr <> \"CASE\"\xFE";
    z += "                        Call Assment\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"BEGIN\" Or Tkstr = \"SELECT\" Or Tkstr = \"SWITCH\"\xFE";
    z += "                        Cmd = Tkstr\xFE";
    z += "                        Begincase = Tkstr = \"BEGIN\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "\xFE";
    z += "                        If Begincase And Tkstr = \"CASE\" Then Call Tcv(False)\xFE";
    z += "                        \xFE";
    z += "                        * BEGIN CASE\xFE";
    z += "                        *   CASE AEXPR\xFE";
    z += "                        *\xFE";
    z += "                        * OR \xFE";
    z += "                        * SELECT CASE BEXPR\xFE";
    z += "                        *   CASE AEXPR\xFE";
    z += "                        *\xFE";
    z += "                        Postpgm = \"\"\xFE";
    z += "                        Breaklbl = \"_toEndCase_\":Nxtlbl; Nxtlbl = Nxtlbl + 1\xFE";
    z += "                        \xFE";
    z += "                        *\xFE";
    z += "                        If Trim(Oc) # \"\" Then Ocpgm[-1] = Oc; Oc = \"\"\xFE";
    z += "                        HoldOCPGM = Ocpgm; Ocpgm = []; Sellbl = Nxtlbl; Nxtlbl = Nxtlbl + 1\xFE";
    z += "                        \xFE";
    z += "                        If Begincase Then\xFE";
    z += "                            OC := 'switch (true) { '\xFE";
    z += "                        Else\xFE";
    z += "                            If Tkstr = \"CASE\" Then Call Tcv(False)\xFE";
    z += "                            Aexpr = Expr(Type_eNum,1,C_case:C_sm:C_default)\xFE";
    z += "                            OC := 'switch (':Aexpr.SYM_C:') {'\xFE";
    z += "                        End If\xFE";
    z += "                        \xFE";
    z += "                        Braces = Tkno = C_lbrace\xFE";
    z += "                        If Braces Then Call Tcv(False)\xFE";
    z += "                        \xFE";
    z += "                        * SKIP TO FIRST CASE\xFE";
    z += "                        Loop Until Tkno = C_case Or Tkno = C_default Or Tkno = C_sm Do\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            Oc<-1> = ''\xFE";
    z += "                        Repeat\xFE";
    z += "                        \xFE";
    z += "                        * loop on the \"Case\" labels\xFE";
    z += "                        Loop While Tkno = C_case Or Tkno = C_default Do\xFE";
    z += "                            Call Reseti(3)\xFE";
    z += "                            If Tkno = C_case Then Call Tcv(False)\xFE";
    z += "                            \xFE";
    z += "                            If Tkstr = \"DEFAULT\" Or Tkno = C_else Then\xFE";
    z += "                                OC := 'default: '\xFE";
    z += "                                Call Tcv(False)\xFE";
    z += "                            Else\xFE";
    z += "                                * loop on the matching expressions\xFE";
    z += "                                OC := 'case '\xFE";
    z += "                                Loop\xFE";
    z += "                                    Aexpr = Expr(Type_eNum,1,C_comma:C_colon)\xFE";
    z += "                                    If Begincase Then Call Makebool(Aexpr, true)\xFE";
    z += "                                    OC := Aexpr.SYM_C\xFE";
    z += "                                While Tkno = C_comma Do\xFE";
    z += "                                    Call Tcv(False)\xFE";
    z += "                                    OC := ': case '\xFE";
    z += "                                Repeat\xFE";
    z += "                                If Right(RTrim(Oc), 1) <> \":\" Then OC := ': '\xFE";
    z += "                            End If\xFE";
    z += "\xFE";
    z += "                            If Tkno = C_colon Then Call Tcv(False)\xFE";
    z += "                            \xFE";
    z += "                            If Trim(Oc) <> '' Then Ocpgm[-1] = Oc; Oc = \"\"\xFE";
    z += "                            Call Reseti(3)\xFE";
    z += "                            Holdpgm = Ocpgm; Ocpgm = []; Holdhaslbl = Haslbl; Haslbl = 0\xFE";
    z += "                            Call states(1, \"\")\xFE";
    z += "                            \xFE";
    z += "                            If Trim(Oc) <> '' Then Ocpgm[-1] = Oc; Oc = \"\"\xFE";
    z += "                            Caseblock = Join(Ocpgm, Am); Caselbls = Haslbl; Haslbl += Holdhaslbl; Ocpgm = Holdpgm\xFE";
    z += "                            Call Reseti(-6)\xFE";
    z += "                            \xFE";
    z += "                            If Caselbls Then\xFE";
    z += "                                Tlbl = \"_outOfLineCaseBlock_\":Nxtlbl; Nxtlbl = Nxtlbl + 1\xFE";
    z += "                                Oc<-1> = \"\"\xFE";
    z += "                                Oc<-1> = Space(Indent+6):'gotoLabel = \"':Tlbl:'\"; continue atgoto;':Am:Am:Space(Indent)\xFE";
    z += "                      \xFE";
    z += "                                Caseblock = Change(Caseblock, Chr(2):'break' :Chr(2), '{ gotoLabel = \"':Breaklbl:'\"; continue atgoto }')\xFE";
    z += "                                Caseblock<-1> = 'gotoLabel = \"':Breaklbl:'\"; continue atgoto; '\xFE";
    z += "                                Postpgm<-1> = Am:Space(24):'case \"':Tlbl:'\": ':Am:Caseblock\xFE";
    z += "                            Else\xFE";
    z += "                                If Tkno <> C_end Then Caseblock<-1> = Space(Indent):'break; ':Am\xFE";
    z += "                                If Trim(Caseblock) <> '' Then Ocpgm[-1] = Caseblock\xFE";
    z += "                            End If\xFE";
    z += "                        Repeat\xFE";
    z += "                        Oc<-1> = Space(Indent-3):'} '\xFE";
    z += "                        \xFE";
    z += "                        Oc = Join(Ocpgm, Am()):Oc; Ocpgm = HoldOCPGM; HoldOCPGM = Null\xFE";
    z += "                        \xFE";
    z += "                        If Instr(Oc, Chr(2):'break':Chr(2)) Then\xFE";
    z += "                            Ocpgm[-1] = Space(Indent):'var dblBreak':Sellbl:' = false;'\xFE";
    z += "                            Oc = Change(Oc, \"; \":Chr(2):'break':Chr(2), '; dblBreak':Sellbl:' = true; break')\xFE";
    z += "                            Oc = Change(Oc, Chr(2):'break':Chr(2), '{ dblBreak':Sellbl:' = true; break }')\xFE";
    z += "                            Oc<-1> = Space(Indent):'if (dblBreak':Sellbl:') ':Chr(2):'break':Chr(2):'; '\xFE";
    z += "                        End If\xFE";
    z += "                        \xFE";
    z += "                        If Postpgm Then\xFE";
    z += "                            Oc<-1> = \"\"\xFE";
    z += "                            Oc<-1> = Space(Indent):'gotoLabel = \"':Breaklbl:'\"; continue atgoto;':Am\xFE";
    z += "                            Oc<-1> = Postpgm\xFE";
    z += "                            Oc<-1> = \"\"\xFE";
    z += "                            Call Deflbl(Breaklbl, 0)\xFE";
    z += "                        End If\xFE";
    z += "                        \xFE";
    z += "                        If Braces Then\xFE";
    z += "                            If Tkno = C_rbrace Then Call Tcv(False) Else Call Err('} expected')\xFE";
    z += "                        Else\xFE";
    z += "                            If Tkno = C_end Then Call Tcv(False)\xFE";
    z += "                            If Tkstr = \"SELECT\" Or Tkstr = \"CASE\" Then Call Tcv(False) Else Call Err('END SELECT expected')\xFE";
    z += "                        End If\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"SQLSELECT\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Aexpr = Expr(Type_estr,1,C_to)\xFE";
    z += "                        Call Typestr(Type_dc, Aexpr)\xFE";
    z += "                        If Tkno = C_to Then\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            Bexpr = parsevar(1, 0, '', 1)\xFE";
    z += "                            If Tkno = C_lparen Or Tkno = C_lbrack Or Tkno = mObjectDelemeter Then Call Err(\"Invalid reference variable. Too complicated\")\xFE";
    z += "                        Else\xFE";
    z += "                            Bexpr = {}\xFE";
    z += "                            Bexpr.SYM_C = 'odbActiveSelectList'\xFE";
    z += "                        End If\xFE";
    z += "                        hasPromises[-1] = \"Uses SQLSELECT\"\xFE";
    z += "                        Call Uses(Bexpr)\xFE";
    z += "                        Aexpr.SYM_C = 'await asyncDNOSqlSelect(':Aexpr.SYM_C:', _selectList => ':Bexpr.SYM_C:' = _selectList)'\xFE";
    z += "                        Aexpr.SYM_TYPE = Type_eBool\xFE";
    z += "                        Call Thenelse(Aexpr)\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"BREAK\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        If Tkno = C_on Then\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            OC := 'BreakOn(me); '\xFE";
    z += "                        ElseIf Tkno = C_off Then\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            OC := 'BreakOff(me); '\xFE";
    z += "                        Else\xFE";
    z += "                            OC := Chr(2):'break':Chr(2):'; '\xFE";
    z += "                        End\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"CALL\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        * Can't do this, fails CALL @NAME\xFE";
    z += "                        * IF TKNO = C_AT AND TKLINE[TKPOS,1] <> \"@\" THEN Call Tcv(False) ;* JUST IGNORE IT\xFE";
    z += "                        AExpr = DoCall(false)\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"CALLBYNAME\"\xFE";
    z += "                        If Tkline[Tkpos,1] <> \"@\" Then Tkno = C_at\xFE";
    z += "                        AExpr = DoCall(false)\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"CASE\" ; Null\xFE";
    z += "                    \xFE";
    z += "                    Case Tkstr = \"CHAIN\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Aexpr = Expr(Type_estr,1,'')\xFE";
    z += "                        Call Typestr(Type_dc, Aexpr)\xFE";
    z += "                        OC := 'return Chain(':Aexpr.SYM_C:'); '\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"CONVERT\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        *\xFE";
    z += "                        Aexpr = Expr(Type_estr, 1, C_to)\xFE";
    z += "                        If Tkno <> C_to Then Call Err('TO  expected') ; Break\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        *\xFE";
    z += "                        Cexpr = Expr(Type_estr, 1, C_in)\xFE";
    z += "                        If Tkno <> C_in Then Call Err('IN  expected') ; Break\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        *\xFE";
    z += "                        Bexpr = parsevar(0, 1, '', 1)\xFE";
    z += "                        Call Typestr(Type_dc, Aexpr)\xFE";
    z += "                        Call Typestr(Type_dc, Cexpr)\xFE";
    z += "                        *\xFE";
    z += "                        Dexpr = Clone(Bexpr)\xFE";
    z += "                        \xFE";
    z += "                        Call Typestr(Type_dc, Dexpr)\xFE";
    z += "                        Aexpr.SYM_C = 'Convert(':Aexpr.SYM_C:', ':Cexpr.SYM_C:', ':Dexpr.SYM_C:')'\xFE";
    z += "                        Call Store(Bexpr, Aexpr)\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"CONTINUE\" Or Tkstr = \"CYCLE\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        OC := Chr(2):'continue' :Chr(2):'; '\xFE";
    z += "\xFE";
    z += "                    Case Tkstr = \"DEBUGGER\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        OC := \"debugger; \"\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"ECHO\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        If Tkno = C_on Then\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            OC := 'activeProcess.At_Echo = 1; '\xFE";
    z += "                        ElseIf Tkno = C_off Then\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            OC := 'activeProcess.At_Echo = 0; '\xFE";
    z += "                        Else \xFE";
    z += "                            Call Err('ON/OFF expected')\xFE";
    z += "                        End If\xFE";
    z += "                        *\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"ELSE\" ; Null\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"ELSEIF\"\xFE";
    z += "                        Tkpos = Tkpos-2\xFE";
    z += "                        Tkno = C_else\xFE";
    z += "                        Tkstr = \"ELSE\"\xFE";
    z += "                        Otkstr = \"ELSE\"\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"END\" ; Null\xFE";
    z += "                    Case Tkstr = \"CATCH\" ; Null\xFE";
    z += "                    Case Tkstr = \"ENDIF\" ; Null\xFE";
    z += "                    Case Tkstr = \"}\" ; Null\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"JAVASCRIPT\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        If Tkstr = \"{\" Then\xFE";
    z += "                            Oc := PassThruJavascript()\xFE";
    z += "                        Else\xFE";
    z += "                            Call Err(\"{ javascript code } expected; Found \":Tkstr)\xFE";
    z += "                        End If\xFE";
    z += "                                                \xFE";
    z += "                    Case Tkstr = \"EXECUTE\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Aexpr = Expr(Type_estr, 1, C_comma:C_capturing)\xFE";
    z += "                        Call Typestr(Type_vstr, Aexpr)\xFE";
    z += "                        \xFE";
    z += "                        If Tkno = C_capturing Then\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            Dexpr = parsevar(1, 1, '', 1)\xFE";
    z += "                            OC := 'await asyncTclExecute(':Aexpr.SYM_C:', _capturedData => ':Dexpr.SYM_C:' = _capturedData)'\xFE";
    z += "                        Else\xFE";
    z += "                            OC := 'await asyncTclExecute(':Aexpr.SYM_C:'); '\xFE";
    z += "                        End If\xFE";
    z += "                        hasPromises[-1] = \"Uses EXECUTE\"\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"EXIT\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        If Tkstr = \"SUB\" Or Tkstr = \"SUBROUTINE\" Or Tkstr = \"FUNCTION\" Then\xFE";
    z += "                            If Left(Tkstr, 1) = \"F\" Then Aexpr = readsym(Funcattr.SYMNAME) Else Aexpr = { SYM_C: '' }\xFE";
    z += "                            \xFE";
    z += "                            if hasByRefParamters then\xFE";
    z += "                                Ocpgm[-1] = Space(Indent):'return exit(':Aexpr.SYM_C:'); '\xFE";
    z += "                            Else\xFE";
    z += "                                Ocpgm[-1] = Space(Indent):'return ':Aexpr.SYM_C:'; '\xFE";
    z += "                            End if\xFE";
    z += "\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            Break\xFE";
    z += "                            \xFE";
    z += "                        ElseIf Tkstr = \"FOR\" Or Tkstr = \"LOOP\" Or Tkstr = \"WHILE\" Or Tkstr = \"DO\" Then\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            OC := Chr(2):'break':Chr(2):'; '\xFE";
    z += "                        Else\xFE";
    z += "                            Call Err('FOR, LOOP, WHILE, DO EXPECTED')\xFE";
    z += "                        End If\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"FOR\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        \xFE";
    z += "                        If Tkno = C_lparen Then\xFE";
    z += "                            Call Tcv(False) ;' skip (\xFE";
    z += "                            \xFE";
    z += "                            ' startstatement\xFE";
    z += "                            Call states(3, C_semi)\xFE";
    z += "                            If Tkno = C_semi Then Call Tcv(False) Else Call Err(\"; expected\")\xFE";
    z += "                            \xFE";
    z += "                            ' Parse While\xFE";
    z += "                            If Tkno = C_semi Then\xFE";
    z += "                                Hascond = False\xFE";
    z += "                            Else\xFE";
    z += "                                Hascond = True\xFE";
    z += "                                Wtkno = C_while\xFE";
    z += "                                Cexpr = Expr(Type_eNum, 1, C_semi);\xFE";
    z += "                            End If\xFE";
    z += "                            \xFE";
    z += "                            If Tkno = C_semi Then Call Tcv(False) Else Call Err(\"; expected\")\xFE";
    z += "                            \xFE";
    z += "                            '    endstatement\xFE";
    z += "                            If Trim(Oc) <> '' Then Ocpgm[-1] = Oc; Oc = \"\"\xFE";
    z += "                            Call Reseti(3)\xFE";
    z += "                            Holdpgm = Ocpgm; Ocpgm = []; Holdhaslbl = Haslbl; Haslbl = 0\xFE";
    z += "                            Call states(3, C_rparen)\xFE";
    z += "                            If Trim(Oc) <> '' Then Ocpgm[-1] = Oc; Oc = \"\"\xFE";
    z += "                            Endblock = Join(Ocpgm, Am); Endlbls = Haslbl; Haslbl += Holdhaslbl; Ocpgm = Holdpgm\xFE";
    z += "                            Call Reseti(-3)\xFE";
    z += "                            \xFE";
    z += "\xFE";
    z += "                            If Tkno = C_rparen Then Call Tcv(False) Else Call Err(\") expected\")\xFE";
    z += "                            \xFE";
    z += "                            '    userstatements\xFE";
    z += "                            If Trim(Oc) <> '' Then Ocpgm[-1] = Oc; Oc = \"\"\xFE";
    z += "                            Call Reseti(3)\xFE";
    z += "                            Holdpgm = Ocpgm; Ocpgm = []; Holdhaslbl = Haslbl; Haslbl = 0\xFE";
    z += "                            \xFE";
    z += "                            If Tkno = C_lbrace Then\xFE";
    z += "                                Call Tcv(False)\xFE";
    z += "                                Call states(1, C_rbrace)\xFE";
    z += "                                If Tkno = C_rbrace Then Call Tcv(False) Else Call Err(\"} expected\")\xFE";
    z += "                            Else\xFE";
    z += "                                Call states(2, \"\")\xFE";
    z += "                            End If\xFE";
    z += "                            \xFE";
    z += "                            If Trim(Oc) <> '' Then Ocpgm[-1] = Oc; Oc = \"\"\xFE";
    z += "                            Doblock = Join(Ocpgm, Am); Dolbls = Haslbl; Haslbl += Holdhaslbl; Ocpgm = Holdpgm\xFE";
    z += "                            Call Reseti(-3)\xFE";
    z += "                            \xFE";
    z += "                            Doblock<-1> = Endblock\xFE";
    z += "                            Call GenLoop(Wtkno, Hascond, \"\", Cexpr, \"\", Doblock, False, Dolbls + Endlbls)\xFE";
    z += "                            \xFE";
    z += "                        Else\xFE";
    z += "                            Has_while = False\xFE";
    z += "                            Has_until = False\xFE";
    z += "                            Has_step = False\xFE";
    z += "                            \xFE";
    z += "                            IsForEach = Tkstr = \"EACH\"\xFE";
    z += "                            ForEachAssignment = \"\"\xFE";
    z += "                            \xFE";
    z += "                            // \"for each\"\xFE";
    z += "                            If IsForEach Then\xFE";
    z += "                                Call Tcv(False)\xFE";
    z += "                                \xFE";
    z += "                                // for Each *AEXPR*, xxx IN xxx\xFE";
    z += "                                Aexpr = parsevar(1, 0, C_in:C_comma, 1) // Storing, Matok, Lb, Showerrors\xFE";
    z += "                                \xFE";
    z += "                                If Aexpr.SYM_INDEX1#'' Or Aexpr.SYM_INDEX2#'' Or Aexpr.SYM_ATRNO Then\xFE";
    z += "                                    Call Err('For variable must not be an array')\xFE";
    z += "                                End\xFE";
    z += "                                \xFE";
    z += "                                hasForEachIndex = False\xFE";
    z += "                            \xFE";
    z += "                                // for each xxx, Eexpr in xxx\xFE";
    z += "                                If Tkno = C_comma Then\xFE";
    z += "                                    Call Tcv(False)\xFE";
    z += "                                    // FOR EACH xxxx, *EEXPR_I* IN xxxx\xFE";
    z += "                                    Eexpr = parsevar(1, 0, C_in, 1)\xFE";
    z += "                                     hasForEachIndex = True\xFE";
    z += "                                Else\xFE";
    z += "                                    // make our own counting variable\xFE";
    z += "                                    Eexpr = Definesym(Aexpr.SYMNAME:\"_Idx\", true)\xFE";
    z += "                                    Eexpr.SYM_TYPE = Type_vnum\xFE";
    z += "                                    Eexpr.isAlreadyDefined = true\xFE";
    z += "                                    Call Writesym(Eexpr, Eexpr.SYMNAME)\xFE";
    z += "                                    Eexpr.varPrefixed = True\xFE";
    z += "                                End If\xFE";
    z += "                                \xFE";
    z += "                                If Tkno = C_in Then Call Tcv(False) Else Call Err(\"IN expected\")\xFE";
    z += "\xFE";
    z += "                                // for each x *IN* GEXPR ...\xFE";
    z += "                                Gexpr = Expr(Type_estr, 1, C_step:C_while:C_until)\xFE";
    z += "                             Else\xFE";
    z += "                                *\xFE";
    z += "                                //     FOR Eexpr = Bexpr TO Fexpr STEP Dexpr UNTIL Cexpr\xFE";
    z += "                                //        Aexpr = Gexpr[Eexpr]\xFE";
    z += "                                *\xFE";
    z += "                                Eexpr = parsevar(1, 0, C_equal, 1)\xFE";
    z += "                                If Eexpr.SYM_INDEX1#'' Or Eexpr.SYM_INDEX2#'' Or Eexpr.SYM_ATRNO Then\xFE";
    z += "                                    Call Err('For variable must not be an array')\xFE";
    z += "                                End\xFE";
    z += "                                If Tkno <> C_equal Then Call Err('= expected') ; Break\xFE";
    z += "                                *\xFE";
    z += "                                * FOR xxx = (BEXPR) To xxx\xFE";
    z += "                                *\xFE";
    z += "                                Call Tcv(False)\xFE";
    z += "                                Bexpr = Expr(Type_eNum, 1, C_to); Call Makenum(Type_vnum, Bexpr)\xFE";
    z += "                                *\xFE";
    z += "                                If Tkno <> C_to Then Call Err('TO expected') ; Break\xFE";
    z += "                                Call Tcv(False)\xFE";
    z += "                                *\xFE";
    z += "                                * FOR xxx = xx TO (FEXPR)\xFE";
    z += "                                *\xFE";
    z += "                                Iexpr = Expr(Type_eNum, 1, C_step:C_while:C_until); Call Makenum(Type_vnum, Iexpr)\xFE";
    z += "                                \xFE";
    z += "                                // If this is a simple constant, no need to copy \xFE";
    z += "                                if Iexpr.SYM_TYPE = Type_cnum Then\xFE";
    z += "                                    ForEachEndExpr = Iexpr.SYM_C\xFE";
    z += "                                Else\xFE";
    z += "                                    ForEachEndExpr = \"_ForEndI_\":Nxtlbl; Nxtlbl = Nxtlbl + 1\xFE";
    z += "                                    Fexpr = Definesym(ForEachEndExpr, true)\xFE";
    z += "                                    Fexpr.SYM_C = ForEachEndExpr\xFE";
    z += "                                    Fexpr.SYM_TYPES = Symtypes_stored\xFE";
    z += "                                    Fexpr.isAlreadyDefined = true\xFE";
    z += "                                    Call Writesym(Fexpr, ForEachEndExpr)\xFE";
    z += "                                    oc := 'var '\xFE";
    z += "                                    Call Store(Fexpr, Iexpr)\xFE";
    z += "                                End If\xFE";
    z += "                                *\xFE";
    z += "                                * FOR xxx = xxx TO xxx STEP (DEXPR)\xFE";
    z += "                                *\xFE";
    z += "                                Has_step = (Tkno = C_step)\xFE";
    z += "                                If Has_step Then\xFE";
    z += "                                    Call Tcv(False)\xFE";
    z += "                                    Dexpr = Expr(Type_eNum, 1, C_while:C_until)\xFE";
    z += "                                    Call Makenum(Type_vnum, Dexpr)\xFE";
    z += "                                End If\xFE";
    z += "                                *\xFE";
    z += "                                * FOR EEXPR = BEXPR TO FEXPR STEP DEXPR WHILE CEXPR\xFE";
    z += "                                *\xFE";
    z += "                                Has_while = (Tkno = C_while)\xFE";
    z += "                                Has_until = (Tkno = C_until)\xFE";
    z += "                                If Has_while Or Has_until Then\xFE";
    z += "                                    Call Tcv(False)\xFE";
    z += "                                    Cexpr = Expr(Type_eNum, 1, ''); \xFE";
    z += "                                    Call Makebool(Cexpr)\xFE";
    z += "                                End If\xFE";
    z += "                            End If\xFE";
    z += "                            \xFE";
    z += "                            *\xFE";
    z += "                            * FORBLOCK\xFE";
    z += "                            *\xFE";
    z += "                            If Trim(Oc) <> '' Then Ocpgm[-1] = Oc\xFE";
    z += "                            Holdpgm = Ocpgm; Oc = Space(Indent + 3); Ocpgm = []; Holdhaslbl = Haslbl; Haslbl = 0\xFE";
    z += "                            Call ResetI(3)\xFE";
    z += "                            Call states(4, C_next)\xFE";
    z += "                            Call ResetI(-3)\xFE";
    z += "                            \xFE";
    z += "                            If Trim(Oc) <> '' Then Ocpgm[-1] = Oc; Oc = \"\"\xFE";
    z += "                            Forblock = Join(Ocpgm, Am); Forlbls = Haslbl; Haslbl += Holdhaslbl; Ocpgm = Holdpgm; Oc = Space(Indent)\xFE";
    z += "\xFE";
    z += "                            If Tkno <> C_next Then Call Err('NEXT expected') Else Call Tcv(False)\xFE";
    z += "                            \xFE";
    z += "                            If Index(La, Tkno, 1) = 0 Then\xFE";
    z += "                                Hexpr = parsevar(0, 0, '', 1)\xFE";
    z += "                                If Hexpr.SYM_C # Eexpr.SYM_C Then Call Warning('Warning: Mismatching for variable')\xFE";
    z += "                            End\xFE";
    z += "                            \xFE";
    z += "                            If IsForEach Then\xFE";
    z += "                                useCounter = false\xFE";
    z += "                                \xFE";
    z += "                                if hasForEachIndex Then\xFE";
    z += "                                    if InStr(ForBlock, \" \":Eexpr.SYM_C:\" = \") then useCounter = true\xFE";
    z += "                                    if InStr(ForBlock, \" \":Eexpr.SYM_C:\" += \") then useCounter = true\xFE";
    z += "                                    if InStr(ForBlock, \" \":Eexpr.SYM_C:\" -= \") then useCounter = true\xFE";
    z += "                                    if InStr(ForBlock, \" \":Eexpr.SYM_C:\"++\") then useCounter = true\xFE";
    z += "                                    if InStr(ForBlock, \" \":Eexpr.SYM_C:\"--\") then useCounter = true\xFE";
    z += "                                end if\xFE";
    z += "                            \xFE";
    z += "                                Bexpr = {}\xFE";
    z += "                                Bexpr.SYM_C = \"LBound(\":Gexpr.SYM_C:\")\"\xFE";
    z += "                                Bexpr.SYM_TYPE = Type_eNum\xFE";
    z += "                                \xFE";
    z += "                                if Forlbls Or useCounter Then\xFE";
    z += "                                    // for each aexpr, Eexpr in Gexpr    -> becomes\xFE";
    z += "                                    //\xFE";
    z += "                                    //     fexpr = UBound(GExpr) - unless GExpr is a CStr\xFE";
    z += "                                    //     FOR Eexpr = LBound(GExpr) TO Fexpr STEP Dexpr UNTIL Cexpr\xFE";
    z += "                                    //        Aexpr = Gexpr[Eexpr]\xFE";
    z += "                                    \xFE";
    z += "    \xFE";
    z += "                                    // Make upper bound Fexpr\xFE";
    z += "                                    If Gexpr.SYM_TYPE = Type_estr Or Gexpr.SYM_TYPE = Type_cstr Then\xFE";
    z += "                                        fexpr = {}\xFE";
    z += "                                        ForEachEndExpr = \"UBound(\":Gexpr.SYM_C:\")\"\xFE";
    z += "                                        fexpr.SYM_C = ForEachEndExpr\xFE";
    z += "                                        fexpr.SYM_TYPE = Type_eNum\xFE";
    z += "                                        \xFE";
    z += "                                    Else\xFE";
    z += "                                        // Create a fixed UBound( variable )\xFE";
    z += "                                        ForEachEndExpr = Aexpr.SYMNAME:\"_LastI\":Nxtlbl; Nxtlbl = Nxtlbl + 1\xFE";
    z += "                                        Fexpr = Definesym(ForEachEndExpr, true) ;* Create A New Fexpr = {}\xFE";
    z += "                                        Fexpr.SYM_C = ForEachEndExpr\xFE";
    z += "                                        Fexpr.SYM_TYPES = Symtypes_stored\xFE";
    z += "                                        Fexpr.isAlreadyDefined = true\xFE";
    z += "                                        \xFE";
    z += "                                        Iexpr = {}\xFE";
    z += "                                        Iexpr.SYM_C = \"UBound(\":Gexpr.SYM_C:\")\"\xFE";
    z += "                                        Iexpr.SYM_TYPE = Type_eNum\xFE";
    z += "                                        Call Makenum(Type_vnum, Iexpr)\xFE";
    z += "                                        \xFE";
    z += "                                        Call Writesym(Fexpr, ForEachEndExpr)\xFE";
    z += "                                        \xFE";
    z += "                                        oc := 'var '\xFE";
    z += "                                        Call Store(Fexpr, Iexpr)\xFE";
    z += "                                    End If\xFE";
    z += "                                    \xFE";
    z += "                                    ForEachAssignment = Space(Indent + 3)\xFE";
    z += "                                    if Aexpr.varPrefixed Then ForEachAssignment := 'var '\xFE";
    z += "                                    ForEachAssignment := Aexpr.SYM_C\xFE";
    z += "                                    ForEachAssignment := \" = Extract(\":Gexpr.SYM_C:\", \":Eexpr.SYM_C:\", 0, 0); \"\xFE";
    z += "                                    ForEachAssignment := Am\xFE";
    z += "                                    Forblock = ForEachAssignment:Forblock\xFE";
    z += "                                    isForEach = False\xFE";
    z += "                                End If    \xFE";
    z += "                            End If    \xFE";
    z += "                \xFE";
    z += "                            * PUT IT ALL TOGETHER\xFE";
    z += "                            If isForEach Then\xFE";
    z += "                                * FOR EACH aexpr {, Eexpr} In Gexpr   - hasForEachIndex means Eexpr is valid\xFE";
    z += "                                if hasForEachIndex Then\xFE";
    z += "                                    if Eexpr.varPrefixed Then Oc := 'var '\xFE";
    z += "                                    Bexpr.SYM_C := \"-1\"\xFE";
    z += "                                    Call Store(Eexpr, Bexpr) \xFE";
    z += "                                    OC<-1> = Space(Indent)\xFE";
    z += "                                end if\xFE";
    z += "                                \xFE";
    z += "                                OC := 'for ('\xFE";
    z += "                                if aexpr.varPrefixed Then Oc := 'var '\xFE";
    z += "                                OC := aexpr.SYM_C:' of iterateOver(':Gexpr.SYM_C:')) '\xFE";
    z += "                                if hasForEachIndex Then\xFE";
    z += "                                    ForBlock = Space(Indent + 3):Eexpr.SYM_C:\"++; \":Am:ForBlock\xFE";
    z += "                                end if\xFE";
    z += "                                \xFE";
    z += "                                Forblock = Change(Forblock, Chr(2):'break' :Chr(2), \"break\")\xFE";
    z += "                                Forblock = Change(Forblock, Chr(2):'continue' :Chr(2), \"continue\")\xFE";
    z += "                                \xFE";
    z += "                                Oc := '{':Am:Forblock:Am:Space(Indent):\"} \"\xFE";
    z += "                            \xFE";
    z += "                            Else If Forlbls Then\xFE";
    z += "                                * FOR Eexpr = Bexpt TO Fexpt STEP Dexpt UNTIL Cexpr\xFE";
    z += "                                *\xFE";
    z += "                                * STORE\xFE";
    z += "                                * CYCLELBL:\xFE";
    z += "                                *    PRECOND\xFE";
    z += "                                *    IF COND THEN GOTO EXITLBL\xFE";
    z += "                                *    FORBLOCK\xFE";
    z += "                                * CONTINUELBL:\xFE";
    z += "                                *    INCREMENT\xFE";
    z += "                                *    GOTO CYCLELBL\xFE";
    z += "                                * EXITLBL:\xFE";
    z += "                                *   \xFE";
    z += "                                * FOR EEXPR = BEXPR TO FEXPR STEP DEXPR WHILE CEXPR\xFE";
    z += "                                \xFE";
    z += "                                Cyclelbl = \"_topOfFor_\":Nxtlbl\xFE";
    z += "                                Exitlbl = \"_exitFor_\":Nxtlbl\xFE";
    z += "                                Continuelbl = \"_continueFor_\":Nxtlbl; Nxtlbl = Nxtlbl + 1\xFE";
    z += "                                \xFE";
    z += "                                if Eexpr.varPrefixed Then Oc := 'var '\xFE";
    z += "                                Call Store(Eexpr, Bexpr) \xFE";
    z += "                                \xFE";
    z += "                                Call Deflbl(Cyclelbl, 0)\xFE";
    z += "                                \xFE";
    z += "                                If Has_while Or Has_until Then Extra = \"(\" Else Extra = \"\"\xFE";
    z += "                                \xFE";
    z += "                                If Has_step Then\xFE";
    z += "                                    If Num(Dexpr.SYM_C) Then\xFE";
    z += "                                        If Dexpr.SYM_C < 0 Then\xFE";
    z += "                                            OC := \"if (\":Extra:Eexpr.SYM_C:'>=':ForEachEndExpr\xFE";
    z += "                                        Else\xFE";
    z += "                                            OC := \"if (\":Extra:Eexpr.SYM_C:'<=':ForEachEndExpr\xFE";
    z += "                                        End If\xFE";
    z += "                                    Else\xFE";
    z += "                                        * DON'T KNOW DIRECTION\xFE";
    z += "                                        OC := 'if ((':Extra:Dexpr.SYM_C:'>=0)?(':Eexpr.SYM_C:'<=':ForEachEndExpr:'):(':Eexpr.SYM_C:'>=':ForEachEndExpr:')'\xFE";
    z += "                                    End If\xFE";
    z += "                                Else\xFE";
    z += "                                    OC := 'if (':Extra:Eexpr.SYM_C:'<=':ForEachEndExpr\xFE";
    z += "                                End If\xFE";
    z += "                                \xFE";
    z += "                                If Has_while Then\xFE";
    z += "                                    OC := ') && ':Cexpr.SYM_C\xFE";
    z += "                                ElseIf Has_until Then\xFE";
    z += "                                    OC := ') && Not(':Cexpr.SYM_C:')'\xFE";
    z += "                                End\xFE";
    z += "                                \xFE";
    z += "                                OC := ') null; else { gotoLabel = \"':Exitlbl:'\"; continue atgoto } '\xFE";
    z += "                                \xFE";
    z += "                                Forblock = Change(Forblock, Chr(2):'break' :Chr(2), '{ gotoLabel = \"':Exitlbl:'\"; continue atgoto }')\xFE";
    z += "                                Forblock = Change(Forblock, Chr(2):'continue' :Chr(2), '{ gotoLabel = \"':Continuelbl:'\"; continue atgoto }')\xFE";
    z += "                                Forblock = Change(Forblock, Am:\"   \", Am); Forblock = Change(Forblock,'case \"_', Space(3):'case \"_')\xFE";
    z += "                                Oc<-1> = Forblock\xFE";
    z += "                                *\xFE";
    z += "                                Call Deflbl(Continuelbl, 0)\xFE";
    z += "                                *\xFE";
    z += "                                If Has_step = 0 Then\xFE";
    z += "                                    Dexpr = {}\xFE";
    z += "                                    Dexpr.SYM_C = '+1'\xFE";
    z += "                                    Dexpr.SYM_TYPE = Type_cnum\xFE";
    z += "                                End If\xFE";
    z += "                                \xFE";
    z += "                                If Index('+-',Dexpr.SYM_C[1,1],1) = 0 Then Dexpr.SYM_C=\"+\":Dexpr.SYM_C\xFE";
    z += "                                Dexpr.SYM_C = Eexpr.SYM_C:Dexpr.SYM_C\xFE";
    z += "                                Call Store(Eexpr, Dexpr)\xFE";
    z += "                                *\xFE";
    z += "                                Oc<-1> = Space(Indent):'gotoLabel = \"':Cyclelbl:'\"; continue atgoto; '\xFE";
    z += "                                *\xFE";
    z += "                                Call Deflbl(Exitlbl, 0)\xFE";
    z += "\xFE";
    z += "                            Else\xFE";
    z += "                            \xFE";
    z += "                                * FOR EEXPR = BEXPR TO FEXPR STEP DEXPR WHILE CEXPR\xFE";
    z += "                                OC := 'for ('\xFE";
    z += "                                \xFE";
    z += "                                if Eexpr.varPrefixed Then Oc := 'var '\xFE";
    z += "                                Call Store(Eexpr, Bexpr) ;* Should Already End With \";\"\xFE";
    z += "                                *\xFE";
    z += "                                If Has_while Or Has_until Then Extra = \"(\" Else Extra = \"\"\xFE";
    z += "                                If Has_step Then\xFE";
    z += "                                    \xFE";
    z += "                                    If Num(Dexpr.SYM_C) Then\xFE";
    z += "                                        If Dexpr.SYM_C < 0 Then\xFE";
    z += "                                            OC := Extra:Eexpr.SYM_C:'>=':ForEachEndExpr\xFE";
    z += "                                        Else\xFE";
    z += "                                            OC := Extra:Eexpr.SYM_C:'<=':ForEachEndExpr\xFE";
    z += "                                        End If\xFE";
    z += "                                    Else\xFE";
    z += "                                        * DON'T KNOW DIRECTION\xFE";
    z += "                                        OC := '(':Extra:Dexpr.SYM_C:'>=0)?(':Eexpr.SYM_C:'<=':ForEachEndExpr:'):(':Eexpr.SYM_C:'>=':ForEachEndExpr:')'\xFE";
    z += "                                    End If\xFE";
    z += "                                Else\xFE";
    z += "                                    OC := Extra:Eexpr.SYM_C:'<=':ForEachEndExpr\xFE";
    z += "                                End If\xFE";
    z += "                                *\xFE";
    z += "                                * WHILE/UNTIL CEXPR\xFE";
    z += "                                *\xFE";
    z += "                                \xFE";
    z += "                                If Has_while Then\xFE";
    z += "                                    OC := ') && ':Cexpr.SYM_C\xFE";
    z += "                                ElseIf Has_until Then\xFE";
    z += "                                    OC := ') && Not(':Cexpr.SYM_C:')'\xFE";
    z += "                                End\xFE";
    z += "                                *\xFE";
    z += "                                OC := '; '\xFE";
    z += "                                *\xFE";
    z += "                                If Has_step = 0 Then\xFE";
    z += "                                    Dexpr = {}\xFE";
    z += "                                    Dexpr.SYM_C = '+1'\xFE";
    z += "                                    Dexpr.SYM_TYPE = Type_cnum\xFE";
    z += "                                Else\xFE";
    z += "                                    \xFE";
    z += "                                End If\xFE";
    z += "                                If Index('+-',Dexpr.SYM_C[1,1],1) = 0 Then Dexpr.SYM_C=\"+\":Dexpr.SYM_C\xFE";
    z += "                                Dexpr.SYM_C = Eexpr.SYM_C:Dexpr.SYM_C\xFE";
    z += "                                Call Store(Eexpr, Dexpr)\xFE";
    z += "                                *\xFE";
    z += "                                * REMOVE LAST ';'\xFE";
    z += "                                Ocl = Len(Oc)\xFE";
    z += "                                Loop While Oc[Ocl,1] = ';' Or Oc[Ocl,1] = ' ' Do Ocl=Ocl-1 Repeat\xFE";
    z += "                                *\xFE";
    z += "                                Forblock = Change(Forblock, Chr(2):'break' :Chr(2), \"break\")\xFE";
    z += "                                Forblock = Change(Forblock, Chr(2):'continue' :Chr(2), \"continue\")\xFE";
    z += "                                Oc = Oc[1,Ocl]:') {':Am:Forblock:Am:Space(Indent):\"} \"\xFE";
    z += "                            End\xFE";
    z += "                        End\xFE";
    z += "\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"GO\" Or Tkstr = \"GOTO\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        If Tkno = C_to Then Call Tcv(False)\xFE";
    z += "                        Tkstr = makesubname(Tkstr)\xFE";
    z += "                        Jmpadr = Tkstr\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        If Tkno = C_colon Then Call Tcv(False)\xFE";
    z += "                        OC := 'gotoLabel = \"':Jmpadr:'\"; continue atgoto; '\xFE";
    z += "                        Call Uselbl(Jmpadr)\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"GOSUB\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Tkstr = makesubname(Tkstr)\xFE";
    z += "                        Jmpadr = Tkstr\xFE";
    z += "                        Call Uselbl(Jmpadr)\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        If Tkno = C_colon Then Call Tcv(False)\xFE";
    z += "                        Hadgosub = 1\xFE";
    z += "                        Tlbl = \"_afterGosub_\":Nxtlbl; Nxtlbl = Nxtlbl + 1\xFE";
    z += "                        OC := 'Gosub(me, \"':Jmpadr:'\", \"':Tlbl:'\"); continue atgoto; '\xFE";
    z += "                        Call Deflbl(Tlbl, 0)\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"IF\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Aexpr = Expr(Type_estr, 1, C_then:C_else:C_lbrace)\xFE";
    z += "                        Call Thenelse(Aexpr)\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"INCLUDE\" Or Tkstr = \"$INCLUDE\" Or Tkstr = \"INSERT\" Or Tkstr = \"$INSERT\"\xFE";
    z += "                        If Trim(Oc) # \"\" Then Ocpgm[-1] = Oc ; Oc = \"\"\xFE";
    z += "                        Sent = ''\xFE";
    z += "                        Loop\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            Sent = Sent:Space(Spaces):Tkstr\xFE";
    z += "                        Until Index(C_am:C_sm:C_semi:C_bang:C_dblSlash,Tkno,1) Do Repeat\xFE";
    z += "                        *\xFE";
    z += "                        Sent = Trim(Sent)\xFE";
    z += "                        Fname = Field(Sent,' ',1)\xFE";
    z += "                        Iname = Field(Sent,' ',2)\xFE";
    z += "                        If Fname = 'DICT' Or Fname = 'DATA' Then\xFE";
    z += "                            Fname = 'DICT ':Iname\xFE";
    z += "                            Iname = Field(Sent,' ',3)\xFE";
    z += "                        End\xFE";
    z += "                        If Iname = '' Then\xFE";
    z += "                            Iname = Fname\xFE";
    z += "                            Fname = Cur_fname\xFE";
    z += "                        End\xFE";
    z += "                        *\xFE";
    z += "                        Call Incfile(Fname, Iname)\xFE";
    z += "            \xFE";
    z += "                    Case Tkstr = \"I_ATTACHDB\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Aexpr = Expr(Type_estr, 1, C_then:C_else:C_lbrace)\xFE";
    z += "                        \xFE";
    z += "                        hasPromises[-1] = \"Uses I_ATTACHDB\"\xFE";
    z += "                        Aexpr.SYM_C = 'await asyncAttach(':Aexpr.SYM_C:')'\xFE";
    z += "                        Aexpr.SYM_TYPE = Type_eBool\xFE";
    z += "                        Call Thenelse(Aexpr)\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"ATTACHDB\"\xFE";
    z += "                        hasPromises[-1] = \"Uses ATTACHDB\"\xFE";
    z += "                        \xFE";
    z += "                        Call Tcv(False) ;* Skip ATTACHDB\xFE";
    z += "                        \xFE";
    z += "                        ;* == Remove Everything Up To Command, So That What Remains We Be Parameterlist\xFE";
    z += "                        Tkline = Mid(Tkline, Tkstartpos)\xFE";
    z += "                        Tkpos = 1; Tkno = ''; Call Tcv(False)\xFE";
    z += "                        If Trim(Oc) # \"\" Then Ocpgm[-1] = Oc; Oc = \"\"\xFE";
    z += "                        \xFE";
    z += "                        \xFE";
    z += "                        ;* == Remove Everything Up To Command, So That What Remains We Be Parameterlist\xFE";
    z += "                        Tkline = Mid(Tkline, Tkstartpos)\xFE";
    z += "                        Tkpos = 1; Tkno = ''; Call Tcv(False)\xFE";
    z += "                        If Trim(Oc) # \"\" Then Ocpgm[-1] = Oc; Oc = \"\"\xFE";
    z += "                        \xFE";
    z += "                        Aexpr = Expr(Type_vstr, 2, C_then:C_else:C_lbrace:C_comma)     \xFE";
    z += "                        \xFE";
    z += "                        ;* ====================\xFE";
    z += "                        Hasthenelse = Tkno = C_then Or Tkno = C_else Or Tkno = C_lbrace\xFE";
    z += "                        Nextcmd = Mid(Tkline, Tkstartpos)\xFE";
    z += "                        Params = Mid(Tkline, 1, Tkstartpos-1)\xFE";
    z += "                        \xFE";
    z += "                        ;* Build Subsitution\xFE";
    z += "                        Tkline = \"IF @JSB_ODB.ATTACHDB(\":Params:\") \"\xFE";
    z += "                        If Hasthenelse Then Tkline = Tkline:Nextcmd Else Tkline = Tkline:\" ELSE STOP @ERRORS\"\xFE";
    z += "                        \xFE";
    z += "                        ;* Re-Parse\xFE";
    z += "                        Oc = \"\"; Tkpos = 1; Tkno = ''; Call Tcv(False)\xFE";
    z += "                        \xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Aexpr = Expr(Type_estr, 1, C_then:C_else:C_lbrace)\xFE";
    z += "                        Call Thenelse(Aexpr) \xFE";
    z += "                                                \xFE";
    z += "                    Case Tkstr = \"INPUT\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        \xFE";
    z += "                        // Handle PRINT portion of INPUT\xFE";
    z += "                        If Tkno = C_at Then\xFE";
    z += "                            Cexpr = Expr(Type_estr, 1, C_colon)\xFE";
    z += "                            Call Typestr(Type_vstr, Cexpr)\xFE";
    z += "                            If Cexpr.SYM_C = Type_cstr Then\xFE";
    z += "                                P = 1\xFE";
    z += "                                Pstr = Cexpr.SYM_C[2,Len(Cexpr.SYM_C)-2]\xFE";
    z += "                                Loop\xFE";
    z += "                                    I = Index(Pstr,'%',P)\xFE";
    z += "                                While I Do\xFE";
    z += "                                    Pstr = Pstr[1,I-1]:'\\\\':Pstr[I,99999]\xFE";
    z += "                                    P = P + 1\xFE";
    z += "                                Repeat\xFE";
    z += "                                OC := 'printf(':Pstr:'); '\xFE";
    z += "                            Else\xFE";
    z += "                                OC := 'printf(\"%s\",':Cexpr.SYM_C:'); '\xFE";
    z += "                            End\xFE";
    z += "                            If Tkno=C_colon Then Call Tcv(False) Else Call Err(': expected')\xFE";
    z += "                        End\xFE";
    z += "                        *\xFE";
    z += "                        * Next handle the Input Variable (Bexpr)\xFE";
    z += "                        *\xFE";
    z += "                        If Tkno < C_ident Then Call Err('Identifier expected') ; Break\xFE";
    z += "                        Bexpr = parsevar(1, 1, C_comma:C_under:C_colon:C_pound, 1)\xFE";
    z += "                        \xFE";
    z += "                        *\xFE";
    z += "                        * next check for options\xFE";
    z += "                        *\xFE";
    z += "                        Crlf = 1; Defaulttext = 0\xFE";
    z += "                        \xFE";
    z += "                        Loop While Instr(C_comma:C_under:C_colon:C_pound, Tkno) Do\xFE";
    z += "                            If Tkno = C_comma Then Call Tcv(False)\xFE";
    z += "                            If Tkno = C_colon Then Crlf = 0; Call Tcv(False)\xFE";
    z += "                            If Tkno = C_under Then Defaulttext = 1; Call Tcv(False)\xFE";
    z += "                            If Tkno = C_pound Then Defaulttext = 1; Call Tcv(False)\xFE";
    z += "                        Repeat\xFE";
    z += "                        \xFE";
    z += "                        Crlf = Tkno <> C_colon\xFE";
    z += "                        If Not(Crlf) Then Call Tcv(False)\xFE";
    z += "\xFE";
    z += "                        // Create INPUTBOX and block\xFE";
    z += "                        If Defaulttext Then DefaultText = Bexpr.SYM_C Else DefaultText = ''\xFE";
    z += "                        \xFE";
    z += "                        Dexpr = {}\xFE";
    z += "                        Dexpr.SYM_TYPE = Type_estr\xFE";
    z += "                        Dexpr.SYM_C = \"await asyncInput('\":Replace(DefaultText, \"'\", \"\\'\"):\"')\"\xFE";
    z += "                        Call Store(Bexpr, Dexpr)\xFE";
    z += "                        \xFE";
    z += "                        If Crlf Then\xFE";
    z += "                            OC := \"if (activeProcess.At_Echo) Println(\":Bexpr.SYM_C:\"); FlushHTML(); \"\xFE";
    z += "                        Else\xFE";
    z += "                            OC := \"if (activeProcess.At_Echo) Print(\":Bexpr.SYM_C:\"); FlushHTML(); \"\xFE";
    z += "                        End If\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"LOCATE\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        *\xFE";
    z += "                        * Set defaults\xFE";
    z += "                        *\xFE";
    z += "                        Bexpr = {}\xFE";
    z += "                        Bexpr.SYM_TYPE = Type_cstr\xFE";
    z += "                        Bexpr.SYM_C = '\"\"'\xFE";
    z += "                        *\xFE";
    z += "                        Cexpr = {}\xFE";
    z += "                        Cexpr.SYM_TYPE = Type_cstr\xFE";
    z += "                        Cexpr.SYM_C = ''\xFE";
    z += "                        *\xFE";
    z += "                        Iexpr = {}\xFE";
    z += "                        If Type_eNum = Type_eNum Then\xFE";
    z += "                            Iexpr.SYM_TYPE = Type_cnum\xFE";
    z += "                            Iexpr.SYM_C  = '0'\xFE";
    z += "                        Else\xFE";
    z += "                            Iexpr.SYM_TYPE = Type_cnum\xFE";
    z += "                            Iexpr.SYM_C  = '0'\xFE";
    z += "                        End\xFE";
    z += "                        Eexpr = Clone(Iexpr)\xFE";
    z += "                        Aexpr = Clone(Iexpr)\xFE";
    z += "                        *\xFE";
    z += "                        If Tkno = C_lparen Then\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            *\xFE";
    z += "                            Fexpr = Expr(Type_estr, 1, C_comma:C_semi:C_rparen)\xFE";
    z += "                            Call Typestr(Type_dc, Fexpr)\xFE";
    z += "                            *\xFE";
    z += "                            If Tkno <> C_comma Then Call Err(', expected') ; Break\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            *\xFE";
    z += "                            Gexpr = Expr(Type_estr, 1, C_comma:C_semi:C_rparen)\xFE";
    z += "                            Call Typestr(Type_var, Gexpr)\xFE";
    z += "                            *\xFE";
    z += "                            If Tkno = C_comma Then\xFE";
    z += "                                Call Tcv(False)\xFE";
    z += "                                Iexpr = Expr(Type_eNum, 1, C_comma:C_semi:C_rparen)\xFE";
    z += "                                Call Typenum(Type_vnum, Iexpr)\xFE";
    z += "                            End\xFE";
    z += "                            *\xFE";
    z += "                            If Tkno = C_comma Then\xFE";
    z += "                                Call Tcv(False)\xFE";
    z += "                                Eexpr = Expr(Type_eNum, 1, C_comma:C_semi:C_rparen)\xFE";
    z += "                                Call Typenum(Type_vnum, Eexpr)\xFE";
    z += "                            End\xFE";
    z += "                            \xFE";
    z += "                            If Tkno = C_semi Or Tkno <> C_comma Then\xFE";
    z += "                                Call Tcv(False)\xFE";
    z += "                                Cexpr = parsevar(1, 0, C_semi:C_rparen, 1)\xFE";
    z += "                            End\xFE";
    z += "                            *\xFE";
    z += "                            If Tkno = C_semi Then\xFE";
    z += "                                Call Tcv(False)\xFE";
    z += "                                Bexpr = Expr(Type_eNum, 1, C_rparen)\xFE";
    z += "                                Call Typestr(Type_dc, Bexpr)\xFE";
    z += "                            End\xFE";
    z += "                            If Tkno <> C_rparen Then Call Err(') expected') ; Break\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                        Else\xFE";
    z += "                            Fexpr = Expr(Type_estr, 1, C_in)\xFE";
    z += "                            Call Typestr(Type_dc, Fexpr)\xFE";
    z += "                            *\xFE";
    z += "                            If Tkno <> C_in Then Call Err('IN expected') ; Break\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            *\xFE";
    z += "                            * GEXPR = parsevar(0, 0, C_LESS:C_USING:C_SETTING:C_BY:C_THEN:C_ELSE:C_LBRACE, 1)\xFE";
    z += "                            \xFE";
    z += "                            Gexpr = Expr(Type_estr, 2, C_less:C_using:C_setting:C_by:C_then:C_else:C_lbrace)\xFE";
    z += "                            \xFE";
    z += "                            Call Typestr(Type_var, Gexpr)\xFE";
    z += "                            *\xFE";
    z += "                            If Tkno = C_less Then\xFE";
    z += "                                Call Tcv(False)\xFE";
    z += "                                Iexpr = Expr(Type_eNum, 2, C_comma:C_great)\xFE";
    z += "                                Call Typenum(Type_vnum, Iexpr)\xFE";
    z += "                                If Tkno = C_comma Then\xFE";
    z += "                                    Call Tcv(False)\xFE";
    z += "                                    Eexpr = Expr(Type_eNum, 2, C_great)\xFE";
    z += "                                    Call Typenum(Type_vnum, Eexpr)\xFE";
    z += "                                End\xFE";
    z += "                                If Tkno <> C_great Then Call Err('> expected') Else Call Tcv(False)\xFE";
    z += "                            End\xFE";
    z += "                            *\xFE";
    z += "                            If Tkno = C_comma Then\xFE";
    z += "                                Call Tcv(False)\xFE";
    z += "                                Aexpr = Expr(Type_eNum, 2, C_using:C_by:C_setting:C_then:C_else:C_lbrace)\xFE";
    z += "                                Call Typenum(Type_vnum, Aexpr)\xFE";
    z += "                            End\xFE";
    z += "                            *\xFE";
    z += "                            Loop\xFE";
    z += "                                If Tkno = C_using Then\xFE";
    z += "                                    Call Tcv(False)\xFE";
    z += "                                    Hexpr = Expr(Type_estr, 1, C_using:C_by:C_setting:C_then:C_else:C_lbrace)\xFE";
    z += "                                    Call Err('USING clause ignored')\xFE";
    z += "                                End\xFE";
    z += "                                *\xFE";
    z += "                                If Tkno = C_by Then\xFE";
    z += "                                    Call Tcv(False)\xFE";
    z += "                                    Bexpr = Expr(Type_estr, 1, C_using:C_by:C_setting:C_then:C_else:C_lbrace)\xFE";
    z += "                                    Call Typestr(Type_dc, Bexpr)\xFE";
    z += "                                End\xFE";
    z += "                                *\xFE";
    z += "                                If Tkno = C_setting Then\xFE";
    z += "                                    Call Tcv(False)\xFE";
    z += "                                    Cexpr = parsevar(1, 0, C_using:C_by:C_setting:C_then:C_else:C_lbrace, 1)\xFE";
    z += "                                End\xFE";
    z += "                            While Instr(C_using:C_by:C_setting, Tkno) Do Repeat\xFE";
    z += "                        End\xFE";
    z += "                        *\xFE";
    z += "                        if Cexpr.SYM_C Then\xFE";
    z += "                            Fexpr.SYM_C = 'Locate(':Fexpr.SYM_C:', ':Gexpr.SYM_C:', ':Iexpr.SYM_C:', ':Eexpr.SYM_C:', ':Aexpr.SYM_C:', ':Bexpr.SYM_C:', position => ':Cexpr.SYM_C:' = position)'\xFE";
    z += "                        Else\xFE";
    z += "                            Fexpr.SYM_C = 'Locate(':Fexpr.SYM_C:', ':Gexpr.SYM_C:', ':Iexpr.SYM_C:', ':Eexpr.SYM_C:', ':Aexpr.SYM_C:', ':Bexpr.SYM_C:', position => { })'                        \xFE";
    z += "                        End If\xFE";
    z += "                        \xFE";
    z += "                        Fexpr.SYM_TYPE = Type_eBool\xFE";
    z += "                        Call Thenelse(Fexpr)\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"LET\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Call Assment\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"REMOVE\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Bexpr = parsevar(1, 1, C_comma, 1)\xFE";
    z += "                        If Tkno <> C_comma Then Call Err(\", EXPECTED\") Else Call Tcv(False)\xFE";
    z += "                        Aexpr = Expr(Type_vstr, 2, '')\xFE";
    z += "                        OC := \"delete \":Bexpr.SYM_C:\"[\":Aexpr.SYM_C:\"]\"\xFE";
    z += "                        \xFE";
    z += "                    Case TkStr = \"THROW\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Gexpr = Expr(Type_estr, 2, '')\xFE";
    z += "                        Call Typestr(Type_vstr, Gexpr)\xFE";
    z += "                        OC := 'throw ':Gexpr.SYM_C\xFE";
    z += "                        \xFE";
    z += "                    Case TkStr = \"TRY\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        OC := 'try {'\xFE";
    z += "                        Call Reseti(3)\xFE";
    z += "                        Call states(4, C_Catch:C_End)\xFE";
    z += "                        if right(OC, 3) = \"   \" Then OC = Left(Oc, Len(OC)-3)\xFE";
    z += "                        \xFE";
    z += "                        If Tkno = C_Catch Then \xFE";
    z += "                            Call Tcv(False) \xFE";
    z += "                            Cexpr = parsevar(1, 0, C_End, 1)\xFE";
    z += "                            OC := '} catch (':Cexpr.SYM_C:') { '\xFE";
    z += "                            Call states(4, C_End)\xFE";
    z += "                        Else\xFE";
    z += "                            OC := '} catch (Xerr) { '\xFE";
    z += "                        End If\xFE";
    z += "                        if right(OC, 3) = \"   \" Then OC = Left(Oc, Len(OC)-3)\xFE";
    z += "                        OC := '} '\xFE";
    z += "                        Call Reseti(-3)\xFE";
    z += "                        If Tkno = C_End Then Call Tcv(False)\xFE";
    z += "                        if Tkstr = \"TRY\" Then Call Tcv(False) Else Call Err('END TRY expected')\xFE";
    z += "                    \xFE";
    z += "                    Case Tkstr = \"DO\" Or Tkstr = \"LOOP\" Or Tkstr = \"WHILE\"\xFE";
    z += "                        Loopblock = \"\"\xFE";
    z += "                        Doblock = \"\"\xFE";
    z += "                        Looplbls = 0\xFE";
    z += "                        Dolbls = 0\xFE";
    z += "                        \xFE";
    z += "                        If Tkno = C_while Then\xFE";
    z += "                            ;* Vb6 While .. Wend\xFE";
    z += "                            If Index(La, C_while, 1) Then Break ;* Expecting While In Loop .. While\xFE";
    z += "                            * WHILE WHILECOND DOBLOCK WEND\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            Cexpr = Expr(Type_eNum, 1, C_do)\xFE";
    z += "                            Call Makebool(Cexpr)\xFE";
    z += "                            \xFE";
    z += "                            If Tkno = C_do Then Call Tcv(False)\xFE";
    z += "                            If Trim(Oc) <> '' Then Ocpgm[-1] = Oc; Oc = \"\"\xFE";
    z += "                            Call Reseti(3)\xFE";
    z += "                            Holdpgm = Ocpgm; Ocpgm = []; Holdhaslbl = Haslbl; Haslbl = 0\xFE";
    z += "                            Call states(4, C_repeat:C_loop)\xFE";
    z += "                            If Trim(Oc) <> '' Then Ocpgm[-1] = Oc; Oc = \"\"\xFE";
    z += "                            Doblock = Join(Ocpgm, Am); Looplbls += Haslbl; Dolbls = Haslbl; Haslbl += Holdhaslbl; Ocpgm = Holdpgm\xFE";
    z += "                            Call Reseti(-3)\xFE";
    z += "                            If Tkstr = \"WEND\" Then Call Tcv(False) Else Call Err(\"WEND EXPECTED\") ;* Repeat Is Extra\xFE";
    z += "                            Wtkno = C_while\xFE";
    z += "                            Hascond = 1\xFE";
    z += "                            \xFE";
    z += "                        ElseIf Tkstr = \"DO\" Then\xFE";
    z += "                            ;* Vb6 Style Do While ... Loop\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            Wtkno = Tkno\xFE";
    z += "                            Hascond = Wtkno = C_while Or Wtkno = C_until\xFE";
    z += "                            If Hascond Then\xFE";
    z += "                                * DO WHILE WHILECOND DOBLOCK LOOP\xFE";
    z += "                                Call Tcv(False)\xFE";
    z += "                                Cexpr = Expr(Type_eNum, 1, C_do)\xFE";
    z += "                                Call Makebool(Cexpr)\xFE";
    z += "                                \xFE";
    z += "                                If Tkno = C_do Then Call Tcv(False)\xFE";
    z += "                                *\xFE";
    z += "                                * DOBLOCK\xFE";
    z += "                                *\xFE";
    z += "                                If Trim(Oc) <> '' Then Ocpgm[-1] = Oc; Oc = \"\"\xFE";
    z += "                                Call Reseti(3)\xFE";
    z += "                                Holdpgm = Ocpgm; Ocpgm = []; Holdhaslbl = Haslbl; Haslbl = 0\xFE";
    z += "                                Call states(4, C_repeat:C_loop)\xFE";
    z += "                                If Trim(Oc) <> '' Then Ocpgm[-1] = Oc; Oc = \"\"\xFE";
    z += "                                Doblock = Join(Ocpgm, Am); Dolbls = Haslbl; Haslbl += Holdhaslbl; Ocpgm = Holdpgm\xFE";
    z += "                                Call Reseti(-3)\xFE";
    z += "                                \xFE";
    z += "                                If Tkno = C_loop Or Tkno = C_repeat Then Call Tcv(False) Else Call Err(\"LOOP EXPECTED\") ;* Repeat Is Extra\xFE";
    z += "                            Else\xFE";
    z += "                                * DO LOOPBLOCK LOOP { WHILE WHILECOND }\xFE";
    z += "                                *\xFE";
    z += "                                * LOOPBLOCK\xFE";
    z += "                                *\xFE";
    z += "                                If Trim(Oc) <> '' Then Ocpgm[-1] = Oc; Oc = \"\"\xFE";
    z += "                                Call Reseti(3)\xFE";
    z += "                                Holdpgm = Ocpgm; Ocpgm = []; Holdhaslbl = Haslbl; Haslbl = 0\xFE";
    z += "                                Call states(4, C_loop:C_while:C_until:C_repeat:C_do)\xFE";
    z += "                                If Trim(Oc) <> '' Then Ocpgm[-1] = Oc; Oc = \"\"\xFE";
    z += "                                Loopblock = Join(Ocpgm, Am); Looplbls += Haslbl; Haslbl += Holdhaslbl; Ocpgm = Holdpgm\xFE";
    z += "                                Call Reseti(-3)\xFE";
    z += "                                \xFE";
    z += "                                If Tkno = C_loop Then Call Tcv(False) Else\xFE";
    z += "                                    Hascond = Wtkno = C_while Or Wtkno = C_until\xFE";
    z += "                                    If !Hascond Then Call Err('LOOP, WHILE or UNTIL expected')\xFE";
    z += "                                End If\xFE";
    z += "                                \xFE";
    z += "                                Wtkno = Tkno\xFE";
    z += "                                Hascond = Wtkno = C_while Or Wtkno = C_until\xFE";
    z += "                                If Hascond Then\xFE";
    z += "                                    Call Tcv(False)\xFE";
    z += "                                    Cexpr = Expr(Type_eNum, 1, '')\xFE";
    z += "                                    Call Makebool(Cexpr)\xFE";
    z += "                                End\xFE";
    z += "                            End\xFE";
    z += "                        Else\xFE";
    z += "                            * TKSTR = \"LOOP\"\xFE";
    z += "                            * LOOP\xFE";
    z += "                            *    LOOPBLOCK\xFE";
    z += "                            * WHILE WHILECOND DO  --- or --- UNTIL CEXPR DO\xFE";
    z += "                            *    DOBLOCK\xFE";
    z += "                            * REPEAT\xFE";
    z += "                            *\xFE";
    z += "                            If Index(Lb, C_loop, 1) Then Break\xFE";
    z += "                            *\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            Loopblock = \"\"\xFE";
    z += "                            If Tkno <> C_while And Tkno <> C_until Then\xFE";
    z += "                                *\xFE";
    z += "                                * LOOPBLOCK\xFE";
    z += "                                *\xFE";
    z += "                                If Trim(Oc) <> '' Then Ocpgm[-1] = Oc; Oc = \"\"\xFE";
    z += "                                Call Reseti(3)\xFE";
    z += "                                Holdpgm = Ocpgm; Ocpgm = []; Holdhaslbl = Haslbl; Haslbl = 0\xFE";
    z += "                                Call states(4, C_while:C_until:C_repeat:C_do)\xFE";
    z += "                                \xFE";
    z += "                                If Trim(Oc) <> '' Then Ocpgm[-1] = Oc; Oc = \"\"\xFE";
    z += "                                Loopblock = Join(Ocpgm, Am); Looplbls += Haslbl; Haslbl += Holdhaslbl; Ocpgm = Holdpgm\xFE";
    z += "                                Call Reseti(-3)\xFE";
    z += "                                \xFE";
    z += "                                If Tkno = C_repeat Then\xFE";
    z += "                                    If Trim(Oc) = '' Then Oc = Space(Indent-3)\xFE";
    z += "                                    OC := '} while (1); '\xFE";
    z += "                                End\xFE";
    z += "                            End\xFE";
    z += "                            *\xFE";
    z += "                            * COND: CEXPR\xFE";
    z += "                            *\xFE";
    z += "                            Wtkno = Tkno\xFE";
    z += "                            Hascond = Wtkno = C_while Or Wtkno = C_until\xFE";
    z += "                            Doblock = \"\"\xFE";
    z += "                            If Hascond Then\xFE";
    z += "                                Call Tcv(False)\xFE";
    z += "                                Cexpr = Expr(Type_eNum, 1, C_do:C_repeat)\xFE";
    z += "                                Call Makebool(Cexpr)\xFE";
    z += "                                \xFE";
    z += "                                If Tkno = C_repeat Then\xFE";
    z += "                                    Call Tcv(False)\xFE";
    z += "                                Else\xFE";
    z += "                                    If Tkno = C_do Then Call Tcv(False)\xFE";
    z += "                                    *\xFE";
    z += "                                    * DOBLOCK\xFE";
    z += "                                    *\xFE";
    z += "                                    If Trim(Oc) <> '' Then Ocpgm[-1] = Oc; Oc = \"\"\xFE";
    z += "                                    Call Reseti(3)\xFE";
    z += "                                    Holdpgm = Ocpgm; Ocpgm = []; Holdhaslbl = Haslbl; Haslbl = 0\xFE";
    z += "                                    Call states(4, C_repeat)\xFE";
    z += "                                    \xFE";
    z += "                                    If Trim(Oc) <> '' Then Ocpgm[-1] = Oc; Oc = \"\"\xFE";
    z += "                                    Doblock = Join(Ocpgm, Am); Looplbls += Haslbl; Dolbls = Haslbl; Haslbl += Holdhaslbl; Ocpgm = Holdpgm\xFE";
    z += "                                    Call Reseti(-3)\xFE";
    z += "                                    \xFE";
    z += "                                    If Tkno = C_repeat Then Call Tcv(False) Else Call Err('REPEAT expected')\xFE";
    z += "                                End If\xFE";
    z += "                            Else\xFE";
    z += "                                If Tkno <> C_repeat Then Call Err('REPEAT expected')\xFE";
    z += "                            End\xFE";
    z += "                        End\xFE";
    z += "                        \xFE";
    z += "                        Call GenLoop(Wtkno, Hascond, \"\", Cexpr, Loopblock, Doblock, Looplbls, Dolbls)\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"MAT\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Aexpr = matLoad()\xFE";
    z += "                        LSize = MatLoadSize\xFE";
    z += "                        *\xFE";
    z += "                        If Tkno <> C_equal Then Call Err('= expected') Else Call Tcv(False)\xFE";
    z += "                        *\xFE";
    z += "                        If Tkno = C_mat Then\xFE";
    z += "                            ;* Mat A = Mat B\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            Bexpr = matLoad()\xFE";
    z += "                            \xFE";
    z += "                            If !Aexpr.SYM_INDEX1 Or !Bexpr.SYM_INDEX1 Or (Aexpr.SYM_INDEX2 And !Bexpr.SYM_INDEX2) Or (!Aexpr.SYM_INDEX2 And Bexpr.SYM_INDEX2) Then Call Err(\"MISMATCHED DIMENSIONS\")\xFE";
    z += "                            \xFE";
    z += "                            Bexpr.SYM_C= 'clone(':Bexpr.SYM_C:')'\xFE";
    z += "                            \xFE";
    z += "                            Aexpr.SYM_INDEX1 = '' ; Aexpr.SYM_INDEX2 = ''\xFE";
    z += "                            Bexpr.SYM_INDEX1 = '' ; Bexpr.SYM_INDEX2 = ''\xFE";
    z += "                            Call Store(Aexpr, Bexpr)\xFE";
    z += "                        Else\xFE";
    z += "                            * MAT AEXPR = BEXPR\xFE";
    z += "                            Bexpr = Expr(Type_estr, 1, '')\xFE";
    z += "                            OC := Aexpr.SYM_C:\" = createArray(\":Bexpr.SYM_C:\", \":Aexpr.SYM_INDEX1\xFE";
    z += "                            If Aexpr.SYM_INDEX2 Then OC := \", \":Aexpr.SYM_INDEX2\xFE";
    z += "                            OC := \"); \"\xFE";
    z += "                        End If\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"NEXT\" ; Null\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"NULL\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        OC := 'null; '\xFE";
    z += "                        Break\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"ON\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        If Tkstr = \"ERR\" Or Tkstr = \"ERROR\" Then\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            If Tkstr = \"GOTO\" Then\xFE";
    z += "                                Call Tcv(False)\xFE";
    z += "                                If Tkstr = \"0\" Then\xFE";
    z += "                                    OC := 'onError':'Goto = null; '\xFE";
    z += "                                    Call Tcv(False)\xFE";
    z += "                                Else\xFE";
    z += "                                    Tkstr = makesubname(Tkstr)\xFE";
    z += "                                    OC := 'onError':'Goto = \"':Tkstr:'\"; '\xFE";
    z += "                                    Call Uselbl(Tkstr)\xFE";
    z += "                                    Call Tcv(False)\xFE";
    z += "                                End If\xFE";
    z += "                                If Tkno = C_colon Then Call Tcv(False)\xFE";
    z += "                                \xFE";
    z += "                            ElseIf Tkstr = \"RESUME\" Then\xFE";
    z += "                                Call Err('RESUME NEXT not supported')\xFE";
    z += "                                \xFE";
    z += "                            Else\xFE";
    z += "                                Call Err('GOTO expected')\xFE";
    z += "                            End If\xFE";
    z += "                        Else\xFE";
    z += "                            Aexpr = Expr(Type_eNum, 1, C_goto:C_gosub)\xFE";
    z += "                            Call Typenum(Type_vnum, Aexpr)\xFE";
    z += "                            *\xFE";
    z += "                            Gtype = Tkno\xFE";
    z += "                            If Index(C_gosub:C_goto,Gtype,1)=0 Then\xFE";
    z += "                                Call Err('GOTO expected')\xFE";
    z += "                                Hadgosub = 1\xFE";
    z += "                                Break\xFE";
    z += "                            End\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            *\xFE";
    z += "                            OC := 'switch (':Aexpr.SYM_C:') { '\xFE";
    z += "                            If Gtype = C_gosub Then\xFE";
    z += "                                Hadgosub = 1\xFE";
    z += "                                Tlbl = \"_\":Nxtlbl; Nxtlbl = Nxtlbl + 1\xFE";
    z += "                            End If\xFE";
    z += "                            \xFE";
    z += "                            *\xFE";
    z += "                            Pnum = 0\xFE";
    z += "                            Loop\xFE";
    z += "                                Pnum = Pnum + 1\xFE";
    z += "                                Tkstr = makesubname(Tkstr)\xFE";
    z += "                                Jmpadr = Tkstr\xFE";
    z += "                                Call Uselbl(Jmpadr)\xFE";
    z += "                                \xFE";
    z += "                                If Gtype = C_gosub Then\xFE";
    z += "                                    Oc<-1> = Space(Indent+3):'case ':Pnum:':  Gosub(me, ':Jmpadr:'\", \"':Tlbl:'\"); continue atgoto; '\xFE";
    z += "                                Else\xFE";
    z += "                                    Oc<-1> = Space(Indent+3):'case ':Pnum:': gotoLabel = \"':Jmpadr:'\"; continue atgoto;'\xFE";
    z += "                                End\xFE";
    z += "                                \xFE";
    z += "                                Call Tcv(False)\xFE";
    z += "                            While Tkno = C_comma Do\xFE";
    z += "                                Call Tcv(False)\xFE";
    z += "                                If Tkno = C_am Then Call Tcv(False)\xFE";
    z += "                            Repeat\xFE";
    z += "                            Oc<-1> = Space(Indent):'} '\xFE";
    z += "                            \xFE";
    z += "                            If Gtype = C_gosub Then Call Deflbl(Tlbl, 0)\xFE";
    z += "                        End If\xFE";
    z += "                    Case Tkstr = \"PRINT\" Or Tkstr = \"STOP\" Or Tkstr = \"ABORT\" Or Tkstr = \"DEBUG\"\xFE";
    z += "                        Cmd = Tkstr\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "\xFE";
    z += "                        If Index(La,Tkno,1) And (Cmd = \"STOP\" Or Cmd = \"ABORT\") Then\xFE";
    z += "                            OC := 'return Stop(); '\xFE";
    z += "                            \xFE";
    z += "                        Else\xFE";
    z += "                            If Trim(Oc) <> '' Then Ocpgm[-1] = Oc;\xFE";
    z += "                            Oc = Space(Indent)\xFE";
    z += "                            Cma = \"\"\xFE";
    z += "                            Plist = \"\"\xFE";
    z += "                            Crlf = Cmd = \"PRINT\"\xFE";
    z += "                            Loop Until Index(La,Tkno,1) Do\xFE";
    z += "                                If Tkno = C_comma Then\xFE";
    z += "                                    Plist=Plist:', \"\\\\t\"'\xFE";
    z += "                                    Cma = \", \"\xFE";
    z += "                                    Call Tcv(False)\xFE";
    z += "                                    Crlf = 0\xFE";
    z += "                                    \xFE";
    z += "                                ElseIf Tkno = C_colon Then\xFE";
    z += "                                    Call Tcv(False)\xFE";
    z += "                                    Crlf = 0\xFE";
    z += "                                    \xFE";
    z += "                                Else\xFE";
    z += "                                    Crlf = 1\xFE";
    z += "                                    Aexpr = Expr(Type_estr, 1, C_comma:C_colon)\xFE";
    z += "                                    Call Typestr(Type_dc, Aexpr)\xFE";
    z += "                                    Plist=Plist:Cma:Aexpr.SYM_C\xFE";
    z += "                                    Cma = \", \"\xFE";
    z += "                                    Crlf = 1\xFE";
    z += "                                End If\xFE";
    z += "                            Repeat\xFE";
    z += "                            *\xFE";
    z += "                            If Cmd = \"STOP\" Or Cmd = \"ABORT\" Then\xFE";
    z += "                                OC := \"return Stop(\":Plist:\"); \"\xFE";
    z += "                            Else\xFE";
    z += "                                If Crlf Then OC := \"Println(\":Plist:\"); \" Else OC := \"Print(\":Plist:\"); \"\xFE";
    z += "                            Endif\xFE";
    z += "                        End If\xFE";
    z += "                        \xFE";
    z += "                        If Cmd = \"DEBUG\" Then \xFE";
    z += "                            if AddDebugging And !NotASyncFunction Then \xFE";
    z += "                                OC := 'await dbgCheck(me, ':Tkam+1:', false, true); ' \xFE";
    z += "                            Else \xFE";
    z += "                                OC := 'debugger; '\xFE";
    z += "                            End If\xFE";
    z += "                        End If\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"PROMPT\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Aexpr = Expr(Type_estr, 1, '')\xFE";
    z += "                        Call Typestr(Type_dc, Aexpr)\xFE";
    z += "                        Bexpr = {}\xFE";
    z += "                        Bexpr.SYM_C = 'activeProcess.At_Prompt'\xFE";
    z += "                        Bexpr.SYM_TYPE = Type_vstr\xFE";
    z += "                        Call Store(Bexpr, Aexpr)\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"REPEAT\" ; Null\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"RETURN\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        \xFE";
    z += "                        // Return To for Gosub's\xFE";
    z += "                        If Tkno = C_to Then\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            Jmpadr = Tkstr\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            Call Uselbl(Jmpadr)\xFE";
    z += "                            Oc := 'if (ReturnTo(\"L_':Jmpadr:'\")) continue atgoto; else return exit(); '\xFE";
    z += "                            hasPromises[-1] = \"Uses RETURN TO\"\xFE";
    z += "                            \xFE";
    z += "                        // functionType ;* -1) Commons, 0) Program, 1) Subroutine, 2) function, 3) @@function, 4) Pick/RESTFUL function\xFE";
    z += "                        ElseIf functionType = 2 And Index(La, Tkno, 1) = 0 Then\xFE";
    z += "                            // inside a function, with a possible arugment\xFE";
    z += "                            Aexpr = Expr(Funcattr.SYM_TYPE, 1, '')\xFE";
    z += "                            Call MakeAfromB(Aexpr, Funcattr)\xFE";
    z += "                            \xFE";
    z += "                            If hasByRefParamters Then\xFE";
    z += "                                Oc := 'return exit(':Aexpr.SYM_C:'); '\xFE";
    z += "                            Else\xFE";
    z += "                                Oc := 'return ':Aexpr.SYM_C:'; '\xFE";
    z += "                            End If\xFE";
    z += "                            \xFE";
    z += "                        // a Return by itself can be a Gosub's return\xFE";
    z += "                        ElseIf Index(La, Tkno, 1) And (hasLbl Or Hadgosub) Then\xFE";
    z += "                            If hasByRefParamters Then\xFE";
    z += "                                Oc := 'if (isGosubRtn(me)) continue atgoto; else return exit(undefined); '\xFE";
    z += "                            Else\xFE";
    z += "                                Oc := 'if (isGosubRtn(me)) continue atgoto; else return;  '\xFE";
    z += "                            End If\xFE";
    z += "                        \xFE";
    z += "                        ElseIf Ispickfunction And Index(La, Tkno, 1) = 0 Then\xFE";
    z += "                            Aexpr = Expr(Funcattr.SYM_TYPE, 1, '')\xFE";
    z += "                            OC := \"return At_Response.redirect('close_html?pick=' + urlEncode(\":Aexpr.SYM_C:\")); \"\xFE";
    z += "                            \xFE";
    z += "                        ElseIf Isrestfulfunction Then\xFE";
    z += "                            Aexpr = Expr(Funcattr.SYM_TYPE, 1, '')\xFE";
    z += "                            Bexpr = {}\xFE";
    z += "                            Bexpr.SYM_C = \"Restful_Result\"\xFE";
    z += "                            Bexpr.SYM_TYPE = Type_vstr\xFE";
    z += "                            Call Store(Bexpr, Aexpr)\xFE";
    z += "                            OC := 'gotoLabel = \"RESTFUL_SERVEREXIT\"; continue atgoto; '\xFE";
    z += "                            hasPromises[-1] = \"Uses RESTFUL\"\xFE";
    z += "                            \xFE";
    z += "                        Else\xFE";
    z += "                            if Index(La, Tkno, 1) = 0 Then Call Err(\"Unexpected Arugment for subroutine return\");\xFE";
    z += "                            If hasByRefParamters Then\xFE";
    z += "                                Oc := 'return exit(undefined); '\xFE";
    z += "                            Else\xFE";
    z += "                                OC := 'return; '\xFE";
    z += "                            End If\xFE";
    z += "                        End\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"THEN\" ; Null\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"THROW\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Aexpr = Expr(Type_estr, 1, '')\xFE";
    z += "                        Call Typestr(Type_dc, Aexpr)\xFE";
    z += "                        OC := \"throw \":Aexpr.SYM_C:\"; \"\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"UNTIL\" ; Null\xFE";
    z += "                    Case Tkstr = \"WEND\" ; Null\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"SLEEP\" Or Tkstr = \"NAP\"\xFE";
    z += "                        If Tkstr = \"SLEEP\" Then Mult = \" * 1000\" Else Mult = \"\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        If Index(La, Tkno, 1) = 0 Then\xFE";
    z += "                            Aexpr = Expr(Type_estr, 1, '')\xFE";
    z += "                            Call Typenum(Type_vnum, Aexpr)\xFE";
    z += "                            \xFE";
    z += "                        Else\xFE";
    z += "                            Aexpr = {}\xFE";
    z += "                            Aexpr.SYM_C = \"1\"\xFE";
    z += "                            Mult = \"\"\xFE";
    z += "                        End If\xFE";
    z += "                        hasPromises[-1] = \"Uses SLEEP OR NAP\"\xFE";
    z += "                        OC := 'await asyncSleep(':Aexpr.SYM_C:Mult:'); '\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"RQM\" Or Tkstr = \"DOEVENTS\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        hasPromises[-1] = \"Uses RQM OR DOEVENTS\"\xFE";
    z += "                        OC := 'await asyncSleep(1); '\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"SETAUTHCOOKIE\" Or Tkstr = \"SIGNOUT\"\xFE";
    z += "                        * IGNORE THESE COMMANDS\xFE";
    z += "                        Loop While Not(Index(C_semi:C_am:C_sm,Tkno,1)) Do\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                        Repeat\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"DIM\" Or Tkstr = \"VAR\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        \xFE";
    z += "                        Call Typedef(Flavor_local, True /* Process Commas */, False /* isObject */)\xFE";
    z += "                        \xFE";
    z += "                        if false then\xFE";
    z += "                            Htk = savetk()\xFE";
    z += "                        \xFE";
    z += "                            Aexpr = parsevar(2, 1, C_equal, 0)\xFE";
    z += "                            \xFE";
    z += "                            If Tkno = C_equal Then\xFE";
    z += "                                Call Restoret(Htk)\xFE";
    z += "                                \xFE";
    z += "                                * INJECT \"this.\" for class variables\xFE";
    z += "                                If Insideclass And Right(Subname, 4) = \"_NEW\" And Tkstr <> \"THIS\" And Tkstr <> \"ME\" Then\xFE";
    z += "                                    Tkpos = Tkpos - Len(Tkstr)\xFE";
    z += "                                    Tkline = Left(Tkline, Tkpos - 1) : \"this\" : mObjectDelemeter : Mid(Tkline, Tkpos)\xFE";
    z += "                                    Tkno = C_ident\xFE";
    z += "                                    Call Tcv(False)\xFE";
    z += "                                End If\xFE";
    z += "                                \xFE";
    z += "                                Call Assment()\xFE";
    z += "                            Else\xFE";
    z += "                                Call Restoret(Htk)\xFE";
    z += "                                Call Typedef(Flavor_local, True /* Process Commas */, False /* isObject */)\xFE";
    z += "                            End If\xFE";
    z += "                        End If\xFE";
    z += "                        \xFE";
    z += "                        \xFE";
    z += "                        * =========================================== Substitution calls ===============================================\xFE";
    z += "                        * =========================================== Substitution calls ===============================================\xFE";
    z += "                        * =========================================== Substitution calls ===============================================\xFE";
    z += "                        * =========================================== Substitution calls ===============================================\xFE";
    z += "                        * =========================================== Substitution calls ===============================================\xFE";
    z += "                    Case Tkstr = \"LISTFILES\"\xFE";
    z += "                        hasPromises[-1] = \"Uses LISTFILES\"\xFE";
    z += "                        \xFE";
    z += "                        Call Tcv(False) ;* Skip Listfiles\xFE";
    z += "                        If Tkno <> C_to Then Call Err(\"TO EXPECTED\"); Return\xFE";
    z += "                        \xFE";
    z += "                        Call Tcv(False) ;* Skip To\xFE";
    z += "                        \xFE";
    z += "                        ;* == Remove Everything Up To Command, So That What Remains We Be Parameterlist\xFE";
    z += "                        Tkline = Mid(Tkline, Tkstartpos)\xFE";
    z += "                        Tkpos = 1; Tkno = ''; Call Tcv(False)\xFE";
    z += "                        If Trim(Oc) # \"\" Then Ocpgm[-1] = Oc; Oc = \"\"\xFE";
    z += "                        \xFE";
    z += "                        ;* ==================\xFE";
    z += "                        Aexpr = parsevar(1, 0, C_else:C_then:C_lbrace, 1) ;* Storing,Matok, Gattr, Lb, Showerrors)\xFE";
    z += "                        If Tkno = C_lparen Or Tkno = C_lbrack Or Tkno = mObjectDelemeter Then Call Err(\"Invalid reference variable. Too complicated\")\xFE";
    z += "                        \xFE";
    z += "                        ;* ====================\xFE";
    z += "                        Hasthenelse = Tkno = C_then Or Tkno = C_else Or Tkno = C_lbrace\xFE";
    z += "                        Nextcmd = Mid(Tkline, Tkstartpos)\xFE";
    z += "                        Params = Mid(Tkline, 1, Tkstartpos-1)\xFE";
    z += "                        \xFE";
    z += "                        ;* Build Subsitution\xFE";
    z += "                        Tkline = \"IF @JSB_ODB.LISTFILES(\":Params:\") \"\xFE";
    z += "                        If Hasthenelse Then Tkline = Tkline:Nextcmd Else Tkline = Tkline:\" ELSE STOP @ERRORS\"\xFE";
    z += "                        \xFE";
    z += "                        ;* Re-Parse\xFE";
    z += "                        Oc = \"\"; Tkpos = 1; Tkno = ''; Call Tcv(False)\xFE";
    z += "                        \xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Aexpr = Expr(Type_estr, 1, C_then:C_else:C_lbrace)\xFE";
    z += "                        Call Thenelse(Aexpr)\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"CREATEFILE\" Or Tkstr = \"CREATETABLE\"\xFE";
    z += "                        hasPromises[-1] = \"Uses CREATEFILE\"\xFE";
    z += "                        \xFE";
    z += "                        Call Tcv(False) ;* Skip Create\xFE";
    z += "                        \xFE";
    z += "                        ;* == Remove Everything Up To Command, So That What Remains We Be Parameterlist\xFE";
    z += "                        Tkline = Mid(Tkline, Tkstartpos)\xFE";
    z += "                        Tkpos = 1; Tkno = ''; Call Tcv(False)\xFE";
    z += "                        If Trim(Oc) # \"\" Then Ocpgm[-1] = Oc; Oc = \"\"\xFE";
    z += "                        \xFE";
    z += "                        Aexpr = Expr(Type_vstr, 2, C_then:C_else:C_lbrace:C_comma)\xFE";
    z += "                        \xFE";
    z += "                        If Tkno = C_comma Then\xFE";
    z += "                            Call Tcv(False) ;* Skip Comma\xFE";
    z += "                            Bexpr = Expr(Type_vstr, 1, C_then:C_else:C_lbrace)\xFE";
    z += "                        End\xFE";
    z += "                        \xFE";
    z += "                        Hasthenelse = Tkno = C_then Or Tkno = C_else Or Tkno = C_lbrace\xFE";
    z += "                        Nextcmd = Mid(Tkline, Tkstartpos)\xFE";
    z += "                        Params = Mid(Tkline, 1, Tkstartpos-1)\xFE";
    z += "                        \xFE";
    z += "                        ;* Build Subsitution\xFE";
    z += "                        Tkline = \"IF @JSB_ODB.CREATEFILE(\":Params:\") \"\xFE";
    z += "                        If Hasthenelse Then Tkline = Tkline:Nextcmd Else Tkline = Tkline:\" ELSE STOP @ERRORS\"\xFE";
    z += "                        \xFE";
    z += "                        ;* Re-Parse\xFE";
    z += "                        Oc = \"\"; Tkpos = 1; Tkno = ''; Call Tcv(False)\xFE";
    z += "                        \xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Aexpr = Expr(Type_estr, 1, C_then:C_else:C_lbrace)\xFE";
    z += "                        Call Thenelse(Aexpr)\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"CLEARFILE\" Or Tkstr = \"CLEARTABLE\"\xFE";
    z += "                        hasPromises[-1] = \"Uses CLEARFILE\"\xFE";
    z += "                        \xFE";
    z += "                        Call Tcv(False) ;* Skip Clearfile\xFE";
    z += "                        \xFE";
    z += "                        ;* == Remove Everything Up To Command, So That What Remains We Be Parameterlist\xFE";
    z += "                        Tkline = Mid(Tkline, Tkstartpos)\xFE";
    z += "                        Tkpos = 1; Tkno = ''; Call Tcv(False)\xFE";
    z += "                        If Trim(Oc) # \"\" Then Ocpgm[-1] = Oc; Oc = \"\"\xFE";
    z += "                        \xFE";
    z += "                        Aexpr = Expr(Type_vstr, 2, C_then:C_else:C_lbrace)\xFE";
    z += "                        \xFE";
    z += "                        Hasthenelse = Tkno = C_then Or Tkno = C_else Or Tkno = C_lbrace\xFE";
    z += "                        Nextcmd = Mid(Tkline, Tkstartpos)\xFE";
    z += "                        Params = Mid(Tkline, 1, Tkstartpos-1)\xFE";
    z += "                        \xFE";
    z += "                        ;* Build Subsitution\xFE";
    z += "                        Tkline = \"IF @JSB_ODB.CLEARFILE(\":Params:\") \"\xFE";
    z += "                        If Hasthenelse Then Tkline = Tkline:Nextcmd Else Tkline = Tkline:\" ELSE STOP @ERRORS\"\xFE";
    z += "                        \xFE";
    z += "                        ;* Re-Parse\xFE";
    z += "                        Oc = \"\"; Tkpos = 1; Tkno = ''; Call Tcv(False)\xFE";
    z += "                        \xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Aexpr = Expr(Type_estr, 1, C_then:C_else:C_lbrace)\xFE";
    z += "                        Call Thenelse(Aexpr)\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"DELETE\"\xFE";
    z += "                        hasPromises[-1] = \"Uses DELETE\"\xFE";
    z += "                        \xFE";
    z += "                        Call Tcv(False) ;* Skip Delete\xFE";
    z += "                        If Tkno = C_from Then Call Tcv(False)\xFE";
    z += "                        \xFE";
    z += "                        * TKPOS IS ALREADY PAST THE DELETE.\xFE";
    z += "                        Tkline = Mid(Tkline, Tkstartpos) ;* Remove Anything Up To Delete Command\xFE";
    z += "                        Tkpos = 1; Tkno = ''; Call Tcv(False)\xFE";
    z += "                        \xFE";
    z += "                        If Trim(Oc) # \"\" Then Ocpgm[-1] = Oc; Oc = \"\"\xFE";
    z += "                        \xFE";
    z += "                        * PARSE FILENO\xFE";
    z += "                        Aexpr = Expr(Type_vstr, 2, C_comma:C_then:C_else:C_lbrace)\xFE";
    z += "                        \xFE";
    z += "                        * PARSE ITEMNAME\xFE";
    z += "                        Defaultfile = Tkno <> C_comma\xFE";
    z += "                        If Tkno = C_comma Then\xFE";
    z += "                            Call Tcv(False) ;* Skip Comma\xFE";
    z += "                            Bexpr = Expr(Type_vstr, 1, C_then:C_else:C_lbrace)\xFE";
    z += "                        End\xFE";
    z += "                        \xFE";
    z += "                        Hasthenelse = Tkno = C_then Or Tkno = C_else Or Tkno = C_lbrace\xFE";
    z += "                        Nextcmd = Mid(Tkline, Tkstartpos)\xFE";
    z += "                        Params = Mid(Tkline, 1, Tkstartpos-1)\xFE";
    z += "                        If Defaultfile Then Params = \"@FILE, \":Params\xFE";
    z += "                        \xFE";
    z += "                        * BUILD SUBSITUTION\xFE";
    z += "                        Tkline = \"IF @JSB_ODB.DELETEITEM(\":Params:\") \"\xFE";
    z += "                        If Hasthenelse Then Tkline = Tkline:Nextcmd Else Tkline = Tkline:\" ELSE STOP @ERRORS\"\xFE";
    z += "                        \xFE";
    z += "                        Tkpos = 1; Tkno = ''; Call Tcv(False)\xFE";
    z += "                        \xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Aexpr = Expr(Type_estr, 1, C_then:C_else:C_lbrace)\xFE";
    z += "                        Call Thenelse(Aexpr)\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"DELETEFILE\" Or Tkstr = \"DELETETABLE\"\xFE";
    z += "                        hasPromises[-1] = \"Uses DELETEFILE\"\xFE";
    z += "                        \xFE";
    z += "                        Call Tcv(False) ;* Skip Create\xFE";
    z += "                        \xFE";
    z += "                        ;* == Remove Everything Up To Command, So That What Remains We Be Parameterlist\xFE";
    z += "                        Tkline = Mid(Tkline, Tkstartpos)\xFE";
    z += "                        Tkpos = 1; Tkno = ''; Call Tcv(False)\xFE";
    z += "                        If Trim(Oc) # \"\" Then Ocpgm[-1] = Oc; Oc = \"\"\xFE";
    z += "                        \xFE";
    z += "                        Aexpr = Expr(Type_vstr, 2, C_then:C_else:C_lbrace)\xFE";
    z += "                        \xFE";
    z += "                        Hasthenelse = Tkno = C_then Or Tkno = C_else Or Tkno = C_lbrace\xFE";
    z += "                        Nextcmd = Mid(Tkline, Tkstartpos)\xFE";
    z += "                        Params = Mid(Tkline, 1, Tkstartpos-1)\xFE";
    z += "                        \xFE";
    z += "                        ;* Build Subsitution\xFE";
    z += "                        Tkline = \"IF @JSB_ODB.DELETEFILE(\":Params:\") \"\xFE";
    z += "                        If Hasthenelse Then Tkline = Tkline:Nextcmd Else Tkline = Tkline:\" ELSE STOP @ERRORS\"\xFE";
    z += "                        \xFE";
    z += "                        ;* Re-Parse\xFE";
    z += "                        Oc = \"\"; Tkpos = 1; Tkno = ''; Call Tcv(False)\xFE";
    z += "                        \xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Aexpr = Expr(Type_estr, 1, C_then:C_else:C_lbrace)\xFE";
    z += "                        Call Thenelse(Aexpr)\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"WRITE\" Or Tkstr = \"WRITEU\" Or Tkstr = \"WRITEXML\" Or Tkstr = \"WRITEXMLU\" Or Tkstr = \"WRITEJSON\" Or Tkstr = \"WRITEJSONU\" Or Tkstr = \"WRITEV\" Or Tkstr = \"WRITEVU\" Or Tkstr = \"MATWRITE\" Or Tkstr = \"MATWRITEU\"\xFE";
    z += "                        hasPromises[-1] = \"Uses WRITE\"\xFE";
    z += "                        \xFE";
    z += "                        Begin Case\xFE";
    z += "                            Case Tkstr = \"WRITE\"; Opts = \"\"\xFE";
    z += "                            Case Tkstr = \"WRITEXML\"; Opts = \"XML\"\xFE";
    z += "                            Case Tkstr = \"WRITEJSON\"; Opts = \"JSON\"\xFE";
    z += "                            Case Tkstr = \"WRITEV\"; Opts = \"V\"\xFE";
    z += "                            Case Tkstr = \"MATWRITE\"; Opts = \"\"\xFE";
    z += "                                \xFE";
    z += "                            Case Tkstr = \"WRITEU\"; Opts = \"U\"\xFE";
    z += "                            Case Tkstr = \"WRITEXMLU\"; Opts = \"XMLU\"\xFE";
    z += "                            Case Tkstr = \"WRITEJSONU\"; Opts = \"JSONU\"\xFE";
    z += "                            Case Tkstr = \"WRITEVU\"; Opts = \"VU\"\xFE";
    z += "                            Case Tkstr = \"MATWRITEU\"; Opts = \"U\"\xFE";
    z += "                        End Case\xFE";
    z += "                        \xFE";
    z += "                        ;* Write (*Aexpr) On Aexpr, Idattr Then, Aexprlink Pc\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        \xFE";
    z += "                        ;* == Remove Everything Up To Command, So That What Remains We Be Parameterlist\xFE";
    z += "                        Tkline = Mid(Tkline, Tkstartpos)\xFE";
    z += "                        Tkpos = 1; Tkno = ''; Call Tcv(False)\xFE";
    z += "                        If Trim(Oc) # \"\" Then Ocpgm[-1] = Oc; Oc = \"\"\xFE";
    z += "                        \xFE";
    z += "                        Aexpr = Expr(Type_vstr, 1, C_on:C_to:C_from)\xFE";
    z += "                        If Opts = \"\" Or Opts = \"V\" Or Opts = \"U\" Or Opts = \"VU\" Then Call Makestr(Type_vstr, Aexpr)\xFE";
    z += "                        \xFE";
    z += "                        If (Tkno <> C_on) And (Tkno <> C_to) And (Tkno <> C_from) Then Call Err(\"ON EXPECTED\"); Return\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        \xFE";
    z += "                        Aexpr = Expr(Type_vstr, 2, C_comma:C_then:C_else:C_lbrace)\xFE";
    z += "                        \xFE";
    z += "                        If Tkno <> C_comma Then Call Err(\", EXPECTED\"); Return\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Aexpr = Expr(Type_vstr, 1, C_then:C_comma:C_else)\xFE";
    z += "                        \xFE";
    z += "                        If Instr(Opts, \"V\") Then\xFE";
    z += "                            If Tkno <> C_comma Then Call Err(\", EXPECTED\"); Return\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            Aexpr = Expr(Type_vstr, 1, C_then:C_else:C_lbrace)\xFE";
    z += "                        End\xFE";
    z += "                        \xFE";
    z += "                        Hasthenelse = Tkno = C_then Or Tkno = C_else Or Tkno = C_lbrace\xFE";
    z += "                        Nextcmd = Mid(Tkline, Tkstartpos)\xFE";
    z += "                        Params = Mid(Tkline, 1, Tkstartpos-1)\xFE";
    z += "                        \xFE";
    z += "                        Params = Replacei(Params, \" ON \", \",\")\xFE";
    z += "                        \xFE";
    z += "                        ;* Build Subsitution\xFE";
    z += "                        Tkline = \"IF @JSB_ODB.WRITE\":Opts:\"(\":Params:\") \"\xFE";
    z += "                        If Hasthenelse Then Tkline = Tkline:Nextcmd Else Tkline = Tkline:\" ELSE STOP @ERRORS\"\xFE";
    z += "                        \xFE";
    z += "                        ;* Re-Parse\xFE";
    z += "                        Oc = \"\"; Tkpos = 1; Tkno = ''; Call Tcv(False)\xFE";
    z += "                        \xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Aexpr = Expr(Type_estr, 1, C_then:C_else:C_lbrace)\xFE";
    z += "                        Call Thenelse(Aexpr)\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"MATREAD\" Or Tkstr = \"MATREADU\" Or Tkstr = \"READ\" Or Tkstr = \"READU\" Or Tkstr = \"READV\" Or Tkstr = \"READVU\" Or Tkstr = \"READXML\" Or Tkstr = \"READXMLU\" Or Tkstr = \"READJSON\" Or Tkstr = \"READJSONU\"\xFE";
    z += "                        hasPromises[-1] = \"Uses READ\"\xFE";
    z += "                        \xFE";
    z += "                        Begin Case\xFE";
    z += "                            Case Tkstr = \"READ\"; Opts = \"\"\xFE";
    z += "                            Case Tkstr = \"READXML\"; Opts = \"XML\"\xFE";
    z += "                            Case Tkstr = \"READJSON\"; Opts = \"JSON\"\xFE";
    z += "                            Case Tkstr = \"READV\"; Opts = \"V\"\xFE";
    z += "                                \xFE";
    z += "                            Case Tkstr = \"READU\"; Opts = \"U\"\xFE";
    z += "                            Case Tkstr = \"READUXML\"; Opts = \"XMLU\"\xFE";
    z += "                            Case Tkstr = \"READUJSON\"; Opts = \"JSONU\"\xFE";
    z += "                            Case Tkstr = \"READUV\"; Opts = \"VU\"\xFE";
    z += "                                \xFE";
    z += "                            Case Tkstr = \"READXMLU\"; Opts = \"XMLU\"\xFE";
    z += "                            Case Tkstr = \"READJSONU\"; Opts = \"JSONU\"\xFE";
    z += "                            Case Tkstr = \"READVU\"; Opts = \"VU\"\xFE";
    z += "                            Case Tkstr = \"MATREAD\"; Opts = \"M\"\xFE";
    z += "                            Case Tkstr = \"MATREADU\"; Opts = \"MU\"\xFE";
    z += "                        End Case\xFE";
    z += "                        \xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        \xFE";
    z += "                        ;* == Remove Everything Up To Command, So That What Remains We Be Parameterlist\xFE";
    z += "                        Tkline = Mid(Tkline, Tkstartpos)\xFE";
    z += "                        Tkpos = 1; Tkno = ''; Call Tcv(False)\xFE";
    z += "                        If Trim(Oc) # \"\" Then Ocpgm[-1] = Oc; Oc = \"\"\xFE";
    z += "                        \xFE";
    z += "                        Aexpr = parsevar(1, 1, C_from, 1)\xFE";
    z += "                        \xFE";
    z += "                        \xFE";
    z += "                        If Tkno <> C_from Then Call Err(\"FROM EXPECTED\"); Return\xFE";
    z += "                        \xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Aexpr = Expr(Type_vstr, 2, C_comma:C_then:C_else:C_lbrace)\xFE";
    z += "                        \xFE";
    z += "                        If Tkno <> C_comma Then Call Err(\", EXPECTED\"); Return\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Aexpr = Expr(Type_vstr, 1, C_then:C_comma:C_else)\xFE";
    z += "                        \xFE";
    z += "                        If Instr(Opts, \"V\") Then\xFE";
    z += "                            If Tkno <> C_comma Then Call Err(\", EXPECTED\"); Return\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            Aexpr = Expr(Type_vstr, 1, C_then:C_else:C_lbrace)\xFE";
    z += "                        End\xFE";
    z += "                        \xFE";
    z += "                        Hasthenelse = Tkno = C_then Or Tkno = C_else Or Tkno = C_lbrace\xFE";
    z += "                        Nextcmd = Mid(Tkline, Tkstartpos)\xFE";
    z += "                        Params = Mid(Tkline, 1, Tkstartpos-1)\xFE";
    z += "                        \xFE";
    z += "                        Params = Replacei(Params, \" FROM \", \",\")\xFE";
    z += "                        \xFE";
    z += "                        ;* Build Subsitution\xFE";
    z += "                        Tkline = \"IF @JSB_ODB.READ\":Opts:\"(\":Params:\") \"\xFE";
    z += "                        If Hasthenelse Then Tkline = Tkline:Nextcmd Else Tkline = Tkline:\" ELSE STOP @ERRORS\"\xFE";
    z += "                        \xFE";
    z += "                        ;* Re-Parse\xFE";
    z += "                        Oc = \"\"; Tkpos = 1; Tkno = ''; Call Tcv(False)\xFE";
    z += "                        \xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Aexpr = Expr(Type_estr, 1, C_then:C_else:C_lbrace)\xFE";
    z += "                        Call Thenelse(Aexpr)\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"OPEN\"\xFE";
    z += "                        hasPromises[-1] = \"Uses OPEN\"\xFE";
    z += "                        \xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        \xFE";
    z += "                        ;* == Remove Everything Up To Command, So That What Remains We Be Parameterlist\xFE";
    z += "                        Tkline = Mid(Tkline, Tkstartpos)\xFE";
    z += "                        Tkpos = 1; Tkno = ''; Call Tcv(False)\xFE";
    z += "                        If Trim(Oc) # \"\" Then Ocpgm[-1] = Oc; Oc = \"\"\xFE";
    z += "                        \xFE";
    z += "                        Aexpr = Expr(Type_vstr, 1, C_comma:C_to:C_on:C_then:C_else:C_lbrace)\xFE";
    z += "                        \xFE";
    z += "                        If Tkno = C_comma Then\xFE";
    z += "                            Needsdict = 0\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            Aexpr = Expr(Type_vstr, 1, C_to:C_on:C_then:C_else:C_lbrace)\xFE";
    z += "                        Else\xFE";
    z += "                            Needsdict = 1\xFE";
    z += "                        End\xFE";
    z += "                        \xFE";
    z += "                        Needsto = Tkno <> C_to\xFE";
    z += "                        If !Needsto Then\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            Aexpr = parsevar(1, 0, C_else:C_then:C_lbrace, 1) ;* Storing,Matok, Gattr, Lb, Showerrors)\xFE";
    z += "                            If Tkno = C_lparen Or Tkno = C_lbrack Or Tkno = mObjectDelemeter Then Call Err(\"Invalid reference variable. Too complicated\")\xFE";
    z += "                        End If\xFE";
    z += "                        \xFE";
    z += "                        Hasthenelse = Tkno = C_then Or Tkno = C_else Or Tkno = C_lbrace\xFE";
    z += "                        Nextcmd = Mid(Tkline, Tkstartpos)\xFE";
    z += "                        Params = Mid(Tkline, 1, Tkstartpos-1)\xFE";
    z += "                        \xFE";
    z += "                        Params = Replacei(Params, \" TO \", \",\")\xFE";
    z += "                        If Needsdict Then Params = \"'', \":Params\xFE";
    z += "                        If Needsto Then Params = Params:\", @FILE\"\xFE";
    z += "                        \xFE";
    z += "                        ;* Build Subsitution\xFE";
    z += "                        Tkline = \"IF @JSB_ODB.OPEN(\":Params:\") \"\xFE";
    z += "                        \xFE";
    z += "                        If Hasthenelse Then Tkline = Tkline:Nextcmd Else Tkline = Tkline:\" ELSE STOP @ERRORS\"\xFE";
    z += "                        \xFE";
    z += "                        ;* Re-Parse\xFE";
    z += "                        Oc = \"\"; Tkpos = 1; Tkno = ''; Call Tcv(False)\xFE";
    z += "                        \xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Aexpr = Expr(Type_estr, 1, C_then:C_else:C_lbrace)\xFE";
    z += "                        Call Thenelse(Aexpr)\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"SELECTFILE\"\xFE";
    z += "                        hasPromises[-1] = \"Uses SELECT\"\xFE";
    z += "                        \xFE";
    z += "                        ;* Sleect F_file Then Where Cond Then To Dim\xFE";
    z += "                        ;* Select { COLUMNS } From F_file Then Where Cond  Then To Dim\xFE";
    z += "                        \xFE";
    z += "                        ;* == Remove Everything Up To Command, So That What Remains We Be Parameterlist\xFE";
    z += "                        Tkline = Mid(Tkline, Tkstartpos)\xFE";
    z += "                        Tkpos = 1; Tkno = ''; Call Tcv(False) ;* Reset To Start Of Line\xFE";
    z += "                        If Trim(Oc) # \"\" Then Ocpgm[-1] = Oc; Oc = \"\"\xFE";
    z += "                        \xFE";
    z += "                        Columnlist = '\"\"'\xFE";
    z += "                        Wherestring = '\"\"'\xFE";
    z += "                        Tofile = '\"\"'\xFE";
    z += "                        \xFE";
    z += "                        If Tkno <> C_from Then\xFE";
    z += "                            Aexpr = Expr(Type_vstr, 1, C_to:C_from:C_where:C_then:C_else:C_lbrace)\xFE";
    z += "                        End If\xFE";
    z += "                        \xFE";
    z += "                        If Tkno = C_from Then\xFE";
    z += "                            Columnlist = RTrim(Mid(Tkline, 1, Tkstartpos-1))\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            Tkline = Mid(Tkline, Tkstartpos); Tkpos = 1; Tkno = ''; Call Tcv(False)\xFE";
    z += "                            Aexpr = Expr(Type_vstr, 2, C_to:C_where:C_then:C_else:C_lbrace)\xFE";
    z += "                        End\xFE";
    z += "                        \xFE";
    z += "                        Fromfile = RTrim(Mid(Tkline, 1, Tkstartpos-1))\xFE";
    z += "                        Tkline = Mid(Tkline, Tkstartpos); Tkpos = 1; Tkno = ''; Call Tcv(False)\xFE";
    z += "                        \xFE";
    z += "                        Cmd = \"SELECT\"\xFE";
    z += "                        \xFE";
    z += "                        Loop While Tkno = C_where Or Tkno = C_to Do\xFE";
    z += "                            If Tkno = C_where Then\xFE";
    z += "                                Call Tcv(False) ;* Skip Fwhere\xFE";
    z += "                                Tkline = Mid(Tkline, Tkstartpos); Tkpos = 1; Tkno = ''; Call Tcv(False)\xFE";
    z += "                                Aexpr = Expr(Type_vstr, 1, C_to:C_where:C_then:C_else:C_lbrace)\xFE";
    z += "                                Wherestring = RTrim(Mid(Tkline, 1, Tkstartpos-1))\xFE";
    z += "                                Tkline = Mid(Tkline, Tkstartpos); Tkpos = 1; Tkno = ''; Call Tcv(False)\xFE";
    z += "                            End\xFE";
    z += "                            \xFE";
    z += "                            If Tkno = C_to Then\xFE";
    z += "                                Call Tcv(False)\xFE";
    z += "                                Tkline = Mid(Tkline, Tkstartpos); Tkpos = 1; Tkno = ''; Call Tcv(False)\xFE";
    z += "                                Cmd = \"SELECTTO\"\xFE";
    z += "                                \xFE";
    z += "                                Aexpr = parsevar(1, 0, C_to:C_where:C_then:C_else:C_lbrace, 1) ;* Storing,Matok, Gattr, Lb, Showerrors)\xFE";
    z += "                                If Tkno = C_lparen Or Tkno = C_lbrack Or Tkno = mObjectDelemeter Then Call Err(\"Invalid reference variable. Too complicated\")\xFE";
    z += "\xFE";
    z += "                                Tofile = RTrim(Mid(Tkline, 1, Tkstartpos-1))\xFE";
    z += "                                Tkline = Mid(Tkline, Tkstartpos); Tkpos = 1; Tkno = ''; Call Tcv(False)\xFE";
    z += "                            End\xFE";
    z += "                        Repeat\xFE";
    z += "                        \xFE";
    z += "                        Hasthenelse = Tkno = C_then Or Tkno = C_else Or Tkno = C_lbrace\xFE";
    z += "                        Nextcmd = Mid(Tkline, Tkstartpos)\xFE";
    z += "                        \xFE";
    z += "                        ;* Build Subsitution\xFE";
    z += "                        Tkline = \"IF @JSB_ODB.\":Cmd:\"(\":Columnlist:\", \":Fromfile:\", \":Wherestring:\", \":Tofile:\") \"\xFE";
    z += "                        If Hasthenelse Then Tkline = Tkline:Nextcmd Else Tkline = Tkline:\" ELSE STOP @ERRORS\"\xFE";
    z += "                        \xFE";
    z += "                        ;* Re-Parse\xFE";
    z += "                        Oc = \"\"; Tkpos = 1; Tkno = ''; Call Tcv(False)\xFE";
    z += "                        \xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Aexpr = Expr(Type_estr, 1, C_then:C_else:C_lbrace)\xFE";
    z += "                        Call Thenelse(Aexpr)\xFE";
    z += "                        \xFE";
    z += "                        * ====================================================================== list Calls ======================================================================\xFE";
    z += "                        * ====================================================================== list Calls ======================================================================\xFE";
    z += "                        * ====================================================================== list Calls ======================================================================\xFE";
    z += "                        * ====================================================================== list Calls ======================================================================\xFE";
    z += "                    Case Tkstr = \"CLEARSELECT\" Or Tkstr = \"I_CLEARSELECT\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        If Tkno = C_from Then\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            Aexpr = Expr(Type_vstr, 1, C_comma:C_then:C_else:C_lbrace:C_locked)\xFE";
    z += "                            OC := 'clearSelect(':Aexpr.SYM_C:'); '\xFE";
    z += "                        Else\xFE";
    z += "                            OC := 'clearSelect(odbActiveSelectList); '\xFE";
    z += "                        End\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"READNEXT\" Or Tkstr = \"I_READNEXT\"\xFE";
    z += "                        * LOAD ADDRESS OF VARIABLE NAME\xFE";
    z += "                        *\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Bexpr = parsevar(1, 0, C_comma:C_from:C_then:C_else:C_lbrace, 1)\xFE";
    z += "                        *\xFE";
    z += "                        If Tkno = C_comma Then\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            Dexpr = parsevar(1, 0, C_from:C_then:C_else:C_lbrace, 1)\xFE";
    z += "                        Else\xFE";
    z += "                            Dexpr = {}\xFE";
    z += "                            Dexpr.SYM_C = \"\"\xFE";
    z += "                        End\xFE";
    z += "                        *\xFE";
    z += "                        If Tkno = C_from Then\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            Cexpr = Expr(Type_vstr, 1, C_comma:C_then:C_else:C_lbrace:C_locked)\xFE";
    z += "                        Else\xFE";
    z += "                            Cexpr = {}\xFE";
    z += "                            Cexpr.SYM_C = \"odbActiveSelectList\"\xFE";
    z += "                        End\xFE";
    z += "                        *\xFE";
    z += "                        * READNEXT BEXPR, DEXPR FROM CEXPR ELSE\xFE";
    z += "                        *\xFE";
    z += "                        If Dexpr.SYM_C Then\xFE";
    z += "                            * GET ITEM TOO\xFE";
    z += "                            OC := \"_ss = readNext(\":Cexpr.SYM_C:\").item; \":Bexpr.SYM_C:\" = _ss.itemid; \":Dexpr.SYM_C:\" = _ss.item; \"\xFE";
    z += "                            Bexpr.SYM_C = \"_ss.success\"\xFE";
    z += "                        Else\xFE";
    z += "                            OC := Bexpr.SYM_C:\" = readNext(\":Cexpr.SYM_C:\").itemid; \"\xFE";
    z += "                        End If\xFE";
    z += "                        \xFE";
    z += "                        Call Thenelse(Bexpr)\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"READLIST\"  Or Tkstr = \"GETLIST\" Or Tkstr = \"I_READLIST\"  Or Tkstr = \"I_GETLIST\" ;* Getlist Aexpr { TO BEXPR } Or Readlist Bexpr From Aexpr\xFE";
    z += "                        If Tkstr = \"READLIST\" Then\xFE";
    z += "                            * READLIST BEXPR FROM AEXPR\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            Bexpr = parsevar(1, 1, C_from, 1)\xFE";
    z += "                            If Tkno <> C_from Then Call Err('FROM  expected') ; Break\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            Aexpr = Expr(Type_estr, 1, C_then:C_else:C_lbrace)\xFE";
    z += "                        Else\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            Aexpr = Expr(Type_estr, 1, C_to)\xFE";
    z += "                            Call Typestr(Type_dc, Aexpr)\xFE";
    z += "                            If Tkno = C_to Then\xFE";
    z += "                                Call Tcv(False)\xFE";
    z += "                                Bexpr = parsevar(1, 0, '', 1) ;* Storing,Matok, Gattr, Lb, Showerrors)\xFE";
    z += "                                If Tkno = C_lparen Or Tkno = C_lbrack Or Tkno = mObjectDelemeter Then Call Err(\"Invalid reference variable. Too complicated\")\xFE";
    z += "                            Else\xFE";
    z += "                                Bexpr = {}\xFE";
    z += "                                Bexpr.SYM_C = \"odbActiveSelectList\"\xFE";
    z += "                            End If\xFE";
    z += "                        End If\xFE";
    z += "                        *\xFE";
    z += "                        * GETLIST AEXPR { TO BEXPR } OR READLIST BEXPR FROM AEXPR\xFE";
    z += "                        * \xFE";
    z += "                        Call Uses(Bexpr)\xFE";
    z += "                        hasPromises[-1] = \"Uses READLIST OR GETLIST\"\xFE";
    z += "                        Aexpr.SYM_C = 'await asyncGetList(':Aexpr.SYM_C:', _selectList => ':Bexpr.SYM_C:' = _selectList)'\xFE";
    z += "                        Aexpr.SYM_TYPE = Type_eBool\xFE";
    z += "                        Call Thenelse(Aexpr)\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"DELETELIST\" Or Tkstr = \"I_DELETELIST\"                    \xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Aexpr = Expr(Type_estr, 1, C_to)\xFE";
    z += "                        Call Typestr(Type_dc, Aexpr)\xFE";
    z += "                        *\xFE";
    z += "                        * DELETELIST AEXPR  (Delete the itemID from the SelectList file)\xFE";
    z += "                        *\xFE";
    z += "                        hasPromises[-1] = \"Uses DELETELIST\"\xFE";
    z += "                        Aexpr.SYM_C = 'await asyncDeleteList(':Aexpr.SYM_C:')'\xFE";
    z += "                        Aexpr.SYM_TYPE = Type_eBool\xFE";
    z += "                        Call Thenelse(Aexpr)\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"FORMLIST\" Or Tkstr = \"I_FORMLIST\"\xFE";
    z += "                        * FORMLIST LIST { TO SELNO } ELSE\xFE";
    z += "                        *\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Aexpr = Expr(Type_estr, 1, C_to:C_then:C_else:C_lbrace)\xFE";
    z += "                        Call Typestr(Type_dc, Aexpr)\xFE";
    z += "                        If Tkno = C_to Then\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            \xFE";
    z += "                            Bexpr = parsevar(1, 0, C_then:C_else:C_lbrace, 1) ;* Storing,Matok, Gattr, Lb, Showerrors)\xFE";
    z += "                            If Tkno = C_lparen Or Tkno = C_lbrack Or Tkno = mObjectDelemeter Then Call Err(\"Invalid reference variable. Too complicated\")\xFE";
    z += "\xFE";
    z += "                            OC := Bexpr.SYM_C:' = formList(':Aexpr.SYM_C:'); '\xFE";
    z += "                            Call Uses(Bexpr)\xFE";
    z += "                        Else\xFE";
    z += "                            OC := 'odbActiveSelectList = formList(':Aexpr.SYM_C:'); '\xFE";
    z += "                        End\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"SAVELIST\" Or Tkstr = \"WRITELIST\" Or Tkstr = \"I_SAVELIST\" Or Tkstr = \"I_WRITELIST\"\xFE";
    z += "                        * SAVELIST { bexpr } TO aexpr (IE, WRITE BEXPR ON POINTERFILE, AEXPR)\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        \xFE";
    z += "                        If Tkno <> C_on And Tkno <> C_to Then\xFE";
    z += "                            Bexpr = Expr(Type_estr, 1, C_on:C_to)\xFE";
    z += "                            Call Typestr(Type_dc, Bexpr)\xFE";
    z += "                        Else\xFE";
    z += "                            Bexpr = {}\xFE";
    z += "                            Bexpr.SYM_C = \"odbActiveSelectList\"\xFE";
    z += "                        End If\xFE";
    z += "                        *\xFE";
    z += "                        If Tkno <> C_on And Tkno <> C_to Then Call Err('TO expected') ; Break\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Aexpr = Expr(Type_estr, 1, C_comma)\xFE";
    z += "                        Call Typestr(Type_dc, Aexpr)\xFE";
    z += "                        *\xFE";
    z += "                        * SAVELIST bexpr TO aexpr (IE, WRITE BEXPR ON POINTERFILE, AEXPR)\xFE";
    z += "                        *\xFE";
    z += "                        hasPromises[-1] = \"Uses SAVELIST or WRITELIST\"\xFE";
    z += "                        Aexpr.SYM_C = 'await asyncSaveList(':Bexpr.SYM_C:', ':Aexpr.SYM_C:')'\xFE";
    z += "                        Aexpr.SYM_TYPE = Type_eBool\xFE";
    z += "                        Call Thenelse(Aexpr)\xFE";
    z += "                        \xFE";
    z += "                        \xFE";
    z += "                        * ====================================================================== i_Direct Calls ======================================================================\xFE";
    z += "                        * ====================================================================== i_Direct Calls ======================================================================\xFE";
    z += "                        * ====================================================================== i_Direct Calls ======================================================================\xFE";
    z += "                        * ====================================================================== i_Direct Calls ======================================================================\xFE";
    z += "                    Case Tkstr = \"I_EMAIL\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        If Tkno = C_lparen Then Call Tcv(False)\xFE";
    z += "                        \xFE";
    z += "                        fromExpr = Expr(Type_estr, 1, C_rparen:C_then:C_else:C_comma)\xFE";
    z += "                        Call Typestr(Type_estr, fromExpr)\xFE";
    z += "                        If Tkno = C_comma Then Call Tcv(False) Else Call Err(\"From, To, CC, BCC, Subject, Body expected\")\xFE";
    z += "                        \xFE";
    z += "                        ToExpr = Expr(Type_estr, 1, C_rparen:C_then:C_else:C_comma)\xFE";
    z += "                        Call Typestr(Type_estr, ToExpr)\xFE";
    z += "                        If Tkno = C_comma Then Call Tcv(False) Else Call Err(\"From, To, CC, BCC, Subject, Body expected\")\xFE";
    z += "                        \xFE";
    z += "                        ccExpr = Expr(Type_estr, 1, C_rparen:C_then:C_else:C_comma)\xFE";
    z += "                        Call Typestr(Type_estr, ccExpr)\xFE";
    z += "                        If Tkno = C_comma Then Call Tcv(False) Else Call Err(\"From, To, CC, BCC, Subject, Body expected\")\xFE";
    z += "                        \xFE";
    z += "                        bccExpr = Expr(Type_estr, 1, C_rparen:C_then:C_else:C_comma)\xFE";
    z += "                        Call Typestr(Type_estr, bccExpr)\xFE";
    z += "                        If Tkno = C_comma Then Call Tcv(False) Else Call Err(\"From, To, CC, BCC, Subject, Body expected\")\xFE";
    z += "\xFE";
    z += "                        subjectExpr = Expr(Type_estr, 1, C_rparen:C_then:C_else:C_comma)\xFE";
    z += "                        Call Typestr(Type_estr, subjectExpr)\xFE";
    z += "                        If Tkno = C_comma Then Call Tcv(False) Else Call Err(\"From, To, CC, BCC, Subject, Body expected\")\xFE";
    z += "\xFE";
    z += "                        bodyExpr = Expr(Type_estr, 1, C_rparen:C_then:C_else:C_comma)\xFE";
    z += "                        Call Typestr(Type_estr, bodyExpr)\xFE";
    z += "                        \xFE";
    z += "                        If Tkno = C_rparen Then Call Tcv(False)\xFE";
    z += "                \xFE";
    z += "                        Aexpr = {}\xFE";
    z += "                        Aexpr.SYM_C := \"sendEMail(\":fromExpr.SYM_C:\", \":ToExpr.SYM_C:\", \":ccExpr.SYM_C:\", \":bccExpr.SYM_C:\", \":subjectExpr.SYM_C:\", \":bodyExpr.SYM_C:\")\"\xFE";
    z += "                        Aexpr.SYM_TYPE = Type_eBool\xFE";
    z += "                        If Tkno = C_then Or Tkno = C_else Then Call Thenelse(Aexpr) Else Oc<-1> = Space(Indent):Aexpr.SYM_C:\"; \"\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"I_DELETEDB\"           \xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Aexpr = Expr(Type_estr, 1, C_comma)\xFE";
    z += "                        Call Typestr(Type_dc, Aexpr)\xFE";
    z += "                        hasPromises[-1] = \"Uses I_DELETEDB\"\xFE";
    z += "                        Aexpr.SYM_C = 'await asyncDeleteDB(':Aexpr.SYM_C:')'\xFE";
    z += "                        Aexpr.SYM_TYPE = Type_eBool\xFE";
    z += "                        Call Thenelse(Aexpr)\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"I_CREATEDB\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Aexpr = Expr(Type_estr, 1, C_comma)\xFE";
    z += "                        Call Typestr(Type_dc, Aexpr)\xFE";
    z += "                        hasPromises[-1] = \"Uses I_CREATEDB\"\xFE";
    z += "                        Aexpr.SYM_C = 'await asyncCreateDB(':Aexpr.SYM_C:')'\xFE";
    z += "                        Aexpr.SYM_TYPE = Type_eBool\xFE";
    z += "                        Call Thenelse(Aexpr)\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"I_CREATEFILE\" Or Tkstr = \"I_CREATETABLE\" ;* Create Bexpr, Cexpr To Aexpr\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Bexpr = Expr(Type_estr, 1, C_comma:C_to:C_on:C_then:C_else:C_lbrace) ;* Parse Dict/DATA Into Bexpr\xFE";
    z += "                        Call Typestr(Type_dc, Bexpr)\xFE";
    z += "                        *\xFE";
    z += "                        If Tkno = C_comma Then\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            Cexpr = Expr(Type_estr, 1, C_to:C_on:C_then:C_else:C_lbrace)\xFE";
    z += "                            Call Typestr(Type_dc, Cexpr)\xFE";
    z += "                        Else\xFE";
    z += "                            Cexpr = Clone(Bexpr)\xFE";
    z += "                            Bexpr = {}\xFE";
    z += "                            Bexpr.SYM_C = '\"\"'\xFE";
    z += "                        End\xFE";
    z += "                        *\xFE";
    z += "                        * LOAD FILE VARIABLE\xFE";
    z += "                        *\xFE";
    z += "                        If Tkno <> C_to Then\xFE";
    z += "                            Aexpr = {}\xFE";
    z += "                            Aexpr.SYM_C='activeProcess.At_File'\xFE";
    z += "                            Aexpr.SYM_TYPE=Type_vstr\xFE";
    z += "                        Else\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            Aexpr = parsevar(1, 0, C_then:C_else:C_lbrace, 1) ;* Storing,Matok, Gattr, Lb, Showerrors)\xFE";
    z += "                            If Tkno = C_lparen Or Tkno = C_lbrack Or Tkno = mObjectDelemeter Then Call Err(\"Invalid reference variable. Too complicated\")\xFE";
    z += "                        End\xFE";
    z += "                        *\xFE";
    z += "                        * create bexpr, cexpr to aexpr\xFE";
    z += "                        *\xFE";
    z += "                        hasPromises[-1] = \"Uses I_CREATEFILE\"\xFE";
    z += "                        Call Uses(Aexpr)\xFE";
    z += "                        Aexpr.SYM_C = 'await asyncCreateTable(':Bexpr.SYM_C:', ':Cexpr.SYM_C:', _fHandle => ':Aexpr.SYM_C:' = _fHandle)'\xFE";
    z += "                        Aexpr.SYM_TYPE = Type_eBool\xFE";
    z += "                        Call Thenelse(Aexpr)\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"I_OPEN\"\xFE";
    z += "                        * Parse DICT/DATA into BEXPR, Filename into CEXPR\xFE";
    z += "                        *\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Bexpr = Expr(Type_estr, 1, C_comma:C_to:C_on:C_then:C_else:C_lbrace)\xFE";
    z += "                        Call Typestr(Type_dc, Bexpr)\xFE";
    z += "                        *\xFE";
    z += "                        If Tkno = C_comma Then\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            Cexpr = Expr(Type_estr, 1, C_to:C_on:C_then:C_else:C_lbrace)\xFE";
    z += "                            Call Typestr(Type_dc, Cexpr)\xFE";
    z += "                        Else\xFE";
    z += "                            Cexpr = Clone(Bexpr)\xFE";
    z += "                            Bexpr = {}\xFE";
    z += "                            Bexpr.SYM_C = '\"\"'\xFE";
    z += "                        End\xFE";
    z += "                        *\xFE";
    z += "                        * LOAD FILE VARIABLE\xFE";
    z += "                        *\xFE";
    z += "                        If Tkno <> C_to Then\xFE";
    z += "                            Aexpr = {}\xFE";
    z += "                            Aexpr.SYM_C='activeProcess.At_File'\xFE";
    z += "                            Aexpr.SYM_TYPE=Type_vstr\xFE";
    z += "                        Else\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            Aexpr = parsevar(1, 0, C_then:C_else:C_lbrace, 1)\xFE";
    z += "                            If Tkno = C_lparen Or Tkno = C_lbrack Or Tkno = mObjectDelemeter Then Call Err(\"Invalid reference variable. Too complicated\")\xFE";
    z += "                        End\xFE";
    z += "                        *\xFE";
    z += "                        * open bexpr, cexpr to aexpr\xFE";
    z += "                        *\xFE";
    z += "                        hasPromises[-1] = \"Uses I_OPEN\"\xFE";
    z += "                        Call Uses(Aexpr)\xFE";
    z += "                        Aexpr.SYM_C = 'await asyncOpen(':Bexpr.SYM_C:', ':Cexpr.SYM_C:', _fHandle => ':Aexpr.SYM_C:' = _fHandle)'\xFE";
    z += "                        Aexpr.SYM_TYPE = Type_eBool\xFE";
    z += "                        Call Thenelse(Aexpr)\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"I_MATREAD\" Or Tkstr = \"I_READ\" Or Tkstr = \"I_READV\" Or Tkstr = \"I_READXML\" Or Tkstr = \"I_READJSON\" Or Tkstr = \"I_READU\" Or Tkstr = \"I_READVU\" Or Tkstr = \"I_READXMLU\" Or Tkstr = \"I_READJSONU\" Or Tkstr = \"I_READBLK\"\xFE";
    z += "\xFE";
    z += "                        Rtype = Mid(Tkstr, 3) // Drop I_\xFE";
    z += "                        Dexpr = { SYM_C: 0 }\xFE";
    z += "                        *\xFE";
    z += "                        * READ CEXPR FROM AEXPR, BEXPR {, DEXPR} {, EEXPR}\xFE";
    z += "                        *\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Cexpr = parsevar(1, 1, C_from, 1)\xFE";
    z += "                        If Tkno <> C_from Then Call Err('FROM  expected') ; Return\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        \xFE";
    z += "                        // get file handle (Aexpr)\xFE";
    z += "                        Aexpr = Expr(Type_vstr, 1, C_comma:C_then:C_else:C_lbrace:C_locked)\xFE";
    z += "                        If Tkno = C_comma Then\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            Bexpr = Expr(Type_estr, 1, C_then:C_comma:C_else:C_locked)\xFE";
    z += "                        Else\xFE";
    z += "                            // default file handle\xFE";
    z += "                            If Rtype = \"READV\" Or Rtype = \"READVU\" Then\xFE";
    z += "                                Call Err('\",\"  expected')\xFE";
    z += "                                Return\xFE";
    z += "                            End\xFE";
    z += "                            Bexpr = Clone(Aexpr)\xFE";
    z += "                            Aexpr.SYM_C='activeProcess.At_File'\xFE";
    z += "                            Aexpr.SYM_TYPE=Type_vstr\xFE";
    z += "                        End\xFE";
    z += "                        \xFE";
    z += "                        // Get first AtnoNo or Start Offset (Dexpr)\xFE";
    z += "                        If Rtype = \"READV\" Or Rtype = \"READVU\" Or Rtype = \"READBLK\" Then\xFE";
    z += "                            If Tkno = C_comma Then\xFE";
    z += "                                Call Tcv(False)\xFE";
    z += "                                Dexpr = Expr(Type_eNum, 1, C_comma:C_then:C_else:C_lbrace:C_locked)\xFE";
    z += "                                Call Typenum(Type_vnum, Dexpr)\xFE";
    z += "                            \xFE";
    z += "                                If Rtype = \"READBLK\" Then\xFE";
    z += "                                    If Tkno = C_comma Then\xFE";
    z += "                                        Call Tcv(False)\xFE";
    z += "                                        Eexpr = Expr(Type_eNum, 1, C_then:C_else:C_lbrace:C_locked) // length\xFE";
    z += "                                    Else\xFE";
    z += "                                        Call Err('\",\"  length expected')\xFE";
    z += "                                        Return\xFE";
    z += "                                    End If\xFE";
    z += "                                    \xFE";
    z += "                                ElseIf Rtype = \"READBLK\" Then\xFE";
    z += "                                    Call Err('\",\"  offset expected')\xFE";
    z += "                                    Return\xFE";
    z += "                                End If\xFE";
    z += "                            Else\xFE";
    z += "                                Dexpr = Clone(Bexpr)\xFE";
    z += "                                Bexpr = Clone(Aexpr)\xFE";
    z += "                                Aexpr.SYM_C='activeProcess.At_File'\xFE";
    z += "                                Aexpr.SYM_TYPE=Type_estr\xFE";
    z += "                            End If\xFE";
    z += "                        End If\xFE";
    z += "                        *\xFE";
    z += "                        * Type em: * READ CEXPR FROM AEXPR, BEXPR {, DEXPR} {, EEXPR}\xFE";
    z += "                        *\xFE";
    z += "                        Call Typestr(Type_vstr, Aexpr) // What we are reading into\xFE";
    z += "                        Call Typestr(Type_vstr, Bexpr) // ItemID\xFE";
    z += "                        *\xFE";
    z += "                        * READ CEXPR FROM AEXPR, BEXPR {, DEXPR} {, EEXPR}\xFE";
    z += "                        *\xFE";
    z += "                        hasPromises[-1] = \"Uses READ\"\xFE";
    z += "                        Call Uses(Cexpr)\xFE";
    z += "                        \xFE";
    z += "                        Begin Case\xFE";
    z += "                            Case Rtype = \"READBLK\"\xFE";
    z += "                                opts = \"B\"\xFE";
    z += "                            Case Rtype = \"MATREAD\"\xFE";
    z += "                                opts = \"\"\xFE";
    z += "                            Case Rtype = \"READ\"\xFE";
    z += "                                opts = \"\"\xFE";
    z += "                            Case Rtype = \"READV\"\xFE";
    z += "                                 opts = \"V\"\xFE";
    z += "                            Case Rtype = \"READXML\"\xFE";
    z += "                                 opts = \"XML\"\xFE";
    z += "                            Case Rtype = \"READJSON\"\xFE";
    z += "                                 opts = \"JSON\"\xFE";
    z += "                            Case Rtype = \"MATREADU\"\xFE";
    z += "                                 opts = \"U\"\xFE";
    z += "                            Case Rtype = \"READU\"\xFE";
    z += "                                 opts = \"U\"\xFE";
    z += "                            Case Rtype = \"READVU\"\xFE";
    z += "                                 opts = \"VU\"\xFE";
    z += "                            Case Rtype = \"READXMLU\"\xFE";
    z += "                                 opts = \"XMLU\"\xFE";
    z += "                            Case Rtype = \"READJSONU\"\xFE";
    z += "                                 opts = \"JSONU\"\xFE";
    z += "                        End Case\xFE";
    z += "                        \xFE";
    z += "                        if opts = \"B\" Then\xFE";
    z += "                            Aexpr.SYM_C = 'await asyncReadBlk(':Aexpr.SYM_C:', ':Bexpr.SYM_C:', ':Dexpr.SYM_C:', ':Eexpr.SYM_C:', _data => ':Cexpr.SYM_C:' = _data)'\xFE";
    z += "                            hasPromises[-1] = \"Uses READBLK\"\xFE";
    z += "                        Else\xFE";
    z += "                            Aexpr.SYM_C = 'await asyncRead(':Aexpr.SYM_C:', ':Bexpr.SYM_C:', \"':Opts:'\", ':Dexpr.SYM_C:', _data => ':Cexpr.SYM_C:' = _data)'\xFE";
    z += "                            hasPromises[-1] = \"Uses READ\"\xFE";
    z += "                        End If\xFE";
    z += "                        \xFE";
    z += "                        Aexpr.SYM_TYPE = Type_eBool\xFE";
    z += "                        Call Thenelse(Aexpr)\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"I_WRITE\" Or Tkstr = \"I_WRITEXML\" Or Tkstr = \"I_WRITEJSON\" Or Tkstr = \"I_MATWRITE\" Or Tkstr = \"I_WRITEU\" Or Tkstr = \"I_WRITEV\" Or Tkstr = \"I_WRITEVU\" Or Tkstr = \"I_WRITEXMLU\" Or Tkstr = \"I_WRITEJSONU\" Or Tkstr = \"I_MATWRITEU\" Or Tkstr = \"I_WRITEBLK\"\xFE";
    z += "                        * i_write cexpr on aexpr, bexpr {, dexpr }\xFE";
    z += "                        *\xFE";
    z += "                        Rtype = Mid(Tkstr, 3) // drop i_\xFE";
    z += "                        \xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        \xFE";
    z += "                        // Item (Cexpr)\xFE";
    z += "                        Cexpr = Expr(Type_estr, 1, C_on:C_to)\xFE";
    z += "                        Call Typestr(Type_dc, Cexpr)\xFE";
    z += "                        \xFE";
    z += "                        If Tkno <> C_on And Tkno <> C_to Then Call Err('ON  expected') ; Return\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        \xFE";
    z += "                        // fileHande (Aexpr)\xFE";
    z += "                        Aexpr = Expr(Type_vstr, 1, C_comma:C_then:C_else:C_lbrace)\xFE";
    z += "                        If Tkno = C_comma Then\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            \xFE";
    z += "                            // ItemID (Bexpr)\xFE";
    z += "                            Bexpr = Expr(Type_estr, 1, C_comma:C_then:C_else:C_lbrace)\xFE";
    z += "                        Else\xFE";
    z += "                            If Right(Rtype, 1) = \"V\" Or Right(Rtype, 2) = \"VU\" Then\xFE";
    z += "                                Call Err('\",\"  expected')\xFE";
    z += "                                Return\xFE";
    z += "                            End\xFE";
    z += "                            Bexpr = Clone(Aexpr)\xFE";
    z += "                            Aexpr.SYM_C='activeProcess.At_File'\xFE";
    z += "                            Aexpr.SYM_TYPE=Type_estr\xFE";
    z += "                        End\xFE";
    z += "                        \xFE";
    z += "                        If Right(Rtype, 1) = \"V\" Or Right(Rtype, 2) = \"VU\" Or RType = \"WRITEBLK\" Then\xFE";
    z += "                            If Tkno = C_comma Then\xFE";
    z += "                                Call Tcv(False)\xFE";
    z += "                                Dexpr = Expr(Type_eNum, 1, C_comma:C_then:C_else:C_lbrace) // Atr (DExpr)\xFE";
    z += "                                    \xFE";
    z += "                            ElseIf Rtype = \"WRITEBLK\" Then\xFE";
    z += "                                Call Err('\",\"  offset expected')\xFE";
    z += "                                Return\xFE";
    z += "                                \xFE";
    z += "                            Else\xFE";
    z += "                                Dexpr = Clone(Bexpr)\xFE";
    z += "                                Bexpr = Clone(Aexpr)\xFE";
    z += "                                Aexpr.SYM_C='activeProcess.At_File'\xFE";
    z += "                                Aexpr.SYM_TYPE=Type_eNum\xFE";
    z += "                                Dexpr.SYM_C = \"0\"\xFE";
    z += "                            End\xFE";
    z += "                            Call Typenum(Type_vnum, Dexpr)\xFE";
    z += "                        Else\xFE";
    z += "                            Dexpr = { SYM_C:0 }\xFE";
    z += "                        End\xFE";
    z += "                        *\xFE";
    z += "                        * Type em: \xFE";
    z += "                        *\xFE";
    z += "                        Call Typestr(Type_estr, Aexpr) // fileHande\xFE";
    z += "                        Call Typestr(Type_estr, Bexpr) // ItemID\xFE";
    z += "                        *\xFE";
    z += "                        *    WRITE Cexpr ON aEXPR, Bexpr, Dexpr, Eexpr\xFE";
    z += "                        *\xFE";
    z += "                        Begin Case\xFE";
    z += "                            Case Rtype = \"WRITEBLK\"\xFE";
    z += "                                opts = \"B\"\xFE";
    z += "                            Case Rtype = \"MATWRITE\"\xFE";
    z += "                                 opts = \"\"\xFE";
    z += "                            Case Rtype = \"WRITE\"\xFE";
    z += "                                 opts = \"\"\xFE";
    z += "                            Case Rtype = \"WRITEV\"\xFE";
    z += "                                 opts = \"V\" \xFE";
    z += "                            Case Rtype = \"WRITEXML\"\xFE";
    z += "                                 opts = \"XML\"\xFE";
    z += "                            Case Rtype = \"WRITEJSON\"\xFE";
    z += "                                 opts = \"JSON\"\xFE";
    z += "                            Case Rtype = \"MATWRITEU\"\xFE";
    z += "                                 opts = \"U\"\xFE";
    z += "                            Case Rtype = \"WRITEU\"\xFE";
    z += "                                 opts = \"U\"\xFE";
    z += "                            Case Rtype = \"WRITEVU\"\xFE";
    z += "                                 opts = \"VU\"\xFE";
    z += "                            Case Rtype = \"WRITEXMLU\"\xFE";
    z += "                                 opts = \"XMLU\"\xFE";
    z += "                            Case Rtype = \"WRITEJSONU\"\xFE";
    z += "                                 opts = \"JSONU\"\xFE";
    z += "                        End Case\xFE";
    z += "                        \xFE";
    z += "                        hasPromises[-1] = \"Uses I_WRITE\"\xFE";
    z += "                        \xFE";
    z += "                        // i_write cexpr on aexpr, bexpr {, dexpr }\xFE";
    z += "                        Aexpr.SYM_C = 'await asyncWrite(':Cexpr.SYM_C:', ':Aexpr.SYM_C:', ':Bexpr.SYM_C:',\"':opts:'\", ':Dexpr.SYM_C:')'\xFE";
    z += "                        Aexpr.SYM_TYPE = Type_eBool\xFE";
    z += "                        Call Thenelse(Aexpr)\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"I_DELETE\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Aexpr = Expr(Type_estr, 1, C_comma)\xFE";
    z += "                        If Tkno <> C_comma Then\xFE";
    z += "                            Bexpr = Clone(Aexpr)\xFE";
    z += "                            Aexpr = {}\xFE";
    z += "                            Aexpr.SYM_C='activeProcess.At_File'\xFE";
    z += "                        Else\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            Bexpr = Expr(Type_estr, 1, '')\xFE";
    z += "                            Call Typenum(Type_eNum, Aexpr)\xFE";
    z += "                        End\xFE";
    z += "                        Call Typestr(Type_dc, Bexpr)\xFE";
    z += "                        hasPromises[-1] = \"Uses I_DELETE\"\xFE";
    z += "                        Aexpr.SYM_C = 'await asyncDelete(':Aexpr.SYM_C:', ':Bexpr.SYM_C:')'\xFE";
    z += "                        Call Thenelse(Aexpr)\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"I_SELECT\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        \xFE";
    z += "                        ;* Sleect Aexpr { WHERE CEXPR } { TO DEXPR }\xFE";
    z += "                        ;* Select Bexpr From Aexpr { WHERE CEXPR } { TO DEXPR } { THEN ELSE }\xFE";
    z += "                        \xFE";
    z += "                        Aexpr = {} // fHandle\xFE";
    z += "                        Aexpr.SYM_C='activeProcess.At_File'\xFE";
    z += "                        Aexpr.SYM_TYPE=Type_estr\xFE";
    z += "                        \xFE";
    z += "                        Bexpr = {} // Columns\xFE";
    z += "                        Bexpr.SYM_C=\"''\"\xFE";
    z += "                        Bexpr.SYM_TYPE=Type_estr\xFE";
    z += "                        \xFE";
    z += "                        Cexpr = {} // Where\xFE";
    z += "                        Cexpr.SYM_C=\"''\"\xFE";
    z += "                        Cexpr.SYM_TYPE=Type_estr\xFE";
    z += "                        \xFE";
    z += "                        Hasto = 0\xFE";
    z += "                        \xFE";
    z += "                        Aexpr = Expr(Type_estr, 1, C_to)\xFE";
    z += "                        Call Typestr(Type_estr, Aexpr)\xFE";
    z += "                        \xFE";
    z += "                        * Is AEXPR a columns list (FROM following) or a F_FILE?\xFE";
    z += "                        If Tkno = C_from Then\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            Bexpr.SYM_C = Aexpr.SYM_C\xFE";
    z += "                            Aexpr = Expr(Type_estr, 1, C_to)\xFE";
    z += "                            Call Typestr(Type_estr, Aexpr)\xFE";
    z += "                        Else\xFE";
    z += "                            Bexpr.SYM_C = \"''\"\xFE";
    z += "                        End\xFE";
    z += "                        \xFE";
    z += "                        Dexpr = { SYM_C: 'odbActiveSelectList' }\xFE";
    z += "                        Loop While Tkno = C_where Or Tkno = C_to Do\xFE";
    z += "                            If Tkno = C_where Then\xFE";
    z += "                                Call Tcv(False) ;* Skip Where\xFE";
    z += "                                Cexpr = Expr(Type_estr, 1, C_to)\xFE";
    z += "                                Call Typestr(Type_estr, Cexpr)\xFE";
    z += "                            End\xFE";
    z += "                            \xFE";
    z += "                            If Tkno = C_to Then\xFE";
    z += "                                Call Tcv(False)\xFE";
    z += "                                Dexpr = parsevar(1, 0, C_then:C_else:C_lbrace, 1)\xFE";
    z += "                                If Tkno = C_lparen Or Tkno = C_lbrack Or Tkno = mObjectDelemeter Then Call Err(\"Invalid reference variable. Too complicated\")\xFE";
    z += "                                Hasto = 1\xFE";
    z += "                                Call Uses(Dexpr)\xFE";
    z += "                            End\xFE";
    z += "                        Repeat\xFE";
    z += "\xFE";
    z += "                        hasPromises[-1] = \"Uses I_SELECT\"\xFE";
    z += "                        \xFE";
    z += "                        //  Select Bexpr( Columns ) from fHandle (Aexpr)  Where (Cexpr)\xFE";
    z += "                        Aexpr.SYM_C = 'await asyncSelect(':Bexpr.SYM_C:', ':Aexpr.SYM_C:', ':Cexpr.SYM_C:', _selectList => ':Dexpr.SYM_C:' = _selectList)'\xFE";
    z += "                        Aexpr.SYM_TYPE = Type_eBool\xFE";
    z += "                        Call Thenelse(Aexpr)\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"I_CLOSE\"\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Aexpr = Expr(Type_eNum, 1, '')\xFE";
    z += "                        Call Typestr(Type_estr, Aexpr)\xFE";
    z += "                        OC := '// Close(':Aexpr.SYM_C:'); '\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"I_CLEARFILE\" Or Tkstr = \"I_CLEARTABLE\" ;* Tablename Or fHandle (Same In this Case)\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        If Index(La:C_to,Tkno,1) Then\xFE";
    z += "                            Aexpr = {}\xFE";
    z += "                            Aexpr.SYM_C='activeProcess.At_File'\xFE";
    z += "                            Aexpr.SYM_TYPE=Type_eNum\xFE";
    z += "                        Else\xFE";
    z += "                            Aexpr = Expr(Type_estr, 1, '')\xFE";
    z += "                            Call Typestr(Type_estr, Aexpr)\xFE";
    z += "                        End\xFE";
    z += "                        hasPromises[-1] = \"Uses asyncClearTable\"\xFE";
    z += "                        Aexpr.SYM_C = 'await asyncClearTable(':Aexpr.SYM_C:')'\xFE";
    z += "                        Aexpr.SYM_TYPE = Type_eBool\xFE";
    z += "                        Call Thenelse(Aexpr)\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"I_DELETEFILE\" Or Tkstr = \"I_DELETETABLE\" ;* Tablename Or fHandle (Same In this Case)\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        If Index(La:C_to,Tkno,1) Then\xFE";
    z += "                            Aexpr = {}\xFE";
    z += "                            Aexpr.SYM_C='activeProcess.At_File'\xFE";
    z += "                            Aexpr.SYM_TYPE=Type_estr\xFE";
    z += "                        Else\xFE";
    z += "                            Aexpr = Expr(Type_estr, 1, '')\xFE";
    z += "                            Call Typestr(Type_estr, Aexpr)\xFE";
    z += "                        End\xFE";
    z += "                        hasPromises[-1] = \"Uses I_DELETEFILE\"\xFE";
    z += "                        Aexpr.SYM_C = 'await asyncDeleteTable(':Aexpr.SYM_C:')'\xFE";
    z += "                        Aexpr.SYM_TYPE = Type_eBool\xFE";
    z += "                        Call Thenelse(Aexpr)\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"I_LISTFILES\" ;* Ilistfiles { TO } List\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        If Tkno = C_to Then Call Tcv(False)\xFE";
    z += "                        \xFE";
    z += "                        Aexpr = parsevar(1, 0, C_then:C_else:C_lbrace, 1)\xFE";
    z += "                        If Tkno = C_lparen Or Tkno = C_lbrack Or Tkno = mObjectDelemeter Then Call Err(\"Invalid reference variable. Too complicated\")\xFE";
    z += "                        \xFE";
    z += "                        hasPromises[-1] = \"Uses I_LISTFILES\"\xFE";
    z += "                        Call Uses(Aexpr)\xFE";
    z += "                        Aexpr.SYM_C = 'await asyncListFiles(_fileList => ':Aexpr.SYM_C:' = _fileList)'\xFE";
    z += "                        Aexpr.SYM_TYPE = Type_eBool\xFE";
    z += "                        Call Thenelse(Aexpr)\xFE";
    z += "\xFE";
    z += "                    Case Tkno = C_at\xFE";
    z += "                        * Check for @SERVER, @EMAIL, @xxx\xFE";
    z += "                        Htk = savetk()\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        \xFE";
    z += "                        If Tkstr = \"EMAIL\" Then\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            \xFE";
    z += "                            If Tkstr = mObjectDelemeter Then Call Tcv(False)\xFE";
    z += "                            if TkStr = \"SEND\" Then Call Tcv(False)\xFE";
    z += "                            If Tkno = C_lparen Then Call Tcv(False)\xFE";
    z += "                            * == Remove Everything Up To this point, So That What Remains We Be Parameterlist\xFE";
    z += "                            Tkline = Mid(Tkline, Tkstartpos)\xFE";
    z += "                            Tkpos = 1; Tkno = ''; Call Tcv(False)\xFE";
    z += "                            If Trim(Oc) # \"\" Then Ocpgm[-1] = Oc; Oc = \"\"\xFE";
    z += "                            \xFE";
    z += "                            Loop\xFE";
    z += "                                Aexpr = Expr(Type_vstr, 1, C_comma:C_to:C_then:C_else:C_lbrace)\xFE";
    z += "                            while Tkno = C_comma do\xFE";
    z += "                                Call Tcv(False)\xFE";
    z += "                            Repeat\xFE";
    z += "                            \xFE";
    z += "                            Hasthenelse = Tkno = C_then Or Tkno = C_else Or Tkno = C_lbrace\xFE";
    z += "                            Nextcmd = Mid(Tkline, Tkstartpos)\xFE";
    z += "                            Params = Mid(Tkline, 1, Tkstartpos-1)\xFE";
    z += "                            \xFE";
    z += "                            ;* Build Subsitution\xFE";
    z += "                            if hasthenelse then\xFE";
    z += "                                Tkline = \"If @JSB_ODB.EMAIL(\":Params:\") \":Nextcmd \xFE";
    z += "                            Else\xFE";
    z += "                                Tkline = \"If @JSB_ODB.EMAIL(\":Params:\") Else Stop @Errors; \":Nextcmd \xFE";
    z += "                            End If\xFE";
    z += "                            \xFE";
    z += "                            ;* Re-Parse\xFE";
    z += "                            Oc = \"\"; Tkpos = 1; Tkno = ''; Call Tcv(False)\xFE";
    z += "                            \xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            Aexpr = Expr(Type_estr, 1, C_then:C_else:C_lbrace)\xFE";
    z += "                            Call Thenelse(Aexpr)\xFE";
    z += "\xFE";
    z += "                        ElseIf Tkstr = \"SERVER\" Then\xFE";
    z += "                            Call Tcv(False)\xFE";
    z += "                            If Tkstr = mObjectDelemeter Then Call Tcv(False) Else Call Err(\". expected\")\xFE";
    z += "                            \xFE";
    z += "                            If Tkstr = \"CLOSE\" Then\xFE";
    z += "                                Call Tcv(False)\xFE";
    z += "                                OC := \"jsbClose(); \"\xFE";
    z += "                                \xFE";
    z += "                            ElseIf Tkstr = \"END\" Then\xFE";
    z += "                                Call Tcv(False)\xFE";
    z += "                                OC := 'At_Server.End(); '\xFE";
    z += "                                \xFE";
    z += "                            ElseIf Tkstr = \"TRANSFER\" Then\xFE";
    z += "                                Call Restoret(Htk) ;* Back Up To @\xFE";
    z += "                                Call defaultExpr()\xFE";
    z += "                                \xFE";
    z += "                            ElseIf Tkstr = \"FLUSH\" Or Tkstr = \"REFRESH\" Then\xFE";
    z += "                                Call Tcv(False)\xFE";
    z += "                                OC := 'FlushHTML();'\xFE";
    z += "                                \xFE";
    z += "                            ElseIf Tkstr = \"PAUSE\" Then\xFE";
    z += "                                Call Tcv(False)\xFE";
    z += "                                OC := 'await At_Server.asyncPause(me); '\xFE";
    z += "                                hasPromises[-1] = \"Uses @SERVER.PAUSE\"\xFE";
    z += "                                \xFE";
    z += "                            Else\xFE";
    z += "                                Call Err(\"SERVER.END expected\")\xFE";
    z += "                            End If\xFE";
    z += "                            If Tkno = C_lparen Then\xFE";
    z += "                                Call Tcv(False)\xFE";
    z += "                                If Tkno = C_rparen Then Call Tcv(False) Else Call Err(\") expected\")\xFE";
    z += "                            End If\xFE";
    z += "                        Else\xFE";
    z += "                        \xFE";
    z += "                            Call Restoret(Htk) ;* Back Up To @\xFE";
    z += "                            Call defaultExpr()\xFE";
    z += "                        End If\xFE";
    z += "                        \xFE";
    z += "                    Case Tkstr = \"FUNC\" ; Null\xFE";
    z += "                    Case Tkstr = \"SUB\" ; Null\xFE";
    z += "                    Case Tkstr = \"SUBROUTINE\" ; Null\xFE";
    z += "                    Case Tkstr = \"FUNCTION\" ; Null\xFE";
    z += "                    Case Tkstr = \"RESTFUL\" And UCase(Left(Trim(Tkline[Tkpos, 18]), 8)) = \"FUNCTION\" ; Null\xFE";
    z += "                    Case Tkstr = \"PICK\" And UCase(Left(Trim(Tkline[Tkpos, 18]), 8)) = \"FUNCTION\" ; Null\xFE";
    z += "                        \xFE";
    z += "                    Case 1\xFE";
    z += "                        Call defaultExpr()\xFE";
    z += "\xFE";
    z += "                End Case\xFE";
    z += "            Next\xFE";
    z += "        End\xFE";
    z += "\xFE";
    z += "    While Tkno = C_semi And Instr(Lb, C_semi) = 0 Do\xFE";
    z += "        Call Tcv(False)\xFE";
    z += "    Repeat\xFE";
    z += "    La = La[1,Len(La)-1]\xFE";
    z += "End Subroutine\xFE";
    z += "\xFE";
    z += "Subroutine defaultExpr()\xFE";
    z += "*\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "    \xFE";
    z += "    FuncName = tkstr\xFE";
    z += "    Locate FuncName In UC_externals_purejs_list Setting isExternalFunc Else isExternalFunc = 0\xFE";
    z += "    R = savetk()\xFE";
    z += "    Aexpr = parsevar(2, 1, C_equal, 0)\xFE";
    z += "    \xFE";
    z += "    if isExternalFunc and Tkno <> C_lparen Then\xFE";
    z += "        // We are using this external function name as a variable.  Make it a local var if we haven't already used it\xFE";
    z += "        AlreadyUsed = False\xFE";
    z += "        for each xSub in CallList \xFE";
    z += "            xSub = dropIfRight(xSub, \"_\") ;* drop \"_fnc\"\xFE";
    z += "            if xSub = FuncName Then AlreadyUsed = True; Break\xFE";
    z += "        next\xFE";
    z += "        \xFE";
    z += "        if AlreadyUsed Then\xFE";
    z += "            Call Err(\"'\":FuncName:\"' is gobally defined as an external function, but used here as a local variable.  Redefine locally with $options local \":FuncName)\xFE";
    z += "        Else\xFE";
    z += "            isExternalFunc = False\xFE";
    z += "        end if\xFE";
    z += "    end if\xFE";
    z += "    \xFE";
    z += "    If Instr(\" =<+-/*%:\", Tkstr) > 1 Then\xFE";
    z += "        Call Restoret(R)\xFE";
    z += "        Call Assment()\xFE";
    z += "        \xFE";
    z += "    ElseIf isExternalFunc Then\xFE";
    z += "        Call Restoret(R)\xFE";
    z += "        Aexpr = Expr(Type_estr, 1, \"\")\xFE";
    z += "        OC := Aexpr.SYM_C:\";\"\xFE";
    z += "\xFE";
    z += "    ElseIf Tkstr = mObjectDelemeter Or Tkno = C_lbrack Or Tkno = C_lparen Then\xFE";
    z += "        ' Load object address\xFE";
    z += "        IgnoreErrors += 1\xFE";
    z += "        Call ObjectParse(Aexpr)\xFE";
    z += "        IgnoreErrors -= 1\xFE";
    z += "        \xFE";
    z += "        ' assignment ?\xFE";
    z += "        If Instr(\" =<+-/*%:\", Tkstr) > 1 Then\xFE";
    z += "            Call Restoret(R)\xFE";
    z += "            Call Assment()\xFE";
    z += "        Else\xFE";
    z += "            Call Restoret(R)\xFE";
    z += "            \xFE";
    z += "            Aexpr = Expr(Type_estr, 1, \"\")\xFE";
    z += "            OC := Aexpr.SYM_C:\";\"\xFE";
    z += "        End If\xFE";
    z += "        \xFE";
    z += "    Else\xFE";
    z += "        Call Restoret(R)\xFE";
    z += "        Call Err(\"Unknown command: \":Tkstr)\xFE";
    z += "    End If\xFE";
    z += "End Subroutine\xFE";
    z += "\xFE";
    z += "Subroutine GenLoop(byval Wtkno, byval Hascond, byval Ignored, ByVal Cexpr, byval Loopblock, byval Doblock, byval Looplbls, byval Dolbls)\xFE";
    z += "*\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "    \xFE";
    z += "    if Right(Doblock, 1) = \";\" Then Doblock = RTrim(Left(Doblock, Len(Doblock) - 1))\xFE";
    z += "    if Right(Loopblock, 1) = \";\" Then Loopblock = RTrim(Left(Loopblock, Len(Loopblock) - 1))\xFE";
    z += "    \xFE";
    z += "    If Hascond Then Call Makenum(Type_vnum, Cexpr)\xFE";
    z += "    If Looplbls Or Dolbls Then\xFE";
    z += "        * LOOP LOOPBLOCK WHILE COND DOBLOCK REPEAT ->\xFE";
    z += "        *\xFE";
    z += "        * CYCLELBL:\xFE";
    z += "        *   LOOPBLOCK\xFE";
    z += "        *   IF !CEXPR GOTO EXITLBL\xFE";
    z += "        *   DOBLOCK\xFE";
    z += "        *   GOTO LOOPTOP\xFE";
    z += "        * EXITLBL:\xFE";
    z += "        *\xFE";
    z += "        *   \xFE";
    z += "        Cyclelbl = \"_topOfLoop_\":Nxtlbl\xFE";
    z += "        Exitlbl = \"_exitFor_\":Nxtlbl; Nxtlbl = Nxtlbl + 1\xFE";
    z += "        *\xFE";
    z += "        Call Deflbl(Cyclelbl, 0)\xFE";
    z += "        *\xFE";
    z += "        Loopblock = Change(Loopblock, Chr(2):'break' :Chr(2), '{ gotoLabel = \"':Exitlbl:'\"; continue atgoto }')\xFE";
    z += "        Loopblock = Change(Loopblock, Chr(2):'continue' :Chr(2), '{ gotoLabel = \"':Cyclelbl:'\"; continue atgoto }')\xFE";
    z += "        Loopblock = Change(Loopblock, Am:\"   \", Am); Loopblock = Change(Loopblock,'case \"_', Space(3):'case \"_')\xFE";
    z += "        Oc<-1> = Loopblock\xFE";
    z += "        If Hascond Then\xFE";
    z += "            If Wtkno = C_while Then\xFE";
    z += "                Oc<-1> = Space(Indent+3):'if (Not(':Cexpr.SYM_C:')) { gotoLabel = \"':Exitlbl:'\"; continue atgoto }; '\xFE";
    z += "            Else\xFE";
    z += "                Oc<-1> = Space(Indent+3):'if (':Cexpr.SYM_C:') { gotoLabel = \"':Exitlbl:'\"; continue atgoto }; '\xFE";
    z += "            End If\xFE";
    z += "        End If\xFE";
    z += "        Doblock = Change(Doblock, Chr(2):'break' :Chr(2), '{ gotoLabel = \"':Exitlbl:'\"; continue atgoto }')\xFE";
    z += "        Doblock = Change(Doblock, Chr(2):'continue' :Chr(2), '{ gotoLabel = \"':Cyclelbl:'\"; continue atgoto }')\xFE";
    z += "        Doblock = Change(Doblock, Am:\"   \", Am); Doblock = Change(Doblock,'case \"_', Space(3):'case \"_')\xFE";
    z += "        Oc<-1> = Doblock\xFE";
    z += "        *\xFE";
    z += "        Oc<-1> = Space(Indent):'gotoLabel = \"':Cyclelbl:'\"; continue atgoto; '\xFE";
    z += "        *\xFE";
    z += "        Call Deflbl(Exitlbl, 0)\xFE";
    z += "    Else\xFE";
    z += "        * NOT LABELS\xFE";
    z += "        Doblock = Change(Doblock, Chr(2):'break' :Chr(2), \"break\")\xFE";
    z += "        Doblock = Change(Doblock, Chr(2):'continue' :Chr(2), \"continue\")\xFE";
    z += "\xFE";
    z += "        \xFE";
    z += "        If Loopblock Then\xFE";
    z += "            Loopblock = Change(Loopblock, Chr(2):'break' :Chr(2), \"break\")\xFE";
    z += "            Loopblock = Change(Loopblock, Chr(2):'continue' :Chr(2), \"continue\")\xFE";
    z += "            If Hascond Then\xFE";
    z += "                If Doblock Then\xFE";
    z += "                    * LOOP LOOPBLOCK WHILE COND DOBLOCK REPEAT -> while (true) { LOOPBLOCK; if (cond) break; DOBLOCK }\xFE";
    z += "                    Oc<-1> = Space(Indent):\"while (true) {\":Am:Loopblock\xFE";
    z += "                    If Wtkno = C_while Then\xFE";
    z += "                        Oc<-1> = Space(Indent+3):'if (Not(':Cexpr.SYM_C:')) break; '\xFE";
    z += "                    Else\xFE";
    z += "                        Oc<-1> = Space(Indent+3):'if (':Cexpr.SYM_C:') break; '\xFE";
    z += "                    End If\xFE";
    z += "                    Oc<-1> = Doblock\xFE";
    z += "                    Oc<-1> = Space(Indent):\"} \"\xFE";
    z += "                Else\xFE";
    z += "                    * LOOP LOOPBLOCK WHILE COND REPEAT ->  do { LOOPBLOCK } while (cond);\xFE";
    z += "                    Oc<-1> = Space(Indent):\"do {\":Am:Loopblock:Am:Space(Indent):\"} \"\xFE";
    z += "                    If Wtkno = C_while Then\xFE";
    z += "                        Oc<-1> = Space(Indent):'while (':Cexpr.SYM_C:'); '\xFE";
    z += "                    Else\xFE";
    z += "                        Oc<-1> = Space(Indent):'while (Not(':Cexpr.SYM_C:')); '\xFE";
    z += "                    End If\xFE";
    z += "                End\xFE";
    z += "            Else\xFE";
    z += "                * LOOP LOOPBLOCK REPEAT ->  while (true) { LOOPBLOCK }\xFE";
    z += "                Oc<-1> = Space(Indent):\"while (true) {\":Am:Loopblock:Am:Space(Indent):\"} \"\xFE";
    z += "            End If\xFE";
    z += "        Else\xFE";
    z += "            If Hascond Then\xFE";
    z += "                * LOOP WHILE COND DOBLOCK REPEAT -> while (cond) { doblock }\xFE";
    z += "                If Wtkno = C_while Then\xFE";
    z += "                    Oc<-1> = Space(Indent):'while (':Cexpr.SYM_C:') {'\xFE";
    z += "                Else\xFE";
    z += "                    Oc<-1> = Space(Indent):'while (Not(':Cexpr.SYM_C:')) {'\xFE";
    z += "                End If\xFE";
    z += "                Oc<-1> = Doblock\xFE";
    z += "                Oc<-1> = Space(Indent):\"} \"\xFE";
    z += "            Else\xFE";
    z += "                * LOOP REPEAT\xFE";
    z += "                Oc<-1> = Space(Indent+3):'while (true) { } '\xFE";
    z += "            End If\xFE";
    z += "        End\xFE";
    z += "    End \xFE";
    z += "End Subroutine"
    window.cached_jsb2js["states"] = z;
    var z = "*********************************************************************************************************************\xFE";
    z += "Subroutine Tcv(byval InExpression)\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "    Dim C2 As Char\xFE";
    z += "    Dim Pau As String\xFE";
    z += "    Dim C3 As String\xFE";
    z += "    Dim C As Char\xFE";
    z += "    Dim Lib As String\xFE";
    z += "    Dim I As Integer\xFE";
    z += "    Dim Epos As Integer\xFE";
    z += "    Dim Cvt As Integer\xFE";
    z += "    Dim Tkstrlen As Integer\xFE";
    z += "    Dim Si As Integer\xFE";
    z += "*\xFE";
    z += "* Pre-Compile a BASIC program\xFE";
    z += "*\xFE";
    z += "    If Tkno = C_sm Then Return\xFE";
    z += "*\xFE";
    z += "    If Tkno = C_am Then\xFE";
    z += "        Tkam += 1\xFE";
    z += "        Tkpos = 1\xFE";
    z += "        If Tkam > UBound(Itemsrc) Then\xFE";
    z += "            Tkno = C_sm\xFE";
    z += "            Tkline = \"\"\xFE";
    z += "            Tkstr = ''\xFE";
    z += "            Otkstr = Tkstr\xFE";
    z += "            Return\xFE";
    z += "        End\xFE";
    z += "        Tkline = Itemsrc[Tkam]\xFE";
    z += "    End\xFE";
    z += "*\xFE";
    z += "    Tkstartpos = Tkpos\xFE";
    z += "*\xFE";
    z += "* SKIP WHITE SPACE\xFE";
    z += "*\xFE";
    z += "    Spaces = Tkstartpos\xFE";
    z += "    Loop\xFE";
    z += "        C = Seq(Tkline[Tkstartpos,1])\xFE";
    z += "    While C = 32 Or C = 9 Or C = 8203 Do\xFE";
    z += "        Tkstartpos = Tkstartpos + 1\xFE";
    z += "    Repeat\xFE";
    z += "    Spaces = Tkstartpos - Spaces\xFE";
    z += "*\xFE";
    z += "    C = Tkline[Tkstartpos,1]\xFE";
    z += "    If C = '' Then\xFE";
    z += "        Tkno = C_am\xFE";
    z += "        Tkstr = ''\xFE";
    z += "        Otkstr = Tkstr\xFE";
    z += "        Return\xFE";
    z += "    End\xFE";
    z += "*\xFE";
    z += "* CHECK FOR STRINGS\xFE";
    z += "*\xFE";
    z += "    If C= \"'\" Or C = '\"' Or C = \"`\" Then\xFE";
    z += "        If C = \"`\" Or Mr83 Then Ec = Chr(255) Else Ec = `\\`\xFE";
    z += "        Tkpos = Tkstartpos\xFE";
    z += "        Tkstr = C\xFE";
    z += "        Loop\xFE";
    z += "            TkPos += 1\xFE";
    z += "            I = Instr(Tkpos, Tkline, C)\xFE";
    z += "            J = Instr(Tkpos, Tkline, Ec)\xFE";
    z += "\xFE";
    z += "            If I = 0 Then I = Len(Tkline) + 1\xFE";
    z += "            If J = 0 Then J = Len(Tkline) + 1\xFE";
    z += "            If J < I And Not(Simplestrings) Then I = J\xFE";
    z += "\xFE";
    z += "            Tkstr = Tkstr:Tkline[Tkpos,I-Tkpos]\xFE";
    z += "            Tkpos = I\xFE";
    z += "\xFE";
    z += "            C2 = Tkline[Tkpos,1]\xFE";
    z += "            If C2 = Ec Then\xFE";
    z += "                TkPos += 1\xFE";
    z += "                C2 = C2:Tkline[Tkpos, 1]\xFE";
    z += "            Else\xFE";
    z += "                If C2 = C Then\xFE";
    z += "                    Tkstr = Tkstr:C2\xFE";
    z += "                    Break\xFE";
    z += "                End If\xFE";
    z += "            End If\xFE";
    z += "\xFE";
    z += "            Tkstr = Tkstr:C2\xFE";
    z += "\xFE";
    z += "            // End of the line?\xFE";
    z += "            If C2 = \"\" Then\xFE";
    z += "                ' Did we start with ' or \"?\xFE";
    z += "                If C <> \"`\" Then\xFE";
    z += "                    ' If what preceeded the string was a CR, AM, ;, THEN, ELSE - it's a comment\xFE";
    z += "                    Si = Tkstartpos - 1\xFE";
    z += "                    Loop While True Do\xFE";
    z += "                        If Si <= 0 Then Break\xFE";
    z += "                        C2 = Mid(Tkline, Si, 1)\xFE";
    z += "                        If C2 = \";\" Then Break\xFE";
    z += "                        If C2 = \")\" Then Break\xFE";
    z += "                        If C2 <> \" \" Then\xFE";
    z += "                            Tkstr = Tkstr:C\xFE";
    z += "                            If InExpression Then Call Err(\"Missing string terminator: \":C)\xFE";
    z += "                            Break\xFE";
    z += "                        End If\xFE";
    z += "                        Si = Si - 1\xFE";
    z += "                    Repeat\xFE";
    z += "                    Break\xFE";
    z += "                End If\xFE";
    z += "                \xFE";
    z += "                Tkam += 1\xFE";
    z += "                Tkstr = Tkstr:Chr(13):Chr(10)\xFE";
    z += "                If Tkam > UBound(Itemsrc) Then\xFE";
    z += "                    Call Err(\"Missing string terminator: \":C)\xFE";
    z += "                    Break\xFE";
    z += "                End If\xFE";
    z += "                Tkline = Itemsrc[Tkam]\xFE";
    z += "                Tkpos = 0\xFE";
    z += "            End If\xFE";
    z += "        While 1 Do Repeat\xFE";
    z += "\xFE";
    z += "        TkPos += 1\xFE";
    z += "        Tkno = C_str\xFE";
    z += "        Otkstr = Tkstr\xFE";
    z += "        Return\xFE";
    z += "    End\xFE";
    z += "*\xFE";
    z += "* CHECK FOR SYMBOLS\xFE";
    z += "*\xFE";
    z += "* Changed $ to !, and _ to ! to allow identifiers to start with _ \xFE";
    z += "*              !  $      !        ` \" '  \xFE";
    z += "    Si = Index(Vm:\"!@#!%^&*()!+-={}~[]!:!;'<>?,./|\",C,1)\xFE";
    z += "    If Si Then\xFE";
    z += "        Tkpos = Tkstartpos + 1\xFE";
    z += "        Tkstr = C\xFE";
    z += "        Tkno = Char(Si + Seq(C_vm)-1)\xFE";
    z += "        Otkstr = Tkstr\xFE";
    z += "\xFE";
    z += "        * CHANGE != TO \"<>\"\xFE";
    z += "        If C = \"!\" Then\xFE";
    z += "            If Tkline[Tkpos, 1] = \"=\" Then\xFE";
    z += "                TkPos += 1\xFE";
    z += "                Tkstr = \"#\"\xFE";
    z += "                Tkno = C_pound\xFE";
    z += "                Otkstr = Tkstr\xFE";
    z += "            End If\xFE";
    z += "        End Else If C = \"&\" Then\xFE";
    z += "            If Tkline[Tkpos, 1] = \"&\" Then\xFE";
    z += "                TkPos += 1\xFE";
    z += "                Tkstr = \"AND\"\xFE";
    z += "                Tkno = C_and\xFE";
    z += "                Otkstr = Tkstr\xFE";
    z += "            End If\xFE";
    z += "        End Else If C = \"|\" Then\xFE";
    z += "            If Tkline[Tkpos, 1] = \"|\" Then\xFE";
    z += "                TkPos += 1\xFE";
    z += "                Tkstr = \"OR\"\xFE";
    z += "                Tkno = C_or\xFE";
    z += "                Otkstr = Tkstr\xFE";
    z += "            End If\xFE";
    z += "        End Else If C = \"=\" Then\xFE";
    z += "            If Tkline[Tkpos, 1] = \"=\" Then\xFE";
    z += "                TkPos += 1\xFE";
    z += "                Otkstr = Tkstr\xFE";
    z += "            End If\xFE";
    z += "            \xFE";
    z += "        End Else If C = \"/\" Then\xFE";
    z += "        \xFE";
    z += "            // Comments?\xFE";
    z += "            C2 = Tkline[Tkpos,1]\xFE";
    z += "            If C2 = \"/\" Then\xFE";
    z += "                TkPos += 1\xFE";
    z += "                Tkstr = \"//\"\xFE";
    z += "                Tkno = C_dblSlash\xFE";
    z += "\xFE";
    z += "            ElseIf C2 = \"*\" Then\xFE";
    z += "                TkPos += 1\xFE";
    z += "                Tkstr = \"/*\"\xFE";
    z += "                Dim Cmts As Array = []\xFE";
    z += "            \xFE";
    z += "                Loop While True Do\xFE";
    z += "                    C2 = Tkline[Tkpos,1]\xFE";
    z += "                    Tkstr := C2\xFE";
    z += "                    \xFE";
    z += "                    ' End at */?\xFE";
    z += "                    If C2 = \"*\" And Tkline[Tkpos+1,1] = \"/\" Then\xFE";
    z += "                        Tkstr = Join(Cmts, crlf()):\"*/\"\xFE";
    z += "                        Tkpos = Tkpos + 2\xFE";
    z += "                        Call Tcv(False)\xFE";
    z += "                        Return\xFE";
    z += "\xFE";
    z += "                    ElseIf C2 = \"\" Then\xFE";
    z += "                        Tkam += 1\xFE";
    z += "                        Cmts[-1] = Tkstr\xFE";
    z += "                        TkStr = \"\"\xFE";
    z += "                        \xFE";
    z += "                        If Tkam > UBound(Itemsrc) Then \xFE";
    z += "                            TkStr = Join(Cmts, crlf())\xFE";
    z += "                            Break\xFE";
    z += "                        end if\xFE";
    z += "                        \xFE";
    z += "                        Tkline = Itemsrc[Tkam]\xFE";
    z += "                        Tkpos = 0\xFE";
    z += "                        Tkstr := \"\"\xFE";
    z += "                    End If\xFE";
    z += "\xFE";
    z += "                    TkPos += 1\xFE";
    z += "                Repeat\xFE";
    z += "                \xFE";
    z += "                if InExpression Then\xFE";
    z += "                    Tkno = C_CmtBlock\xFE";
    z += "                Else\xFE";
    z += "                    Oc := Tkstr\xFE";
    z += "                    Call Tcv(false)\xFE";
    z += "                end if\xFE";
    z += "            Else\xFE";
    z += "                Tkno = C_fslash\xFE";
    z += "            End If\xFE";
    z += "        End If\xFE";
    z += "\xFE";
    z += "        Return\xFE";
    z += "    End\xFE";
    z += "*\xFE";
    z += "* CHECK FOR NUMBERS\xFE";
    z += "*\xFE";
    z += "    If Index(\" 0123456789\", C, 1) > 1 Then\xFE";
    z += "        Tkpos = Tkstartpos\xFE";
    z += "        Loop\xFE";
    z += "            TkPos += 1\xFE";
    z += "            C = Tkline[Tkpos,1]\xFE";
    z += "        While Index(\" 0123456789\", C, 1) > 1 And C # '' Do Repeat\xFE";
    z += "        *\xFE";
    z += "        Tkstr = Tkline[Tkstartpos,Tkpos-Tkstartpos]\xFE";
    z += "        Tkno = C_number\xFE";
    z += "        Otkstr = Tkstr\xFE";
    z += "        Return\xFE";
    z += "    End\xFE";
    z += "*\xFE";
    z += "* MUST BE IDENTIFIER\xFE";
    z += "    Tkpos = Tkstartpos\xFE";
    z += "    Loop\xFE";
    z += "        Tkpos=Tkpos+1\xFE";
    z += "        C = Tkline[Tkpos,1]\xFE";
    z += "    Until Index('@#*() +-=[]{}\":;<>|,/':\"'\",C,1) Or C=\"\" Or C = Mobjectdelemeter Do Repeat\xFE";
    z += "\xFE";
    z += "    Otkstr = Tkline[Tkstartpos,Tkpos-Tkstartpos]\xFE";
    z += "    If Otkstr[1,1] = `\\` Then \xFE";
    z += "        Otkstr = Mid(Otkstr, 2)\xFE";
    z += "        Tkstr = Otkstr\xFE";
    z += "    Else\xFE";
    z += "        Tkstr = Otkstr\xFE";
    z += "        Tkstr = Mcu(Tkstr)\xFE";
    z += "    End if\xFE";
    z += "    \xFE";
    z += "    Tkno = C_ident\xFE";
    z += "\xFE";
    z += "    Begin Case\xFE";
    z += "        Case Tkstr = \"CASE\" ; Tkno = C_case\xFE";
    z += "        Case Tkstr = \"ELSE\" ; Tkno = C_else\xFE";
    z += "        Case Tkstr = \"END\" ; Tkno = C_end\xFE";
    z += "        Case Tkstr = \"ENDIF\" ; Tkno = C_end\xFE";
    z += "        Case Tkstr = \"MOD\" ; Tkno = C_mod\xFE";
    z += "        Case Tkstr = \"FROM\" ; Tkno = C_from\xFE";
    z += "        Case Tkstr = \"NEXT\" ; Tkno = C_next\xFE";
    z += "        Case Tkstr = \"OFF\" ; Tkno = C_off\xFE";
    z += "        Case Tkstr = \"ON\" ; Tkno = C_on\xFE";
    z += "        Case Tkstr = \"REPEAT\" ; Tkno = C_repeat\xFE";
    z += "        Case Tkstr = \"THEN\" ; Tkno = C_then\xFE";
    z += "        Case Tkstr = \"TO\" ; Tkno = C_to\xFE";
    z += "        Case Tkstr = \"UNTIL\" ; Tkno = C_until\xFE";
    z += "        Case Tkstr = \"WHILE\" ; Tkno = C_while\xFE";
    z += "        Case Tkstr = \"OR\" ; Tkno = C_or\xFE";
    z += "        Case Tkstr = \"AND\" ; Tkno = C_and\xFE";
    z += "        Case Tkstr = \"MATCH\" ; Tkno = C_match\xFE";
    z += "        Case Tkstr = \"MATCHES\" ; Tkno = C_matches\xFE";
    z += "        Case Tkstr = \"CAT\" ; Tkno = C_cat\xFE";
    z += "        Case Tkstr = \"LT\" ; Tkno = C_lt\xFE";
    z += "        Case Tkstr = \"GT\" ; Tkno = C_gt\xFE";
    z += "        Case Tkstr = \"LE\" ; Tkno = C_le\xFE";
    z += "        Case Tkstr = \"NE\" ; Tkno = C_ne\xFE";
    z += "        Case Tkstr = \"GE\" ; Tkno = C_ge\xFE";
    z += "        Case Tkstr = \"EQ\" ; Tkno = C_eq\xFE";
    z += "        Case Tkstr = \"STEP\" ; Tkno = C_step\xFE";
    z += "        Case Tkstr = \"BEFORE\" ; Tkno = C_before\xFE";
    z += "        Case Tkstr = \"SETTING\" ; Tkno = C_setting\xFE";
    z += "        Case Tkstr = \"BY\" ; Tkno = C_by\xFE";
    z += "        Case Tkstr = \"LOCKED\" ; Tkno = C_locked\xFE";
    z += "        Case Tkstr = \"GOTO\" ; Tkno = C_goto\xFE";
    z += "        Case Tkstr = \"GO\" ; Tkno = C_goto\xFE";
    z += "        Case Tkstr = \"GOSUB\" ; Tkno = C_gosub\xFE";
    z += "        Case Tkstr = \"DO\" ; Tkno = C_do\xFE";
    z += "        Case Tkstr = \"LOOP\" ; Tkno = C_loop\xFE";
    z += "        Case Tkstr = \"MAT\" ; Tkno = C_mat\xFE";
    z += "        Case Tkstr = \"ERROR\" ; Tkno = C_error\xFE";
    z += "        Case Tkstr = \"IN\" ; Tkno = C_in\xFE";
    z += "        Case Tkstr = \"CAPTURING\" ; Tkno = C_capturing\xFE";
    z += "        Case Tkstr = \"USING\" ; Tkno = C_using\xFE";
    z += "        Case Tkstr = \"WITH\" ; Tkno = C_with\xFE";
    z += "        Case Tkstr = \"WHERE\" ; Tkno = C_where\xFE";
    z += "        Case Tkstr = \"DEFAULT\" ; Tkno = C_default\xFE";
    z += "        Case TkStr = \"CATCH\"; Tkno = C_catch\xFE";
    z += "    End Case\xFE";
    z += "    Return\xFE";
    z += "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "function Ferr(byval Msg)\xFE";
    z += "*\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "    Gattr = {}\xFE";
    z += "    Gattr.SYMNAME = 'CompileError'\xFE";
    z += "    Gattr.SYM_C = 'CompileError'\xFE";
    z += "    Gattr.SYM_INCLEVEL = Incfile\xFE";
    z += "    Gattr.SYM_FLAVOR = Flavor_local\xFE";
    z += "    Gattr.SYM_TYPE = Type_var\xFE";
    z += "    Gattr.SYM_USED = 1\xFE";
    z += "    Call Writesym(Gattr, Gattr.SYMNAME)\xFE";
    z += "    Call Err(Msg)\xFE";
    z += "    Return Gattr\xFE";
    z += "end function\xFE";
    z += "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "Subroutine Macro\xFE";
    z += "*\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "    If Trim(Oc) = '' Then\xFE";
    z += "        Oc = ''\xFE";
    z += "    End Else\xFE";
    z += "        Oc = Oc:Am\xFE";
    z += "    End\xFE";
    z += "    Call Tcv(False)\xFE";
    z += "    Loop\xFE";
    z += "        If Tkno = C_pound Then\xFE";
    z += "            Pstr = Space(Spaces):Tkstr\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "            If UCase(Tkstr) = \"ENDMACRO\" Then\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Exit Do\xFE";
    z += "            End\xFE";
    z += "            Oc = Oc:Pstr\xFE";
    z += "        End\xFE";
    z += "    While Tkno <> C_sm Do\xFE";
    z += "        Oc = Oc:Space(Spaces):Tkstr\xFE";
    z += "        Call Tcv(False)\xFE";
    z += "    Repeat\xFE";
    z += "    Return\xFE";
    z += "end sub\xFE";
    z += "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "function Makesubname(byval Id)\xFE";
    z += "*\xFE";
    z += "* Make C name for subroutine names, safe to call twice\xFE";
    z += "*\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "    Dim C As Char\xFE";
    z += "*\xFE";
    z += "    Sch = \";!@#$%^&*|\"\xFE";
    z += "    Rpl=\"_~SMI~PND~AT~PND~DLR~PCT~UPA~AMP~AST~BAR\"\xFE";
    z += "    Id = UCase(ID)\xFE";
    z += "    \xFE";
    z += "    For I = 1 To Len(Id)\xFE";
    z += "        C = Id[I,1]\xFE";
    z += "        If Index('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789',C,1)=0 Then\xFE";
    z += "            Ri = Index(Sch,C,1)+1\xFE";
    z += "            Id=Id[1,I-1]:Field(Rpl,'~',Ri):Id[I+1,99999]\xFE";
    z += "        End\xFE";
    z += "    Next I\xFE";
    z += "*\xFE";
    z += "*   BEGIN CASE\xFE";
    z += "*      CASE ID = \"WEOF\" ; ID = \"WEOFSUB\"\xFE";
    z += "*   END CASE\xFE";
    z += "    Return id\xFE";
    z += "end sub\xFE";
    z += "\xFE";
    z += "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "Subroutine parseAStype(byval Gattr)\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "    Gattr.SYM_TYPE = Type_var\xFE";
    z += "    If Tkstr <> \"AS\" Then Return\xFE";
    z += "    Call Tcv(False)\xFE";
    z += "    Begin Case\xFE";
    z += "        Case Tkstr = 'NUMBER' Or Tkstr = 'INT' Or Tkstr = 'INTEGER' Or Tkstr = 'LONG' Or Tkstr = 'REAL' Or Tkstr = 'FLOAT' Or Tkstr = 'DOUBLE' Or Tkstr = 'DBL'  Or Tkstr = \"BOOLEAN\" Or Tkstr = \"BOOL\"  Or Tkstr = 'SINGLE'\xFE";
    z += "            Gattr.SYM_TYPE = Type_vnum\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "        Case Tkstr = 'STRING' Or Tkstr = 'STR' Or Tkstr = \"CHAR\"\xFE";
    z += "            Gattr.SYM_TYPE = Type_vstr\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "        Case Tkstr = \"VARIANT\" Or Tkstr = \"VARIABLE\" Or Tkstr = \"FILE\" Or Tkstr = \"FILEHANDLE\" Or Tkstr = \"TABLE\" Or Tkstr = \"TABLEHANDLE\" Or Tkstr = \"SELECTLIST\" Or Tkstr = \"ARRAY\" Or Tkstr = \"JSON\" Or Tkstr = \"OBJECT\" \xFE";
    z += "            Gattr.SYM_TYPE = Type_var\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "        Case 1\xFE";
    z += "            Call Err(\"Invalid type\")\xFE";
    z += "            Gattr.SYM_TYPE = Type_var\xFE";
    z += "    End Case\xFE";
    z += "    Return\xFE";
    z += "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "function Parsevar(byval Storing, byval Matok, byval Lb, byval Showerrors)\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "* CHECK FOR PREVIOUS DEFINITION\xFE";
    z += "*\xFE";
    z += "    Gattr = {}\xFE";
    z += "    Gattr.SYM_INCLEVEL = Incfile\xFE";
    z += "\xFE";
    z += "    If Tkno = C_at Then\xFE";
    z += "        Call Tcv(False)\xFE";
    z += "\xFE";
    z += "        AtName = \"At_\":Tkstr[1,1]:LCase(Mid(Tkstr, 2))\xFE";
    z += "        \xFE";
    z += "        Gattr.SYMNAME = AtName\xFE";
    z += "        Gattr.SYM_C = AtName\xFE";
    z += "\xFE";
    z += "        If Tkstr = \"AM\" Or Tkstr = \"VM\" Or Tkstr = \"SVM\" Or Tkstr = \"SSVM\" Then\xFE";
    z += "            Gattr.SYM_C = LCase(Tkstr)\xFE";
    z += "            Gattr.SYM_TYPE = Type_vnum\xFE";
    z += "            Gattr.SYM_FLAVOR = Flavor_external\xFE";
    z += "            \xFE";
    z += "            Call Tcv(False)\xFE";
    z += "            Return Gattr\xFE";
    z += "\xFE";
    z += "        End Else If Tkstr = \"SENTENCE\" Or Tkstr = \"ERRORS\" Or Tkstr = \"FILENAME\" Or Tkstr = \"FILE\" Or Tkstr = \"RECORD\" Or Tkstr = \"PROMPT\" Or Tkstr = \"INPUT\" Or Tkstr = \"ECHO\" Or Tkstr = \"MV\" Or Tkstr = \"NI\" Or Tkstr = \"ID\" Or Tkstr = \"NV\" Or Tkstr = \"NB\" Or Tkstr = \"ND\" Or Tkstr = \"STATUS\" Then\xFE";
    z += "            AtName = \"activeProcess.At_\":Tkstr[1,1]:LCase(Mid(Tkstr, 2))\xFE";
    z += "            Gattr.SYM_C = AtName\xFE";
    z += "            Gattr.SYM_TYPE = Type_vstr\xFE";
    z += "            Gattr.SYM_TYPES = Symtypes_stored\xFE";
    z += "            Gattr.SYM_FLAVOR = Flavor_external\xFE";
    z += "\xFE";
    z += "        End Else If Tkstr = \"RESTFUL_RESULT\" Then\xFE";
    z += "            AtName = \"Restful_Result\"\xFE";
    z += "            Gattr.SYM_C = AtName\xFE";
    z += "            Gattr.SYM_TYPE = Type_exp\xFE";
    z += "            Gattr.SYM_TYPES = Symtypes_stored\xFE";
    z += "            Gattr.SYM_FLAVOR = Flavor_external\xFE";
    z += "            \xFE";
    z += "        End Else If Tkstr = \"APPLICATION\" Or Tkstr = \"SESSION\" Then\xFE";
    z += "            Gattr.SYMNAME = AtName\xFE";
    z += "            Gattr.SYM_C = AtName\xFE";
    z += "            \xFE";
    z += "            Nextch = Left(LTrim(Tkline[Tkpos,5]), 1)\xFE";
    z += "            If Nextch = Mobjectdelemeter Then\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                Call Tcv(False) ;* Skip Application\xFE";
    z += "                Call Tcv(False) ;* Skip .\xFE";
    z += "    \xFE";
    z += "                If Tkstr = \"ITEM\" Then\xFE";
    z += "                    Call Tcv(False)\xFE";
    z += "                    Gattr.SYM_C = AtName:\".Item\"\xFE";
    z += "                    Return Gattr\xFE";
    z += "                End If\xFE";
    z += "                \xFE";
    z += "                Gattr.SYM_C = AtName:\".Item('\":Tkstr:\"')\"\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Return Gattr\xFE";
    z += "                \xFE";
    z += "            End Else If Nextch = \"(\" Or Nextch = \"[\" Then\xFE";
    z += "                Gattr.SYM_TYPE = Type_estr\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "    \xFE";
    z += "                Lattr = Expr(Type_eNum, 1, C_rbrack:C_rparen)\xFE";
    z += "                Gattr.SYM_C = AtName:\".Item(\":Lattr.SYM_C:\")\"\xFE";
    z += "                If Nextch = \"(\" Then\xFE";
    z += "                    If Tkno = C_rparen Then Call Tcv(False) Else Call Err(\") EXPECTED\")\xFE";
    z += "                Else\xFE";
    z += "                    If Tkno = C_rbrack Then Call Tcv(False) Else Call Err(\"] EXPECTED\")\xFE";
    z += "                Endif\xFE";
    z += "                Return Gattr\xFE";
    z += "            End If\xFE";
    z += "        End If\xFE";
    z += "\xFE";
    z += "    End Else If Tkstr = \"$\" Or Tkstr = \"WINDOW\" Or Tkstr = \"DOCUMENT\" Or Tkstr = \"ME\" Then\xFE";
    z += "        Gattr.SYM_C = LCase(Tkstr)\xFE";
    z += "        Gattr.SYM_TYPE = Type_estr\xFE";
    z += "        Gattr.SYM_FLAVOR = Flavor_external\xFE";
    z += "        \xFE";
    z += "        Call Tcv(False)\xFE";
    z += "        Return Gattr\xFE";
    z += "\xFE";
    z += "    End Else If Tkstr = \"TRUE\" Or Tkstr = \"FALSE\" Then\xFE";
    z += "        Gattr.SYM_C = LCase(Tkstr)\xFE";
    z += "        Gattr.SYM_TYPE = Type_eBool\xFE";
    z += "        Gattr.SYM_FLAVOR = Flavor_external\xFE";
    z += "        \xFE";
    z += "        Call Tcv(False)\xFE";
    z += "        Return Gattr\xFE";
    z += "\xFE";
    z += "    End Else If Tkstr = \"RANDYNWALSH\" Then\xFE";
    z += "        Gattr.SYM_C = \"'Randy N. Walsh is the author'\"\xFE";
    z += "        Gattr.SYM_TYPE = Type_cstr\xFE";
    z += "        Gattr.SYM_FLAVOR = Flavor_external\xFE";
    z += "        Call Tcv(False)\xFE";
    z += "        Return Gattr\xFE";
    z += "\xFE";
    z += "    // to be compatible with ASX null is the same - use window.null\xFE";
    z += "    End Else If Tkstr = \"NOTHING\" Or Tkstr = \"UNDEFINED\" Or Tkstr = \"NULL\" Then\xFE";
    z += "        Gattr.SYM_C = \"undefined\"\xFE";
    z += "        Gattr.SYM_TYPE = Type_estr\xFE";
    z += "        Gattr.SYM_FLAVOR = Flavor_external\xFE";
    z += "        \xFE";
    z += "        Call Tcv(False)\xFE";
    z += "        Return Gattr\xFE";
    z += "\xFE";
    z += "    End Else\xFE";
    z += "        varPrefixed = Tkstr = \"VAR\" or Tkstr = \"DIM\"\xFE";
    z += "        if varPrefixed then Call Tcv(False)\xFE";
    z += "        \xFE";
    z += "        * STANDARD VARIABLE (or function?)\xFE";
    z += "        Gattr = readsym(Tkstr)\xFE";
    z += "        Found = readSymFound\xFE";
    z += "        \xFE";
    z += "        \xFE";
    z += "        If Found Then\xFE";
    z += "            if varPrefixed then call Warning('already defined')\xFE";
    z += "            \xFE";
    z += "            If Not(Gattr.SYM_USED) And Not(Index(C_lparen:C_great:C_lbrack,Tkno,1)) Then\xFE";
    z += "                Gattr.SYM_USED = 1\xFE";
    z += "                Call Writesym(Gattr, Tkstr)\xFE";
    z += "            End\xFE";
    z += "\xFE";
    z += "            If Storing And Not(Index(Gattr.SYM_TYPES,Symtypes_stored,1)) Then\xFE";
    z += "                Gattr.SYM_TYPES=Gattr.SYM_TYPES:Symtypes_stored\xFE";
    z += "                Call Writevsym(Gattr.SYM_TYPES, Gattr.SYMNAME, \"SYM_TYPES\")\xFE";
    z += "            End\xFE";
    z += "            \xFE";
    z += "        End Else\xFE";
    z += "            If Tkno < C_ident Then\xFE";
    z += "                If Showerrors Then Call Err('Identifier expected')\xFE";
    z += "                Return Gattr\xFE";
    z += "            End\xFE";
    z += "            \xFE";
    z += "            If Showerrors And Mid(Tkline, Tkpos, 1) <> \"(\" Then\xFE";
    z += "                if varPrefixed then Gattr.isAlreadyDefined = true\xFE";
    z += "                If Storing Then Gattr.SYM_TYPES = Symtypes_stored\xFE";
    z += "                Gattr.SYM_USED = Gattr.SYM_USED + 1\xFE";
    z += "                Call Writesym(Gattr, Gattr.SYMNAME)\xFE";
    z += "            End If\xFE";
    z += "        End\xFE";
    z += "        if varPrefixed then Gattr.SYM_C = 'var \":Gattr.SYM_C\xFE";
    z += "    End If\xFE";
    z += "\xFE";
    z += "    Call Tcv(False)\xFE";
    z += "\xFE";
    z += "    If Tkstr = \"AS\" Then\xFE";
    z += "        Call parseAStype(Gattr)\xFE";
    z += "    End If\xFE";
    z += "        \xFE";
    z += "    If Instr(Lb, Tkno) Then Return Gattr\xFE";
    z += "*\xFE";
    z += "* CHECK FOR r83 style predeclared array '(' DIM-INDEX ')'\xFE";
    z += "* OR (TKNO=C_LPAREN AND SPACES = 0)\xFE";
    z += "*\xFE";
    z += "    If Gattr.SYM_INDEX1 And Not(Index(Lb,C_lparen,1)) Then\xFE";
    z += "        If Tkno <> C_lparen Then\xFE";
    z += "            If Not(Matok) Then\xFE";
    z += "                If Showerrors Then Call Err('[Array index expected]')\xFE";
    z += "            End\xFE";
    z += "        End Else\xFE";
    z += "            If Gattr.SYM_INDEX1='' Then\xFE";
    z += "                If Found Then\xFE";
    z += "                    If Showerrors Then Call Err('Not a MAT variable')\xFE";
    z += "                End Else If Showerrors Then\xFE";
    z += "                    Gattr.SYM_TYPE = Type_vstr\xFE";
    z += "                    Gattr.SYM_INDEX1 = -1\xFE";
    z += "                    Call Writesym(Gattr, Gattr.SYMNAME)\xFE";
    z += "                End\xFE";
    z += "            End\xFE";
    z += "            *\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "            *\xFE";
    z += "            Lattr = Expr(Type_eNum, 1, C_comma:C_rparen)\xFE";
    z += "            If Not(Index(Type_cnum:Type_vNum:Type_vBool:Type_eNum:Type_eBool,Lattr.SYM_TYPE,1)) Then\xFE";
    z += "                Call Makenum(Type_vnum, Lattr)\xFE";
    z += "            End\xFE";
    z += "            Gattr.SYM_C = Gattr.SYM_C:'[':Lattr.SYM_C\xFE";
    z += "            *\xFE";
    z += "            If Tkno = C_comma Then\xFE";
    z += "                If Gattr.SYM_INDEX2 = '' Then\xFE";
    z += "                    If Found Then\xFE";
    z += "                        If Showerrors Then Call Err('Variable does not have 2nd dimension')\xFE";
    z += "                    End Else If Showerrors Then\xFE";
    z += "                        Gattr.SYM_INDEX2 = -1\xFE";
    z += "                        Call Writesym(Gattr, Gattr.SYMNAME)\xFE";
    z += "                    End\xFE";
    z += "                End\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Jattr = Expr(Type_eNum, 1, C_comma:C_rparen)\xFE";
    z += "                Call Makenum(Type_vnum, Jattr)\xFE";
    z += "                Gattr.SYM_C = Gattr.SYM_C:'][':Jattr.SYM_C\xFE";
    z += "            End Else\xFE";
    z += "                If Gattr.SYM_INDEX2 And Showerrors Then Call Err('Index expected')\xFE";
    z += "            End\xFE";
    z += "            Gattr.SYM_C = Gattr.SYM_C:']'\xFE";
    z += "\xFE";
    z += "            If Tkno <> C_rparen And Showerrors Then Call Err(') expected') Else Call Tcv(False)\xFE";
    z += "            Gattr.SYM_INDEX1 = ''\xFE";
    z += "            Gattr.SYM_INDEX2 = ''\xFE";
    z += "        End\xFE";
    z += "    End\xFE";
    z += "*\xFE";
    z += "    Return Gattr\xFE";
    z += "end function\xFE";
    z += "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "function Peektk()\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "    Htkno = Tkno\xFE";
    z += "    Hotkstr = Otkstr\xFE";
    z += "    Htkstr = Tkstr\xFE";
    z += "    Htkpos = Tkpos\xFE";
    z += "    Htkam = Tkam\xFE";
    z += "    Htkline = Tkline\xFE";
    z += "    Htkstartpos = Tkstartpos\xFE";
    z += "    Hcpassthru = Cpassthru\xFE";
    z += "    Hoc = Oc\xFE";
    z += "*\xFE";
    z += "    Call Tcv(False)\xFE";
    z += "    Cpassthru = Hcpassthru\xFE";
    z += "    Oc = Hoc\xFE";
    z += "    Ptk = Tkno\xFE";
    z += "*\xFE";
    z += "    Tkno = Htkno\xFE";
    z += "    Otkstr = Hotkstr\xFE";
    z += "    Tkstr = Htkstr\xFE";
    z += "    Tkpos = Htkpos\xFE";
    z += "    Tkam = Htkam\xFE";
    z += "    Tkline = Htkline\xFE";
    z += "    Tkstartpos = Htkstartpos\xFE";
    z += "*\xFE";
    z += "    Return Ptk\xFE";
    z += "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "Subroutine Readinc(byval Symlist As Json)\xFE";
    z += "*\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "    For Each SName In Symlist\xFE";
    z += "        SAttr = SymList[SName]\xFE";
    z += "        Symname = Sattr.SYMNAME\xFE";
    z += "        Sattr.SYM_INCLEVEL = 999\xFE";
    z += "        Pattr = Clone(Symtab[Symname])\xFE";
    z += "        If Pattr Then\xFE";
    z += "            If Not(Pattr.SYM_USED) Then\xFE";
    z += "                If Sattr.SYM_TYPE=Type_var Then\xFE";
    z += "                    Sattr.SYM_TYPE = Pattr.SYM_TYPE\xFE";
    z += "                End\xFE";
    z += "                If Pattr.SYM_TYPE=Type_var Then\xFE";
    z += "                    Pattr.SYM_TYPE = Sattr.SYM_TYPE\xFE";
    z += "                End\xFE";
    z += "                If Pattr.SYM_FLAVOR = Flavor_parameter And Sattr.SYM_FLAVOR = Flavor_local Then\xFE";
    z += "                    Sattr.SYM_FLAVOR = Flavor_parameter\xFE";
    z += "                End\xFE";
    z += "                If Sattr.SYM_INDEX1='' Or Sattr.SYM_INDEX1 = -1 Then\xFE";
    z += "                    Sattr.SYM_INDEX1 = Pattr.SYM_INDEX1\xFE";
    z += "                    Sattr.SYM_INDEX2 = Pattr.SYM_INDEX2\xFE";
    z += "                End\xFE";
    z += "                If Pattr.SYM_INDEX1='' Or Pattr.SYM_INDEX1 = -1 Then\xFE";
    z += "                    Pattr.SYM_INDEX1 = Sattr.SYM_INDEX1\xFE";
    z += "                    Pattr.SYM_INDEX2 = Sattr.SYM_INDEX2\xFE";
    z += "\xFE";
    z += "                End\xFE";
    z += "                If Sattr.SYM_STRLEN = Dftstrlen Then\xFE";
    z += "                    Sattr.SYM_STRLEN = Pattr.SYM_STRLEN\xFE";
    z += "                End\xFE";
    z += "                If Pattr.SYM_STRLEN = Dftstrlen Then\xFE";
    z += "                    Pattr.SYM_STRLEN = Sattr.SYM_STRLEN\xFE";
    z += "                End\xFE";
    z += "            End\xFE";
    z += "            Begin Case\xFE";
    z += "                Case Sattr.SYM_TYPE # Pattr.SYM_TYPE\xFE";
    z += "                    Call Err('Variable ':Symname:' previosly defined differently')\xFE";
    z += "                Case Sattr.SYM_INDEX1 # Pattr.SYM_INDEX1 Or Sattr.SYM_INDEX2 # Pattr.SYM_INDEX2\xFE";
    z += "                    Call Err('Variable ':Symname:' previosly defined with a different index')\xFE";
    z += "                Case Sattr.SYM_FLAVOR # Pattr.SYM_FLAVOR\xFE";
    z += "                    Call Err('Variable ':Symname:' previously defined in a different block')\xFE";
    z += "                Case Sattr.SYM_ISCONST # Pattr.SYM_ISCONST\xFE";
    z += "                    Call Err('Variable ':Symname:' previously defined at a different access level')\xFE";
    z += "            End Case\xFE";
    z += "        End\xFE";
    z += "        Call Writesym(Sattr, Symname)\xFE";
    z += "    Next\xFE";
    z += "    Return\xFE";
    z += "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "Subroutine Reseti(byval Howmuch As Integer)\xFE";
    z += "*\xFE";
    z += "* HOWMUCH = # OF SPACES +/- TO CHANGE INDENTATION\xFE";
    z += "*\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "    Indent = Indent + Howmuch\xFE";
    z += "    Lline = Count(Oc,Am) + 1\xFE";
    z += "    If Trim(Oc<Lline>) = '' Then Oc<Lline>=Space(Indent)\xFE";
    z += "    Return\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "Subroutine Restoret(byval A As Object, optional byval nolengthcheck as boolean)\xFE";
    z += "*\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "    Tkno = A.TKNO\xFE";
    z += "    Otkstr = A.OTKSTR\xFE";
    z += "    Tkstr = Mcu(Otkstr)\xFE";
    z += "    Tkpos = A.TKPOS\xFE";
    z += "    Tkam = A.TKAM\xFE";
    z += "    Tkline = A.TKLINE\xFE";
    z += "    Cpassthru = A.CPASSTHRU\xFE";
    z += "    Oc = A.OC\xFE";
    z += "    IF LEN(OCPGM) <> A.LOCPGM THEN \xFE";
    z += "        // We should avoid putting stuff in OCPGM when between SaveTk and RestoreTk\xFE";
    z += "        if !nolengthcheck then DEBUG\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    Return\xFE";
    z += "    \xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "function Savetk()\xFE";
    z += "*\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "    A = { }\xFE";
    z += "    A.TKNO = Tkno\xFE";
    z += "    A.OTKSTR = Otkstr\xFE";
    z += "    A.TKPOS = Tkpos\xFE";
    z += "    A.TKAM = Tkam\xFE";
    z += "    A.TKLINE = Tkline\xFE";
    z += "    A.CPASSTHRU = Cpassthru\xFE";
    z += "    A.OC = Oc\xFE";
    z += "    A.LOCPGM = LEN(OCPGM)\xFE";
    z += "    Return A\xFE";
    z += "\xFE";
    z += "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "Subroutine Typenum(byval Suggest_type, byval Gattr)\xFE";
    z += "*\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "    If Gattr.SYM_TYPE = Type_vnum Or Gattr.SYM_TYPE = Type_var Or Gattr.SYM_TYPE = Type_vstr Then\xFE";
    z += "        If Not(Index(Gattr.SYM_TYPES, Suggest_type, 1)) And Suggest_type # Type_dc  Then\xFE";
    z += "            Gattr.SYM_TYPES=Gattr.SYM_TYPES:Suggest_type\xFE";
    z += "            Call Writevsym(Gattr.SYM_TYPES, Gattr.SYMNAME, \"SYM_TYPES\")\xFE";
    z += "        End If\xFE";
    z += "    End If\xFE";
    z += "    Gattr.SYM_TYPE = Type_eNum\xFE";
    z += "    Return\xFE";
    z += "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "Subroutine Typestr(byval Suggest_type, byval Gattr)\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "    If Gattr.SYM_TYPE = Type_vnum Or Gattr.SYM_TYPE = Type_var Or Gattr.SYM_TYPE = Type_vstr Then\xFE";
    z += "        If Not(Index(Gattr.SYM_TYPES, Suggest_type, 1)) And Suggest_type # Type_dc  Then\xFE";
    z += "            Gattr.SYM_TYPES=Gattr.SYM_TYPES:Suggest_type\xFE";
    z += "            Call Writevsym(Gattr.SYM_TYPES, Gattr.SYMNAME, \"SYM_TYPES\")\xFE";
    z += "        End\xFE";
    z += "    End If\xFE";
    z += "    Gattr.SYM_TYPE = Type_estr\xFE";
    z += "    Return\xFE";
    z += "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "Subroutine Uses(byval Bexpr)\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "    If Not(Index(Bexpr.SYM_TYPES,Symtypes_stored,1)) Then\xFE";
    z += "        Bexpr.SYM_TYPES=Bexpr.SYM_TYPES:Symtypes_stored\xFE";
    z += "        Call Writevsym(Bexpr.SYM_TYPES, Bexpr.SYMNAME,  \"SYM_TYPES\")\xFE";
    z += "    End\xFE";
    z += "    Return\xFE";
    z += "\xFE";
    z += "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "function Makevarname(byval Vstr)\xFE";
    z += "*\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "* MUST BE IDENTIFIER\xFE";
    z += "*\xFE";
    z += "    C = Vstr[1,1]\xFE";
    z += "    If C = '\\\\' Then\xFE";
    z += "        Vstr = Vstr[2,99]\xFE";
    z += "        Return\xFE";
    z += "    End\xFE";
    z += "*\xFE";
    z += "    Upcase = 1\xFE";
    z += "    Ostr = \"\"\xFE";
    z += "    L = Len(Vstr)\xFE";
    z += "    For I = 1 To L\xFE";
    z += "        C = Vstr[I,1]\xFE";
    z += "        If Mr83 Then Cvt = Index('_&!@#$%.',C,1) Else Cvt = Index('_&!@#$%',C,1)\xFE";
    z += "        If Cvt Then\xFE";
    z += "            C3 = ('_':Am:'_AMP_':Am:'_BANG_':Am:'_AT_':Am:'_PND_':Am:'_DLR_':Am:'_PCT_':Am:'_')<Cvt>\xFE";
    z += "            Ostr = Ostr:C3\xFE";
    z += "            Upcase = 1\xFE";
    z += "        End Else\xFE";
    z += "            If C = \"_\" Then\xFE";
    z += "                Upcase = 1\xFE";
    z += "                Ostr = Ostr:\"_\"\xFE";
    z += "            End Else\xFE";
    z += "                If Upcase Then\xFE";
    z += "                    Ostr = Ostr:Mcu(C)\xFE";
    z += "                    Upcase = 0\xFE";
    z += "                End Else\xFE";
    z += "                    Ostr = Ostr:Mcl(C)\xFE";
    z += "                End\xFE";
    z += "            End\xFE";
    z += "        End\xFE";
    z += "    Next I\xFE";
    z += "    \xFE";
    z += "    Locate UCase(Ostr) In UC_externals_purejs_list Then Ostr = \"_\":Ostr\xFE";
    z += "    \xFE";
    z += "    return Ostr\xFE";
    z += "end function\xFE";
    z += "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "Subroutine Err(byval Msg)\xFE";
    z += "*\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "    If IgnoreErrors Then Return\xFE";
    z += "    If Index(Options,'!',1) Then Debug\xFE";
    z += "    \xFE";
    z += "    Errcnt = Errcnt + 1\xFE";
    z += "    If ErrCnt = 1 Then\xFE";
    z += "        Print Crlf():anchorEdit(Cur_fname, Itemid)\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    If Tkam # Errline Then\xFE";
    z += "        Print\xFE";
    z += "        Print anchorEdit(Cur_fname, Itemid, Monospace(tkam:\" \":Itemsrc[Tkam]), \"\", \"\", Tkam)\xFE";
    z += "        Errors<-1> = Tkam:' ':Itemsrc[Tkam]\xFE";
    z += "        Errline = Tkam\xFE";
    z += "        Errpos = 0\xFE";
    z += "        if InStr(options, \"!\") then debug\xFE";
    z += "    End\xFE";
    z += "    \xFE";
    z += "    If Errpos # Tkpos Then\xFE";
    z += "        Print Monospace(Space(Tkpos-Len(Tkstr)+4)):\"^\":Chr(14):Tkam:' ':Msg:Chr(14)\xFE";
    z += "        Errors<-1> = Space(Tkpos-Len(Tkstr)+4):\"^\":Msg\xFE";
    z += "        If Tkstr = '' Then Print Else Print '; \"':Tkstr:'\" found.'\xFE";
    z += "        Errpos = Tkpos\xFE";
    z += "    End\xFE";
    z += "    Loop While Not(Index(La:C_semi:C_am:C_sm,Tkno,1)) Do\xFE";
    z += "        Call Tcv(False)\xFE";
    z += "    Repeat\xFE";
    z += "    Return\xFE";
    z += "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "Subroutine Err2(byval Msg)\xFE";
    z += "*\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "* REPORT ERROR NO MATTER WHAT\xFE";
    z += "*\xFE";
    z += "    If Index(Options,'!',1) Then Debug\xFE";
    z += "    \xFE";
    z += "    Errcnt = Errcnt + 1\xFE";
    z += "    If ErrCnt = 1 Then\xFE";
    z += "        Print Crlf():anchorEdit(Cur_fname, Itemid)\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    If Tkam # Errline And Tkam <= UBound(Itemsrc) Then\xFE";
    z += "        Print\xFE";
    z += "        Print Monospace(tkam:\" \":Itemsrc[Tkam])\xFE";
    z += "        Errors<-1> = Tkam:' ':Itemsrc[Tkam]\xFE";
    z += "        Errline = Tkam\xFE";
    z += "        Errpos = 0\xFE";
    z += "        if InStr(options, \"!\") then debug\xFE";
    z += "    End\xFE";
    z += "    Print anchorEdit(Cur_fname, Itemid, Monospace(Space(Tkpos-Len(Tkstr)+3):\"^\"):Chr(14):Tkam:\" \":Msg:Chr(14), \"\", \"\", Tkam)\xFE";
    z += "    Errors<-1> = Space(Tkpos-Len(Tkstr)+4):\"^\":Msg\xFE";
    z += "    Errpos = Tkpos\xFE";
    z += "    Return\xFE";
    z += "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "Subroutine Warning(byval Msg)\xFE";
    z += "*\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "    If Tkam # Errline And Tkam <= UBound(Itemsrc) Then\xFE";
    z += "        Print\xFE";
    z += "        Print Monospace(tkam:\" \":Itemsrc[Tkam])\xFE";
    z += "        Errors<-1> = Tkam:' ':Itemsrc[Tkam]\xFE";
    z += "        Errline = Tkam\xFE";
    z += "    End\xFE";
    z += "    Print anchorEdit(Cur_fname, Itemid, Monospace(Space(Tkpos-Len(Tkstr)+4)):\"|Warning: \":Chr(15):Tkam:\" \":Msg:Chr(15), \"\", \"\", Tkam)\xFE";
    z += "    Errors<-1> = Space(Tkpos-Len(Tkstr)+4):\"|Warning: \":Msg\xFE";
    z += "    Return\xFE";
    z += "    \xFE";
    z += "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "Function Matload()\xFE";
    z += "*\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "    If Tkno < C_ident Then\xFE";
    z += "        Call Err('Variable Identifier expected')\xFE";
    z += "        MatLoadSize = 'M1X0'\xFE";
    z += "        Gattr = {}\xFE";
    z += "        Return Gattr\xFE";
    z += "    End\xFE";
    z += "\xFE";
    z += "    Gattr = readsym(Tkstr);\xFE";
    z += "    If readSymFound Then\xFE";
    z += "        If Not(Gattr.SYM_USED) And Not(Index(C_lparen:C_great:C_lbrack,Tkno,1)) Then\xFE";
    z += "            Gattr.SYM_USED = 1\xFE";
    z += "            Call Writesym(Gattr, Tkstr)\xFE";
    z += "        End\xFE";
    z += "        If Gattr.SYM_INDEX1 = '' Then Call Err('Variable not DIMensioned')\xFE";
    z += "        Pt = Index(Type_var:Type_vNum:Type_vBool:Type_vstr, Gattr.SYM_TYPE, 1)\xFE";
    z += "        Expectingtype = ('pns')[Pt,1]\xFE";
    z += "        If Gattr.SYM_TYPE = Type_vstr Then\xFE";
    z += "            Expectingtype = 's':Gattr.SYM_STRLEN:Expectingtype\xFE";
    z += "        End\xFE";
    z += "        MatLoadSize = 'M':Gattr.SYM_INDEX1:'X':Gattr.SYM_INDEX2:Expectingtype\xFE";
    z += "    End Else Call Err('Variable not DIMensioned')\xFE";
    z += "    Call Tcv(False)\xFE";
    z += "    Return Gattr\xFE";
    z += "\xFE";
    z += ""
    window.cached_jsb2js["tcv"] = z;
    var z = "Subroutine Thenelse(byval Gattr)\xFE";
    z += "    $Insert _comms\xFE";
    z += "\xFE";
    z += "    Call Makebool(Gattr)\xFE";
    z += "    If Trim(Oc) <> '' Then Ocpgm[-1] = Oc; Oc = Space(Indent)\xFE";
    z += "    Ochold = Ocpgm; Ocpgm = []; Holdhaslbl = Haslbl; Haslbl = 0\xFE";
    z += "\xFE";
    z += "    Ifblock = \"\"\xFE";
    z += "    Elseblock = \"\"\xFE";
    z += "    ElseIfBlock = \"\"\xFE";
    z += "    Endlbl = \"_EndIf_\":Nxtlbl\xFE";
    z += "    Elselbl = \"_Else_\":Nxtlbl; Nxtlbl = Nxtlbl + 1\xFE";
    z += "\xFE";
    z += "    NeedBraces = false\xFE";
    z += "    \xFE";
    z += "    If Tkno <> C_else Then\xFE";
    z += "        If Tkno = C_then Then \xFE";
    z += "            Call Tcv(False)\xFE";
    z += "            if Tkno = C_AM Then ForceBraces = True\xFE";
    z += "        end if\xFE";
    z += "        Oc = \"\"; Ocpgm = []\xFE";
    z += "        Call States(2,C_else)\xFE";
    z += "        If Trim(Oc) <> '' Then Ocpgm[-1] = Oc\xFE";
    z += "        Ifblock = RTrim(LTrim(Ocpgm))\xFE";
    z += "    End\xFE";
    z += "\xFE";
    z += "    If Tkno = C_else or TkStr = \"ELSEIF\" Then\xFE";
    z += "        if Tkno = C_else Then Call Tcv(False) Else TKStr = \"IF\"\xFE";
    z += "        \xFE";
    z += "        if Tkno = C_AM Then ForceBraces = True\xFE";
    z += "\xFE";
    z += "        Oc = \"\"; Ocpgm = []\xFE";
    z += "        if TkStr = \"IF\" Then\xFE";
    z += "            Call States(2, '')\xFE";
    z += "            If Trim(Oc) <> '' Then Ocpgm[-1] = Oc\xFE";
    z += "            ElseIfblock = RTrim(LTrim(Ocpgm))\xFE";
    z += "            \xFE";
    z += "        Else\xFE";
    z += "            Call States(2,C_else)\xFE";
    z += "            If Trim(Oc) <> '' Then Ocpgm[-1] = Oc\xFE";
    z += "            Elseblock = RTrim(LTrim(Ocpgm))\xFE";
    z += "        End If\xFE";
    z += "    End\xFE";
    z += "\xFE";
    z += "    Ocpgm = Ochold; Oc = Space(Indent)\xFE";
    z += "    If Haslbl Then\xFE";
    z += "        if ElseIfblock then ElseBlock = ElseIfblock\xFE";
    z += "        \xFE";
    z += "        If Ifblock <> \"\" Then\xFE";
    z += "            If Elseblock <> \"\" Then\xFE";
    z += "                Oc = Oc:'if (':Gattr.SYM_C:') null; else { gotoLabel = \"':Elselbl:'\"; continue atgoto }'\xFE";
    z += "                Oc<-1> = Space(Indent+3):LTrim(Ifblock)\xFE";
    z += "                Oc<-1> = Space(Indent+3):'gotoLabel = \"':Endlbl:'\"; continue atgoto; '\xFE";
    z += "                Call Deflbl(Elselbl, 0)\xFE";
    z += "                Oc<-1> = Space(Indent+3):LTrim(Elseblock)\xFE";
    z += "            End Else\xFE";
    z += "                Oc = Oc:'if (':Gattr.SYM_C:') null; else { gotoLabel = \"':Endlbl:'\"; continue atgoto }'\xFE";
    z += "                Oc<-1> = Space(Indent+3):LTrim(Ifblock)\xFE";
    z += "            End\xFE";
    z += "        Else If Elseblock <> \"\" Then\xFE";
    z += "            * NO IF BLOCK\xFE";
    z += "            Oc = Oc:'if (':Gattr.SYM_C:') { gotoLabel = \"':Endlbl:'\"; continue atgoto }'\xFE";
    z += "            Oc<-1> = Space(Indent+3):LTrim(Elseblock)\xFE";
    z += "        End\xFE";
    z += "        Call Deflbl(Endlbl, 0)\xFE";
    z += "        Haslbl = Haslbl Or Holdhaslbl\xFE";
    z += "        Return\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    Loop\xFE";
    z += "        Rc = Right(IfBlock, 1)\xFE";
    z += "    While Rc = \";\" or Rc = Am() Or Rc = Cr() Or Rc = Lf() Do\xFE";
    z += "        IfBlock = Left(IfBlock, Len(IfBlock) - 1)\xFE";
    z += "    Repeat\xFE";
    z += "    \xFE";
    z += "    Loop\xFE";
    z += "        Rc = Right(Elseblock, 1)\xFE";
    z += "    While Rc = \";\" or Rc = Am() Or Rc = Cr() Or Rc = Lf() Do\xFE";
    z += "        Elseblock = Left(Elseblock, Len(Elseblock) - 1)\xFE";
    z += "    Repeat\xFE";
    z += "\xFE";
    z += "    If Instr(Ifblock, \";\") Or Instr(Ifblock, \"{\") Or Instr(Ifblock, \"//\") Then NeedThenBraces = True\xFE";
    z += "    If Instr(Elseblock, \";\") Or Instr(Elseblock, \"{\") Or Instr(Elseblock, \"//\") Then NeedElseBraces = True\xFE";
    z += "\xFE";
    z += "    If IfBlock <> \"\" And (ForceBraces Or NeedThenBraces) Then\xFE";
    z += "        if Right(IfBlock, 1) <> \"}\" Then IfBlock := \";\"\xFE";
    z += "        If ForceBraces Or Instr(Ifblock, Am) Or Instr(Ifblock, \"//\") Then\xFE";
    z += "            Ifblock = \"{\":Am:Space(Indent+3):Ifblock:Am:Space(Indent):\"}\"\xFE";
    z += "        End Else\xFE";
    z += "            Ifblock = \"{ \":Ifblock:\" }\"\xFE";
    z += "        End If\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    If Elseblock <> \"\" And (ForceBraces Or NeedElseBraces) Then\xFE";
    z += "        if Right(Elseblock, 1) <> \"}\" Then Elseblock := \";\"\xFE";
    z += "        If ForceBraces Or Instr(Elseblock, Am) Or Instr(Elseblock, \"//\")  Then\xFE";
    z += "            Elseblock = \"{\":Am:Space(Indent+3):Elseblock:Am:Space(Indent):\"}\"\xFE";
    z += "        End Else\xFE";
    z += "            Elseblock = \"{ \":Elseblock:\" }\"\xFE";
    z += "        End If\xFE";
    z += "    End If\xFE";
    z += "\xFE";
    z += "    If ElseIfblock <> \"\" Then ElseBlock = ElseIfblock\xFE";
    z += "    \xFE";
    z += "    If Ifblock <> \"\" Then\xFE";
    z += "        if Right(IfBlock, 1) <> \"}\" Then IfBlock := \";\"\xFE";
    z += "        \xFE";
    z += "        If Elseblock <> \"\" Then\xFE";
    z += "            if Right(Elseblock, 1) <> \"}\" Then Elseblock := \";\"\xFE";
    z += "            Oc = Oc:'if (':Gattr.SYM_C:') ':Ifblock:\" else \":Elseblock\xFE";
    z += "        End Else\xFE";
    z += "            Oc = Oc:'if (':Gattr.SYM_C:') ':Ifblock\xFE";
    z += "        End\xFE";
    z += "\xFE";
    z += "    Else If Elseblock <> \"\" Then\xFE";
    z += "        * NO IF BLOCK\xFE";
    z += "        if Right(Elseblock, 1) <> \"}\" Then Elseblock := \";\"\xFE";
    z += "        Oc = Oc:'if (':Gattr.SYM_C:'); else ':Elseblock\xFE";
    z += "        \xFE";
    z += "    Else\xFE";
    z += "        Oc = Oc:'if (':Gattr.SYM_C:') null; '\xFE";
    z += "    End\xFE";
    z += "\xFE";
    z += "    Haslbl = Haslbl Or Holdhaslbl\xFE";
    z += "    Return\xFE";
    z += ""
    window.cached_jsb2js["thenelse"] = z;
    var z = "Subroutine Typedef(byval Type_flavor, optional byval Process_commas, optional byval optionsInternal)\xFE";
    z += "*\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "* NOTE: INCFILE=1 IS MAIN FILE, INCFILE>1 IS INCLUDE\xFE";
    z += "*       INDEX1=-1 IF VAR DECLARED PREVIOUSLY ONLY AS MAT\xFE";
    z += "*\xFE";
    z += "* Parameter if SYM_FLAVOR = FLAVOR_PARAMETER\xFE";
    z += "*\xFE";
    z += "* If parameter, parameter is:\xFE";
    z += "*   Call by value if <SYM_ISCONST> = 1 (Use CONST)\xFE";
    z += "*      (Not valid for type VARIANT)\xFE";
    z += "*   Call by address if <SYM_ISCONST> = 0 (Default)\xFE";
    z += "*\xFE";
    z += "    La = La:C_comma\xFE";
    z += "    Sep = ';'\xFE";
    z += "    \xFE";
    z += "    Loop\xFE";
    z += "        Gattr = {}\xFE";
    z += "        Gattr.SYM_FLAVOR = Type_flavor\xFE";
    z += "        Gattr.SYM_INCLEVEL = Incfile\xFE";
    z += "        Gattr.SYM_ISCONST = 0\xFE";
    z += "        Gattr.SYM_JSOBJ = optionsInternal\xFE";
    z += "        \xFE";
    z += "        If Type_flavor = Flavor_parameter Then\xFE";
    z += "            If Tkstr = \"BYVAL\" Then\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Gattr.SYM_ISBYVAL = True\xFE";
    z += "            Else\xFE";
    z += "                // assumed byRef\xFE";
    z += "                If Tkstr = 'BYREF' Then Call Tcv(False)\xFE";
    z += "                Gattr.SYM_ISBYVAL = False\xFE";
    z += "            End If\xFE";
    z += "            If Tkno < C_ident Then Call Err('Variable expected'); Return\xFE";
    z += "        Else\xFE";
    z += "            If Tkstr = 'CONST' Then\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                If Tkno >= C_ident Then\xFE";
    z += "                    Gattr.SYM_ISCONST = 1\xFE";
    z += "                End Else\xFE";
    z += "                    If Tkno < C_ident Then Call Err('Variable expected'); Return\xFE";
    z += "                End If\xFE";
    z += "            End If\xFE";
    z += "        End If\xFE";
    z += "\xFE";
    z += "        Ismat = (Tkno = C_mat)\xFE";
    z += "        If Ismat Then Call Tcv(False)\xFE";
    z += "\xFE";
    z += "        If Tkno < C_ident Then Call Err('Variable expected'); Return\xFE";
    z += "        Gattr.SYMNAME = Tkstr\xFE";
    z += "        if Type_flavor <> Flavor_external And !optionsInternal Then Otkstr = Makevarname(Otkstr)\xFE";
    z += "        Gattr.SYM_C = Otkstr\xFE";
    z += "\xFE";
    z += "        Call Tcv(False)\xFE";
    z += "*\xFE";
    z += "* CHECK FOR DIM()'S\xFE";
    z += "*\xFE";
    z += "        If Tkno = C_lparen Then\xFE";
    z += "            Call Tcv(False)\xFE";
    z += "            Lattr = Expr(Type_estr, 1, C_comma:C_rparen)\xFE";
    z += "            If Lattr.SYM_TYPE = Type_cnum Or (Lattr.SYM_TYPE = Type_eNum And Lattr.SYM_FLAVOR = Flavor_equate) Then\xFE";
    z += "                Gattr.SYM_INDEX1 = Lattr.SYM_C\xFE";
    z += "            End Else Call Err('Integer constant expected')\xFE";
    z += "\xFE";
    z += "            If Tkno = C_comma Then\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Lattr = Expr(Type_estr, 1, C_comma:C_rparen)\xFE";
    z += "                If Lattr.SYM_TYPE = Type_cnum Or (Lattr.SYM_TYPE = Type_eNum And Lattr.SYM_FLAVOR = Flavor_equate) Then\xFE";
    z += "                    Gattr.SYM_INDEX2 = Lattr.SYM_C\xFE";
    z += "                End Else Call Err('Integer constant expected')\xFE";
    z += "            End\xFE";
    z += "            If Tkno <> C_rparen Then Call Err(') expected.. found ') Else Call Tcv(False)\xFE";
    z += "            Gattr.SYM_ISCONST = 0\xFE";
    z += "            \xFE";
    z += "        End Else If Ismat Then\xFE";
    z += "            Gattr.SYM_INDEX1 = -1\xFE";
    z += "            Gattr.SYM_INDEX2 = -1\xFE";
    z += "            Gattr.SYM_ISCONST = 0\xFE";
    z += "        End\xFE";
    z += "        \xFE";
    z += "        If Tkstr = \"AS\" Then\xFE";
    z += "            Call parseAStype(Gattr)\xFE";
    z += "        End Else\xFE";
    z += "            Gattr.SYM_TYPE = Type_var\xFE";
    z += "        End\xFE";
    z += "*\xFE";
    z += "* CHECK FOR PREVIOUS DEFINITION\xFE";
    z += "*\xFE";
    z += "        previousDef = Clone(Symtab[Gattr.SYMNAME])\xFE";
    z += "        If previousDef Then\xFE";
    z += "            Gattr.SYM_JSOBJ = previousDef.SYM_JSOBJ Or optionsInternal\xFE";
    z += "            Gattr.SYM_C = previousDef.SYM_C\xFE";
    z += "            Gattr.SYM_ISBYVAL = Gattr.SYM_ISBYVAL Or previousDef.SYM_ISBYVAL\xFE";
    z += "            Gattr.SYM_USED += previousDef.SYM_USED\xFE";
    z += "            Gattr.SYM_TYPES := previousDef.SYM_TYPES\xFE";
    z += "            GATTR.SYM_ISCONST += previousDef.SYM_ISCONST\xFE";
    z += "            if previousDef.SYM_INCLEVEL < GATTR.SYM_INCLEVEL Then GATTR.SYM_INCLEVEL = previousDef.SYM_INCLEVEL\xFE";
    z += "            \xFE";
    z += "            If previousDef.SYM_FLAVOR = Flavor_parameter Or Type_flavor = Flavor_parameter Then\xFE";
    z += "                Gattr.SYM_FLAVOR = Flavor_parameter\xFE";
    z += "                \xFE";
    z += "            End ElseIf previousDef.SYM_FLAVOR = Flavor_common Or Type_flavor = Flavor_common Then\xFE";
    z += "                Gattr.SYM_FLAVOR = Flavor_common\xFE";
    z += "                \xFE";
    z += "            End ElseIf Type_flavor = Flavor_external Or optionsInternal Then\xFE";
    z += "                ' OK to declare twice (look ahead from $options)\xFE";
    z += "                \xFE";
    z += "            Else\xFE";
    z += "                Call Err(\"Already declared\")\xFE";
    z += "            End\xFE";
    z += "        End If\xFE";
    z += "        \xFE";
    z += "        If Gattr.SYM_FLAVOR = Flavor_parameter Then\xFE";
    z += "            Locate Gattr.SYMNAME In Paramlist Setting Spot Else\xFE";
    z += "                Spot = UBound(ParamList) + 1\xFE";
    z += "                Paramlist[-1] = Gattr.SYMNAME\xFE";
    z += "            End If\xFE";
    z += "        \xFE";
    z += "            Gattr.SYM_USED = 1\xFE";
    z += "            Gattr.SYM_TYPES = Symtypes_stored\xFE";
    z += "            if !Gattr.SYM_ISBYVAL Then Gattr.SYM_C = \"ByRef_\":Makevarname(Gattr.SYMNAME)\xFE";
    z += "\xFE";
    z += "\xFE";
    z += "        Else If Gattr.SYM_FLAVOR = Flavor_common Then\xFE";
    z += "            F = Gattr.SYMNAME\xFE";
    z += "            F = Makevarname(F)\xFE";
    z += "            // Gattr.SYM_C = \"Commons_\":UCase(Cur_realfname):\"_\":Makevarname(Subname):\".\":F\xFE";
    z += "            Gattr.SYM_C = \"Commons_\":UCase(Cur_realfname):\".\":F\xFE";
    z += "\xFE";
    z += "        Else If Gattr.SYM_FLAVOR = Flavor_external Or optionsInternal Then\xFE";
    z += "            Gattr.SYM_TYPES = Symtypes_stored\xFE";
    z += "            \xFE";
    z += "        Else If Gattr.SYM_FLAVOR = Flavor_local Then\xFE";
    z += "            Gattr.SYM_C = Makevarname(Gattr.SYMNAME)\xFE";
    z += "\xFE";
    z += "        Else\xFE";
    z += "            debug\xFE";
    z += "        End If\xFE";
    z += "        \xFE";
    z += "        * CHANGE VSTR TO CSTR\xFE";
    z += "        If Gattr.SYM_ISCONST Then\xFE";
    z += "            If Gattr.SYM_FLAVOR = Flavor_external Then\xFE";
    z += "                I = Index(Type_vstr:Type_vnum,Gattr.SYM_TYPE,1)\xFE";
    z += "                * Do not allow address ops on constant externals <> [], etc_\xFE";
    z += "                If I Then\xFE";
    z += "                    Gattr.SYM_TYPE = (Type_cstr:Type_cnum)[I,1]\xFE";
    z += "                End\xFE";
    z += "            End\xFE";
    z += "        End\xFE";
    z += "        \xFE";
    z += "        Call Writesym(Gattr, Gattr.SYMNAME)\xFE";
    z += "\xFE";
    z += "        if !Gattr.isAlreadyDefined And Process_commas And (Gattr.SYM_FLAVOR = Flavor_common Or Gattr.SYM_FLAVOR = Flavor_local) Then\xFE";
    z += "            if Sep = ',' Then \xFE";
    z += "                Oc := ', ' \xFE";
    z += "            ElseIf Gattr.SYM_FLAVOR = Flavor_local Then\xFE";
    z += "                Oc := 'var '\xFE";
    z += "            End If\xFE";
    z += "            \xFE";
    z += "            Gattr.isAlreadyDefined = true\xFE";
    z += "            Call Writesym(Gattr, Gattr.SYMNAME)\xFE";
    z += "            \xFE";
    z += "            If Tkstr = \"=\" Then\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Lattr = Expr(Type_estr, 1, C_comma)\xFE";
    z += "                Call Store(Gattr, Lattr)\xFE";
    z += "                Sep = ';'\xFE";
    z += "\xFE";
    z += "            else\xFE";
    z += "                If Gattr.SYM_TYPE = Type_vstr Then\xFE";
    z += "                    oc := Gattr.SYM_C:\" = ''\"\xFE";
    z += "                    Sep = ','\xFE";
    z += "                    \xFE";
    z += "                ElseIf Gattr.SYM_FLAVOR = Flavor_common Then\xFE";
    z += "                    Sep = \";\"\xFE";
    z += "                    \xFE";
    z += "                Else\xFE";
    z += "                    oc := Gattr.SYM_C:' = undefined'\xFE";
    z += "                    Sep = ','\xFE";
    z += "                End if\xFE";
    z += "            End If\xFE";
    z += "        Else\xFE";
    z += "            If Tkstr = \"=\" Then\xFE";
    z += "                Call Tcv(False)\xFE";
    z += "                Lattr = Expr(Type_estr, 1, C_comma)\xFE";
    z += "                Call Store(Gattr, Lattr)\xFE";
    z += "                Sep = ';'\xFE";
    z += "            End If\xFE";
    z += "        End if\xFE";
    z += "\xFE";
    z += "    While Tkno = C_comma And Process_commas Do\xFE";
    z += "        Call Tcv(False)\xFE";
    z += "    Repeat\xFE";
    z += "    \xFE";
    z += "    if Sep = ',' Then oc := '; '\xFE";
    z += "    La = La[1,Len(La)-1]\xFE";
    z += "    Return\xFE";
    z += "end sub\xFE";
    z += "\xFE";
    z += "Subroutine Defineequates\xFE";
    z += "\xFE";
    z += "    $Insert _comms\xFE";
    z += "*\xFE";
    z += "    Call Tcv(False)\xFE";
    z += "    Loop\xFE";
    z += "        If Tkno < C_ident Then Call Err('Identifier expected') ; Break\xFE";
    z += "        Orgname = Tkstr\xFE";
    z += "        Symname = Tkstr\xFE";
    z += "        Symname = Makesubname(Symname)\xFE";
    z += "        Aexpr = {}\xFE";
    z += "        Call Tcv(False)\xFE";
    z += "        If Not(Index(C_to:C_equal,Tkno,1)) Then\xFE";
    z += "            Call Err('TO expected')\xFE";
    z += "            Break\xFE";
    z += "        End\xFE";
    z += "\xFE";
    z += "        Call Tcv(False)\xFE";
    z += "        Aexpr = Expr(Type_cstr, 1, C_comma)\xFE";
    z += "\xFE";
    z += "        Aexpr.SYMNAME = Orgname\xFE";
    z += "        Aexpr.SYM_FLAVOR = Flavor_equate\xFE";
    z += "        Aexpr.SYM_USED = 1\xFE";
    z += "        Aexpr.SYM_TYPES = Symtypes_stored\xFE";
    z += "        Aexpr.SYM_EQUATE = Aexpr.SYM_C\xFE";
    z += "        Aexpr.SYM_INCLEVEL = Incfile\xFE";
    z += "        Aexpr.SYM_ISCONST = Index(Type_cnum:Type_cstr, Aexpr.SYM_TYPE, 1)\xFE";
    z += "        If Aexpr.SYM_ISCONST Then\xFE";
    z += "            If Incfile>0 or Functiontype = -1 Then \xFE";
    z += "                Aexpr.SYM_C = \"Equates_\":UCase(Cur_realfname):\".\":Symname\xFE";
    z += "            Else\xFE";
    z += "                Aexpr.SYM_C = Symname\xFE";
    z += "            End If\xFE";
    z += "        End If\xFE";
    z += "        \xFE";
    z += "        Bexpr = readsym(Orgname)\xFE";
    z += "        \xFE";
    z += "        If readSymFound Then Call Err('Symbol already defined') Else Call Writesym(Aexpr, Orgname)\xFE";
    z += "\xFE";
    z += "        If functionType = 0 Then\xFE";
    z += "            If Aexpr.SYM_ISCONST Then\xFE";
    z += "                Oc = Oc:Aexpr.SYM_C:' = ':Aexpr.SYM_EQUATE:\"; \"\xFE";
    z += "            End Else\xFE";
    z += "                Oc = Oc:'// ':Aexpr.SYMNAME:' is expanded inline as ':Aexpr.SYM_C:\";\"\xFE";
    z += "            End If\xFE";
    z += "        End If\xFE";
    z += "    While Tkno = C_comma Do\xFE";
    z += "        Call Tcv(False)\xFE";
    z += "    Repeat\xFE";
    z += "End Subroutine\xFE";
    z += ""
    window.cached_jsb2js["typedef"] = z;
    var z = "Subroutine updateCrossReference(newDef)\xFE";
    z += "End Sub\xFE";
    z += "\xFE";
    z += "Sub afterHeaderParse()\xFE";
    z += "    $Insert _comms\xFE";
    z += "\xFE";
    z += "    NeedToRecompileMyCallers = \"\"\xFE";
    z += "\xFE";
    z += "    // We need to reload this each time as $options external func ass to this list\xFE";
    z += "    externals_purejs_list = externals_txt\xFE";
    z += "    UC_externals_purejs_list = UCase(externals_txt)\xFE";
    z += "\xFE";
    z += "    if functionType != 2 And functionType != 1 then return\xFE";
    z += "    \xFE";
    z += "    Locate UCase(Truesubname) In UC_externals_purejs_list Setting externalDef Then oldTrueName = externals_purejs_list<externalDef> Else externalDef = 0\xFE";
    z += "\xFE";
    z += "    if externalDef Then\xFE";
    z += "        if oldTrueName <> Truesubname Then\xFE";
    z += "            NeedToRecompileMyCallers := 'config_jsb2js updated with correct casing of ':Truesubname:'; '\xFE";
    z += "            externals_txt<externalDef> = Truesubname\xFE";
    z += "        end if\xFE";
    z += "        Subname = Truesubname\xFE";
    z += "        dontMorphFunctionName = True\xFE";
    z += "    end if\xFE";
    z += "    \xFE";
    z += "    If dontMorphFunctionName Then \xFE";
    z += "        // Make sure we don't conflict with anything in jsblib.js\xFE";
    z += "        If !Jsblib_src Then\xFE";
    z += "            Read Jsblib_src From Fhandle('js'), 'jsblib.js' Else Jsblib_src = ''\xFE";
    z += "        End If\xFE";
    z += "        \xFE";
    z += "        If Instr(Jsblib_src, 'function ':Truesubname:'(') Then\xFE";
    z += "            Call Err('function ':Truesubname:'() conflicts with jsblib.js')\xFE";
    z += "        Else\xFE";
    z += "            Ss = Am():'var ':Truesubname\xFE";
    z += "            I = Instr(Jsblib_src, Ss)\xFE";
    z += "            If I Then\xFE";
    z += "                Nc = Mid(Jsblib_src, I + Len(Ss), 1)\xFE";
    z += "                If !isAlpha(Nc) Then Call Warning('var ':Truesubname:' may conflict with jsblib.js')\xFE";
    z += "            End If\xFE";
    z += "        End If\xFE";
    z += "        \xFE";
    z += "        // Make sure casing in config_jsb2js is correct for what we have defined\xFE";
    z += "        if !externalDef Then\xFE";
    z += "            NeedToRecompileMyCallers = 'Added ':Truesubname:' to \"config_jsb2js\"; '\xFE";
    z += "            externals_txt<-1> = Truesubname\xFE";
    z += "        End If\xFE";
    z += "    Else\xFE";
    z += "        if externalDef then\xFE";
    z += "            if oldTrueName = Truesubname and Truesubname = UCase(Truesubname) Then\xFE";
    z += "                NeedToRecompileMyCallers = oldTrueName:\" is not longer has $options ijs; need to update dependencies\"\xFE";
    z += "                externals_txt = Delete(externals_txt, externalDef)\xFE";
    z += "            end if\xFE";
    z += "        end if\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    if NeedToRecompileMyCallers Then   \xFE";
    z += "        Write externals_txt On fJsbConfig, 'config_jsb2js' Else Alert(@Errors)\xFE";
    z += "\xFE";
    z += "        externals_purejs_list = externals_txt\xFE";
    z += "        UC_externals_purejs_list = UCase(externals_txt)\xFE";
    z += "        \xFE";
    z += "        if functionType = 2 Then \xFE";
    z += "            xrefID = LCase(subName):\"_fnc\"\xFE";
    z += "        Else if functionType = 1 Then \xFE";
    z += "            xrefID = LCase(subName):\"_sub\"\xFE";
    z += "        Else if functionType = 0 Then \xFE";
    z += "            xrefID = LCase(subName):\"_pgm\"\xFE";
    z += "        Else\xFE";
    z += "            Return\xFE";
    z += "        End if\xFE";
    z += "        \xFE";
    z += "        MyOldDef = readXRef(xrefID:'.def') \xFE";
    z += "        if MyOldDef Then\xFE";
    z += "            if MyOldDef.SUB_ISCALLEDBY then Call Warning(NeedToRecompileMyCallers)\xFE";
    z += "            call addToCompileList(MyOldDef.SUB_ISCALLEDBY, NeedToRecompileMyCallers)\xFE";
    z += "        end if\xFE";
    z += "    end if\xFE";
    z += "End Sub\xFE";
    z += "\xFE";
    z += "\xFE";
    z += "*********************************************************************************************************************\xFE";
    z += "* Updates: SUB_CALLSTO, SUB_ISCALLEDBY, SUB_PARAMTYPES\xFE";
    z += "*\xFE";
    z += "* Called at end of routine compile\xFE";
    z += "*\xFE";
    z += "Subroutine updateCrossReference(newDef)\xFE";
    z += "    $Insert _comms\xFE";
    z += "\xFE";
    z += "    // -1) COMMONS, 0) PROGRAM, 1) SUBROUTINE, 2) FUNCTION, 3) @@FUNCTION, 4) PICK/RESTFUL FUNCTION \xFE";
    z += "\xFE";
    z += "    fName = newDef.SUB_FNAME ;* Alreaded made true and lowercase\xFE";
    z += "    iName = newDef.SUB_INAME\xFE";
    z += "    Isjs = newDef.SUB_NOAWAITSALLOWED\xFE";
    z += "    \xFE";
    z += "    newDef.SUB_PARAMTYPES = Replace(newDef.SUB_PARAMTYPES, Am(), \",\")\xFE";
    z += "    \xFE";
    z += "    subName = fName:\"_\":newDef.SUB_SUBNAME\xFE";
    z += "\xFE";
    z += "    if newDef.SUB_ISFUNCTION = 2 Then \xFE";
    z += "        xrefID = LCase(subName):\"_fnc\"\xFE";
    z += "    Else if newDef.SUB_ISFUNCTION = 1 Then \xFE";
    z += "        xrefID = LCase(subName):\"_sub\"\xFE";
    z += "    Else if newDef.SUB_ISFUNCTION = 0 Then \xFE";
    z += "        xrefID = LCase(subName):\"_pgm\"\xFE";
    z += "    Else\xFE";
    z += "        Return\xFE";
    z += "    End if\xFE";
    z += "   \xFE";
    z += "    // This isn't necessary other than for maintaining the XREF list - skip if we don't have the file\xFE";
    z += "    If !fXRefs Then Return\xFE";
    z += "    \xFE";
    z += "    // Read our previous def\xFE";
    z += "    MyOldDef = readXRef(xrefID:'.def') \xFE";
    z += "    If MyOldDef Then\xFE";
    z += "        If MyOldDef.SUB_FNAME <> newDef.SUB_FNAME And MyOldDef.SUB_FNAME <> \"\" Then\xFE";
    z += "            Call Warning(\"You have '\":subName:\"' defined in two files: \":MyOldDef.SUB_FNAME : \" and \" : newDef.SUB_FNAME:\".\")\xFE";
    z += "        End If\xFE";
    z += "    Else \xFE";
    z += "        MyOldDef = {}\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    // Update our new .def record \xFE";
    z += "    newDef.SUB_ISCALLEDBY = MyOldDef.SUB_ISCALLEDBY\xFE";
    z += "    if WriteXRef(xrefID:\".def\", newDef) Else \xFE";
    z += "        Print @Errors\xFE";
    z += "        Return\xFE";
    z += "    end if\xFE";
    z += "    \xFE";
    z += "    \xFE";
    z += "    // See who we don't call anymore, and remove ourselves from their calllists\xFE";
    z += "    ///////////////////////////////////////////////////////////////////////////\xFE";
    z += "    dim old_CallsTo As Array = Split(MyOldDef.SUB_CALLSTO, ',')\xFE";
    z += "    commonCall = []\xFE";
    z += "    For Each fullFileAndSubName In Calllist\xFE";
    z += "        Locate fullFileAndSubName In old_CallsTo Setting Spot Then\xFE";
    z += "            commonCall[-1] = fullFileAndSubName\xFE";
    z += "            old_CallsTo.DELETE(Spot)\xFE";
    z += "        End If\xFE";
    z += "    Next\xFE";
    z += "\xFE";
    z += "    myCallingID = Lcase(fName:\"*\":iName:\"*\":subName:\"*\":xrefID)\xFE";
    z += "    For Each fullFileAndSubName In old_CallsTo\xFE";
    z += "        Pdef = readXRef(fullFileAndSubName:'.def')\xFE";
    z += "        if Pdef Then\xFE";
    z += "            isCalledBy = Split(Pdef.SUB_ISCALLEDBY, \"|\")\xFE";
    z += "            Locate myCallingID In isCalledBy Setting Spot Then\xFE";
    z += "                isCalledBy = Delete(isCalledBy, 1, Spot)\xFE";
    z += "                Pdef.SUB_ISCALLEDBY = Join(isCalledBy, \",\")\xFE";
    z += "                if writeXRef(fullFileAndSubName:'.def', Pdef) Else Stop @Errors\xFE";
    z += "            end if\xFE";
    z += "        End\xFE";
    z += "    Next\xFE";
    z += "    \xFE";
    z += "    // Let all the routines in our active CallList know that we call them\xFE";
    z += "    ///////////////////////////////////////////////////////////////////////////\xFE";
    z += "    For Each fullFileAndSubName In Calllist\xFE";
    z += "        Xdef = readXRef(fullFileAndSubName:'.def') \xFE";
    z += "        if xdef Then\xFE";
    z += "            isCalledBy = Split(Xdef.SUB_ISCALLEDBY, \"|\")\xFE";
    z += "            Locate myCallingID In isCalledBy Else\xFE";
    z += "                isCalledBy[-1] = myCallingID\xFE";
    z += "                Xdef.SUB_ISCALLEDBY = Join(isCalledBy, \"|\")\xFE";
    z += "                if writeXRef(fullFileAndSubName:'.def', Xdef) Else Stop @Errors\xFE";
    z += "            End If\xFE";
    z += "        End If\xFE";
    z += "    Next\xFE";
    z += "\xFE";
    z += "    // If we went from being an async function to not being one, or vica-verse, need to recompile anyone that calls us\xFE";
    z += "    if MyOldDef.SUB_ISCALLEDBY Then\xFE";
    z += "        if MyOldDef.SUB_NOAWAITSALLOWED <> newDef.SUB_NOAWAITSALLOWED Then \xFE";
    z += "            NeedToRecompileMyCallers = \"Async function type changed from \":MyOldDef.SUB_NOAWAITSALLOWED:\" to \":newDef.SUB_NOAWAITSALLOWED:\" in \":subName:\"; \"\xFE";
    z += "            \xFE";
    z += "        Elseif Len(MyOldDef.SUB_PARAMTYPES) <> Len(newDef.SUB_PARAMTYPES) Then \xFE";
    z += "            NeedToRecompileMyCallers = \"Parameters count changed from \":MyOldDef.SUB_PARAMTYPES:\" to \":newDef.SUB_PARAMTYPES:\" in \":subName:\"; \"\xFE";
    z += "     \xFE";
    z += "        Elseif LCase(MyOldDef.SUB_PARAMTYPES) <> LCase(newDef.SUB_PARAMTYPES) Then \xFE";
    z += "            NeedToRecompileMyCallers = \"ByRef / ByVal Parameters changed from \":MyOldDef.SUB_PARAMTYPES:\" to \":newDef.SUB_PARAMTYPES:\" in \":subName:\"; \"\xFE";
    z += "        \xFE";
    z += "        Elseif MyOldDef.SUB_PARAMTYPES <> newDef.SUB_PARAMTYPES Then \xFE";
    z += "            NeedToRecompileMyCallers = \"Parameters types changed from \":MyOldDef.SUB_PARAMTYPES:\" to \":newDef.SUB_PARAMTYPES:\" in \":subName:\"; \"\xFE";
    z += "         \xFE";
    z += "        Elseif MyOldDef.SUB_OPTIONALPARAMCNT <> newDef.SUB_OPTIONALPARAMCNT Then\xFE";
    z += "            NeedToRecompileMyCallers := \"Optional parameter count changed from \":MyOldDef.SUB_OPTIONALPARAMCNT:\" to \":newDef.SUB_OPTIONALPARAMCNT:\" in \":subName:\"; \"\xFE";
    z += "        end if\xFE";
    z += "            \xFE";
    z += "        //if MyOldDef.SUB_RTNTYPE <> newDef.SUB_RTNTYPE Then NeedToRecompileMyCallers := \"function return type changed; \"\xFE";
    z += "        \xFE";
    z += "        if NeedToRecompileMyCallers Then\xFE";
    z += "            call addToCompileList(MyOldDef.SUB_ISCALLEDBY, NeedToRecompileMyCallers)\xFE";
    z += "        end if\xFE";
    z += "    End If\xFE";
    z += "    \xFE";
    z += "    Return\xFE";
    z += "End Subroutine\xFE";
    z += "\xFE";
    z += "\xFE";
    z += "Sub addToCompileList(byval calledByList, byVal Reason)\xFE";
    z += "    $Insert _comms\xFE";
    z += "    if !calledByList Then return\xFE";
    z += "    \xFE";
    z += "    cl = Split(calledByList, \"|\")\xFE";
    z += "    \xFE";
    z += "    print \"Appending \":UBound(cl):\" items to compilelist because \":Reason\xFE";
    z += "    \xFE";
    z += "    xrefID = Field(xrefID, '.def', 1)\xFE";
    z += "    \xFE";
    z += "    \xFE";
    z += "    for each CallerID in Cl\xFE";
    z += "        calledByFName = Field(CallerID, '*', 1)\xFE";
    z += "        calledByIName = Field(CallerID, '*', 2)\xFE";
    z += "        calledBySubName = Field(CallerID, '*', 3)\xFE";
    z += "        calledByXDefID = Field(CallerID, '*',4)\xFE";
    z += "        \xFE";
    z += "        recompileID = calledByFName:vm():calledByIName\xFE";
    z += "        Locate recompileID in Itemlist Setting Spot Then Itemlist = Delete(Itemlist, Spot)\xFE";
    z += "        Itemlist[-1] = recompileID\xFE";
    z += "        print calledByIName:\" \":\xFE";
    z += "    Next\xFE";
    z += "    Print\xFE";
    z += "    \xFE";
    z += "end function\xFE";
    z += "\xFE";
    z += ""
    window.cached_jsb2js["updatecrossreference"] = z;
    window.cached_jsb2js["writexref"] = "function writeXRef(byval xdefID as string, byval d as json) \xFE    $Insert _comms\xFE    \xFE    xdefID = LCase(xdefID)\xFE    cached_XRefs[xdefID] = d\xFE    \xFE    // If we don't know the FNAME, then we can't be sure where this routine is really located (may be BF, HTML)\xFE    if !d.SUB_FNAME then \xFE        // we may just be updating SUB_ISCALLEDBY \xFE        return true\xFE    end if\xFE    \xFE    writejson d on fXRefs, xdefID else return false\xFE    \xFE    return true\xFEend function\xFE";
    window.cached_jsb2js["xref"] = "Program XRef\xFE    If !@IsAdmin Then Stop 'You must be an admin to run this'\xFE    \xFE    specificRoutine = LCase(Field(Field(@Sentence, ' ', 2), \"(\", 1))\xFE    If !specificRoutine Then stop \"xref identifier\"\xFE    \xFE    select fHandle(\"jsb_jsxrefs\") where \"ItemId Like '[\":specificRoutine:\"]'\" else stop @Errors\xFE    \xFE    if !system(11) then stop \"no match\"\xFE    execute \"L ItemID,SrcEdit,SUB_FNAME,SUB_INAME,SUB_FIRSTLINE,SUB_CNAME,SUB_NOAWAITS,SUB_MAYBENOAWAITSUB,NotASyncFunction, SUB_CALLSTO, isCalledBy From jsb_jsxrefs order by SUB_FNAME, SUB_INAME\"\xFEEnd Program\xFE";
    var z = "*\xFE";
    z += "    Equ Am To Char(254) ; Equ Vm To Char(253) ; Equ Svm To Char(252)\xFE";
    z += "    Equ Tab To Char(9)\xFE";
    z += "    Equ Dftstrlen To 'StringSize'\xFE";
    z += "*\xFE";
    z += "* ENUM OF FLAVOR_TYPES\xFE";
    z += "*\xFE";
    z += "    Equ Flavor_parameter To 1 ;* this Is A Parameter Definition\xFE";
    z += "    Equ Flavor_equate To 2 ;* this Is An Equate Variable\xFE";
    z += "    Equ Flavor_common To 3 ;* this Is A Common Variable\xFE";
    z += "    Equ Flavor_gotolbl To 4 ;* this Is A Goto Label\xFE";
    z += "    Equ Flavor_temp To 5 ;* Temp Item In Symtab\xFE";
    z += "    Equ Flavor_local To 6 ;* Local Variable\xFE";
    z += "    Equ Flavor_external To 7 ;* External Variable\xFE";
    z += "    Equ Flavor_function To 8 ;* Definition For function To Type\xFE";
    z += "*\xFE";
    z += "* SYM_TYPE (EXPRESSION ARE UPPERCASE FOR READABILITY)\xFE";
    z += "*          (VARIABLES  ARE LOWERCASE FOR READABILITY)\xFE";
    z += "\xFE";
    z += "* -------------- Variant VARIABLE ------------------------\xFE";
    z += "    Equ Type_var To \"v\"\xFE";
    z += "    Equ Type_exp To \"?\"\xFE";
    z += "\xFE";
    z += "* -------------- Numbers ------------------------\xFE";
    z += "    Equ Type_cnum To \"c\"\xFE";
    z += "    Equ Type_vnum To \"n\"\xFE";
    z += "    Equ Type_eNum To \"N\"\xFE";
    z += "    Equ Type_vBool To \"b\"\xFE";
    z += "    Equ Type_eBool To \"B\"\xFE";
    z += "\xFE";
    z += "    * -------------- STRINGS (SIZED) ------------------------\xFE";
    z += "    Equ Type_cstr To 'S'\xFE";
    z += "    Equ Type_vstr To \"s\"\xFE";
    z += "    Equ Type_estr To \"$\"\xFE";
    z += "    *\xFE";
    z += "    Equ Type_dc       To \"-\" ;* Used For Makestr(X) To Prevent Making Suggestions\xFE";
    z += "*\xFE";
    z += "* SYM_TYPES\xFE";
    z += "*\xFE";
    z += "    Equ Symtypes_stored To \"7\" ;* Used Only For Sym_types\xFE";
    z += "    Equ Symtypes_temp   To \"L\" ;* Used For Goto Labels\xFE";
    z += "\xFE";
    z += "*\xFE";
    z += "* Await / Promise\xFE";
    z += "*\xFE";
    z += "    Common hasPromises As Array \xFE";
    z += "    Common externals_purejs_list                ;*  config_jsb2js (pure js - no ByRefs, no promises)\xFE";
    z += "    Common externals_txt As String              ;* pure version without $options external's added\xFE";
    z += "    Common UC_externals_purejs_list As String   ;* UpperCase Of externals_purejs_list\xFE";
    z += "    Common ByRefsNotAllowed As Boolean          ;* Indicates that the routine has no ByRef parameters 't a async routine (\"IJS\", \"BYREFS-\")\xFE";
    z += "    Common NotASyncFunction As Boolean          ;* Indicates that the routine isn't a async routine, therefore can't call any ASync functions ($options \"IJS\", \"ASYNC-\")\xFE";
    z += "    Common dontMorphFunctionName As Boolean     ;* Indicates that the routine name should not be altered (\"IJS\")\xFE";
    z += "    Common hasByRefParamters As Integer\xFE";
    z += "    Common optionalParamCnt As Integer    \xFE";
    z += "    Common Paramlist As Array                   ;* Names of parameters and optional parameters in order\xFE";
    z += "    Common ItemList As Array\xFE";
    z += "*   \xFE";
    z += "******************************************************************\xFE";
    z += "*\xFE";
    z += "* ERROR REPORTING\xFE";
    z += "*\xFE";
    z += "******************************************************************\xFE";
    z += "    Common Cpassthru As Long ;* Cpassthru As Long\xFE";
    z += "    Common Errcnt As Long ;* Total # Of Errors Found\xFE";
    z += "    Common Errors As String ;* Errors ;* Description (Multi-Am) Of Errors\xFE";
    z += "    Common Errline As String ;* Errline ;* Line Line # Of An Error\xFE";
    z += "    Common oneTimeError\xFE";
    z += "    Common MatLoadSize\xFE";
    z += "*\xFE";
    z += "* LEXER VARIABLES\xFE";
    z += "*\xFE";
    z += "    Common Haslbl As Integer\xFE";
    z += "    Common Tmpvari As Integer ;* Reset Each Statement, For function Results\xFE";
    z += "    Common Options As String ;* Comand Line Options\xFE";
    z += "    \xFE";
    z += "    Common Tkno As Char ;* Tkno ;* Single Character Token\xFE";
    z += "    Common Otkstr As String ;* Tkstr ;* Last Token String\xFE";
    z += "    Common Tkstr As String ;* Tkstr ;* Last Token String\xFE";
    z += "    Common Tkam As Long ;* Tkam ;* Current Lexer Line #\xFE";
    z += "    Common Tkstartpos\xFE";
    z += "    Common Tkpos As Long ;* Tkpos ;* Current Lexer Line Position\xFE";
    z += "    Common La As String ;* La ;* String Of Tokens For Look-Ahead\xFE";
    z += "    Common Mobjectdelemeter As String\xFE";
    z += "    Common Lineno As Long ;* Lineno ;* Debugging Lineno To Output\xFE";
    z += "    Common Itemid As String ;* Itemid ;* Current Item Name\xFE";
    z += "    Common Oc As String ;* Oc ;* Output C Code\xFE";
    z += "    Common Localvars As String ;* Localvars\xFE";
    z += "    Common Indent As Long ;* Indent ;* Current Indention\xFE";
    z += "    Common Incfile As Long ;* Incfile ;* Current Include File Number [1__N]\xFE";
    z += "    Common functionType As Long ;* functionType ;* -1) Commons, 0) Program, 1) Subroutine, 2) function, 3) @@function, 4) Pick/RESTFUL function\xFE";
    z += "    \xFE";
    z += "    Common Calllist As String ;* Calllist ;* List Of Subroutines Called\xFE";
    z += "    Common Typeitem As String ;* Typeitem\xFE";
    z += "    Common Hadgosub As Long ;* Hadgosub\xFE";
    z += "    Common Filename As String ;* Filename ;* Current Prog File\xFE";
    z += "    Common Hadreturn As Long ;* Hadreturn\xFE";
    z += "    Common Addcmt As Boolean ;* Addcmt ;* Flag For Comments\xFE";
    z += "    Common Adddebugging As Boolean ;* Flag For Adding Line Numbers\xFE";
    z += "    Common Showlist As Boolean ;* Flag\xFE";
    z += "    Common Mr83 As Boolean\xFE";
    z += "    Common Simplestrings As Boolean\xFE";
    z += "    Common Funcattr\xFE";
    z += "    Common Errs As String ;* Errs\xFE";
    z += "    Common Nxtlbl As Long ;* Nxtlbl\xFE";
    z += "    Common Globals As Boolean\xFE";
    z += "    Common Tkline As String ;* Tkline\xFE";
    z += "    Common Lcllbl As Long ;* Lcllbl\xFE";
    z += "*\xFE";
    z += "    Common Small, Large As String ;* Small, Large\xFE";
    z += "    Common Upcase As Long ;* Upcase\xFE";
    z += "    Common Subname As String ;* Subname \xFE";
    z += "    Common Truesubname As String ;* Subname \xFE";
    z += "    Common Optionexplicit\xFE";
    z += "    Common Docatalog\xFE";
    z += "    Common Ispickfunction\xFE";
    z += "    Common Isrestfulfunction\xFE";
    z += "    Common Classname\xFE";
    z += "    Common Insideclass\xFE";
    z += "    Common Jsblib_src\xFE";
    z += "    Common Hush\xFE";
    z += "    Common incFilesSrc\xFE";
    z += "    Common readSymFound\xFE";
    z += "\xFE";
    z += "******************************************************************\xFE";
    z += "*\xFE";
    z += "* LEXICAL ANALYSIS VARIABLES\xFE";
    z += "*\xFE";
    z += "******************************************************************\xFE";
    z += "    Common Itemsrc As String ;* Itemsrc\xFE";
    z += "    Common Symbols As String ;* Symbols\xFE";
    z += "    Common Idsymbols As String ;* Idsymbols\xFE";
    z += "    Common Supress As Long ;* Supress\xFE";
    z += "    Common Cur_fname As String ;* Cur_fname\xFE";
    z += "    Common Cur_realfname As String\xFE";
    z += "    Common Ocpgm As String ;* Ocpgm\xFE";
    z += "*\xFE";
    z += "    Common Outputtypes As Long ;* Outputtypes ;* Write .SUG\xFE";
    z += "    Common Symtab ;* Symtab\xFE";
    z += "    Common Symhold(57) ;* Symhold\xFE";
    z += "    Common Usesug As Long ;* Usesug\xFE";
    z += "*\xFE";
    z += "* Platform record\xFE";
    z += "*\xFE";
    z += "    Common Hardcode As Long ;* Hardcode\xFE";
    z += "    Common Spaces As Long ;* Spaces ;* #Of Spaces Before Tkstr\xFE";
    z += "    Common Dcpp As Long ;* Dcpp ;* Handles Debug Inits\xFE";
    z += "    Common Blankok As Long ;* Blankok ;* Drop Excess Blank Lines\xFE";
    z += "    Common Osfiles As Long ;* Osfiles\xFE";
    z += "    Common Errpos As String ;* Errpos\xFE";
    z += "    Common Addlist As String ;* Addlist ;* List Of Items To Also Compile\xFE";
    z += "    Common Oldcalllist As String ;* Oldcalllist\xFE";
    z += "    Common Sugext As String ;* Sugext[10]\xFE";
    z += "    Common Dollarcnt As Long ;* Dollarcnt\xFE";
    z += "    Common F_file As FileHandle ;* F_file\xFE";
    z += "    Common F_ffile As FileHandle ;* F_ffile\xFE";
    z += "    Common D_file As FileHandle ;* dictionary of D_file\xFE";
    z += "    Common D_ffile As FileHandle ;* dictionary of D_ffile\xFE";
    z += "    Common fJsbConfig As FileHandle \xFE";
    z += "    Common Pcfname As String ;* Pcfname\xFE";
    z += "    Common Realpcfname As String\xFE";
    z += "    Common IgnoreErrors As Boolean\xFE";
    z += "    Common fXRefs as FileHandle\xFE";
    z += "    Common cached_XRefs As Json\xFE";
    z += "*\xFE";
    z += "* Lexer tokens\xFE";
    z += "*\xFE";
    z += "    Equ C_number To \"!\"\xFE";
    z += "    Equ C_str To '\"'\xFE";
    z += "    Equ C_unknown To \"#\"\xFE";
    z += "    Equ C_am To \"$\"\xFE";
    z += "    Equ C_sm To \"%\"\xFE";
    z += "*\xFE";
    z += "    Equ C_vm To \"&\"\xFE";
    z += "    Equ C_bang To \"'\"\xFE";
    z += "    Equ C_at To \"(\"\xFE";
    z += "    Equ C_pound To \")\"\xFE";
    z += "    * EQU C_DOLLAR TO \"*\" ;* NO LONGER USED\xFE";
    z += "    Equ C_percent To \"+\"\xFE";
    z += "    Equ C_circumflex To \",\"\xFE";
    z += "    Equ C_andsign To \"-\"\xFE";
    z += "    Equ C_asterisk To \".\"\xFE";
    z += "    Equ C_lparen To \"/\"\xFE";
    z += "    Equ C_rparen To \"0\"\xFE";
    z += "    Equ C_under To \"1\"\xFE";
    z += "    Equ C_plus To \"2\"\xFE";
    z += "    Equ C_minus To \"3\"\xFE";
    z += "    Equ C_equal To \"4\"\xFE";
    z += "    Equ C_lbrace To \"5\"\xFE";
    z += "    Equ C_rbrace To \"6\"\xFE";
    z += "    Equ C_squiggle To \"7\" ;* ~\xFE";
    z += "    Equ C_lbrack To \"8\"\xFE";
    z += "    Equ C_rbrack To \"9\"\xFE";
    z += "    Equ C_bsquote To \":\" ;* Used For Strings\xFE";
    z += "    Equ C_colon To \";\"\xFE";
    z += "    * EQU C_DQUOTE TO \"<\" ;* \" USED FOR STRINGS\xFE";
    z += "    Equ C_semi To \"=\"\xFE";
    z += "    * EQU C_SQUOTE TO \">\" ;* ' USED FOR STRINGS\xFE";
    z += "    Equ C_less To \"?\"\xFE";
    z += "    Equ C_great To \"@\"\xFE";
    z += "    Equ C_question To \"A\"\xFE";
    z += "    Equ C_comma To \"B\"\xFE";
    z += "    Equ C_period To \"C\"\xFE";
    z += "    Equ C_fslash To \"D\"\xFE";
    z += "    Equ C_bar To \"E\"\xFE";
    z += "    Equ C_bslash To \"F\"\xFE";
    z += "    Equ C_json To \"G\"\xFE";
    z += "*\xFE";
    z += "    Equ C_ident To \"I\"\xFE";
    z += "    Equ C_case To \"J\"\xFE";
    z += "    Equ C_else To \"K\"\xFE";
    z += "    Equ C_end To \"L\"\xFE";
    z += "    Equ C_from To \"M\"\xFE";
    z += "    Equ C_next To \"N\"\xFE";
    z += "    Equ C_off To \"O\"\xFE";
    z += "    Equ C_on To \"P\"\xFE";
    z += "    Equ C_repeat To \"Q\"\xFE";
    z += "    Equ C_then To \"R\"\xFE";
    z += "    Equ C_to To \"S\"\xFE";
    z += "    Equ C_until To \"T\"\xFE";
    z += "    Equ C_while To \"U\"\xFE";
    z += "    Equ C_or To \"V\"\xFE";
    z += "    Equ C_and To \"W\"\xFE";
    z += "    Equ C_match To \"X\"\xFE";
    z += "    Equ C_matches To \"Y\"\xFE";
    z += "    Equ C_cat To \"Z\"\xFE";
    z += "    Equ C_lt To \"[\"\xFE";
    z += "    Equ C_gt To \"|\"\xFE";
    z += "    Equ C_le To \"]\"\xFE";
    z += "    Equ C_ne To \"^\"\xFE";
    z += "    Equ C_ge To \"_\"\xFE";
    z += "    Equ C_eq To \"`\"\xFE";
    z += "    Equ C_step To \"a\"\xFE";
    z += "    Equ C_before To \"b\"\xFE";
    z += "    Equ C_setting To \"c\"\xFE";
    z += "    Equ C_by To \"d\"\xFE";
    z += "    Equ C_locked To \"e\"\xFE";
    z += "    Equ C_goto To \"f\"\xFE";
    z += "    Equ C_gosub To \"g\"\xFE";
    z += "    Equ C_do To \"h\"\xFE";
    z += "    Equ C_mat To \"i\"\xFE";
    z += "    Equ C_dblSlash To \"j\"\xFE";
    z += "    Equ C_error To \"k\"\xFE";
    z += "    Equ C_in To \"l\"\xFE";
    z += "    Equ C_capturing To \"m\"\xFE";
    z += "    Equ C_using To \"n\"\xFE";
    z += "    Equ C_with To \"o\"\xFE";
    z += "    Equ C_loop To \"p\"\xFE";
    z += "    Equ C_mod To \"q\"\xFE";
    z += "    Equ C_where To \"r\"\xFE";
    z += "    Equ C_default To \"s\"\xFE";
    z += "    Equ C_catch To \"t\"\xFE";
    z += "    Equ C_CmtBlock to \"u\"\xFE";
    z += ""
    window.cached_jsb2js["_comms"] = z;
}
anonymousFunc()
anonymousFunc = null