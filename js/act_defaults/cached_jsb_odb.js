anonymousFunc = function () {
window.cachedFileNames["jsb_odb"] = "jsb_odb"
if (!window.cached_jsb_odb) window.cached_jsb_odb = {}
var z="Program Attach\xFE";
 z+="    * $options aspxc-\xFE";
 z+="    // Dim ActiveAct As String = @Account\xFE";
 z+="    Dim accountName As String = Field(Field(@Sentence, \" \", 2), \"(\", 1)\xFE";
 z+="    If  !IsAdmin() Then Stop \"You are not an administrator\"\xFE";
 z+="    Clearselect\xFE";
 z+="     Call DetachDB(true)\xFE";
 z+="    If !@Jsb_odb.AttachDB(accountName) Then Stop @Errors\xFE";
 z+="    Print \"Attached to \":accountName\xFE";
 z+="End Program\xFE";
 z+="\xFE";
 z+="Program AttachDB\xFE";
 z+="* $options aspxc-\xFE";
 z+="    // Dim ActiveAct As String = @Account\xFE";
 z+="    Dim accountName As String = Field(Field(@Sentence, \" \", 2), \"(\", 1)\xFE";
 z+="    If  !IsAdmin() Then Stop \"You are not an administrator\"\xFE";
 z+="    Clearselect\xFE";
 z+="     Call DetachDB(true)\xFE";
 z+="    If !@Jsb_odb.AttachDB(accountName) Then Stop @Errors\xFE";
 z+="    Print \"Attached to \":accountName\xFE";
 z+="End Program\xFE";
 z+="\xFE";
 z+="Program DetachDB\xFE";
 z+="* $options aspxc-\xFE";
 z+="    Call DetachDB(true)\xFE";
 z+="End Program\xFE";
 z+="\xFE";
 z+="Program Detach\xFE";
 z+="* $options aspxc-\xFE";
 z+="    Call DetachDB(true)\xFE";
 z+="End Program\xFE";
 z+="\xFE";
 z+="function AttachDB(byval accountName As String) As Boolean\xFE";
 z+="    if system(1) = \"js\" then\xFE";
 z+="        if accountName = window.dbName then accountName = \"\"\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    If (!accountName) Then\xFE";
 z+="        Call DetachDB(false)\xFE";
 z+="        Return True\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    Dim httpAddress As String = @Jsb_odb.AttachRemoteDB(accountName, True)\xFE";
 z+="    \xFE";
 z+="    // Did we get an error?\xFE";
 z+="    If Left(httpAddress,1) = \"!\" Then Return False\xFE";
 z+="\xFE";
 z+="    // Did we attach?\xFE";
 z+="    If httpAddress Then Return True\xFE";
 z+="    \xFE";
 z+="    // Try internal attach\xFE";
 z+="    I_AttachDB accountName Then\xFE";
 z+="        @Session.AttachedDatabase = accountName\xFE";
 z+="        If System(1) = \"js\" Then window.saveAtSession()\xFE";
 z+="        Return True\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    If !accountName Then Return False\xFE";
 z+="    Dim realError As String = @Errors\xFE";
 z+="    \xFE";
 z+="    I_Open \"system\" to fSystem Else Return False\xFE";
 z+="    I_Read oldDef From fSystem, accountName Then @Errors = realError; Return False\xFE";
 z+="    \xFE";
 z+="    // Can we attempt a SQL attachment using a default config?\xFE";
 z+="    Dim dftAct As String = Jsbconfig('default.account')\xFE";
 z+="    If !dftAct Then @Errors = realError; Return False\xFE";
 z+="    If !Instr(dftAct, '<<databasename>>') Then @Errors = 'jsb_config default.account is missing <<databasename>>'; Return False\xFE";
 z+="    dftAct = Replace(dftAct, '<<databasename>>', accountName)\xFE";
 z+="    I_Write dftAct On fSystem, accountName Else Return False\xFE";
 z+="    \xFE";
 z+="    // Attemp http attach?\xFE";
 z+="    httpAddress = @Jsb_odb.AttachRemoteDB(accountName, True)\xFE";
 z+="    Dim Success As Boolean = Left(httpAddress,1) <> \"!\" And httpAddress\xFE";
 z+="    If !Success Then\xFE";
 z+="        // Try internal attach\xFE";
 z+="        I_AttachDB accountName Then Success = True\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    // Get rid of temporary account definition\xFE";
 z+="    Delete fSystem, accountName Else Null\xFE";
 z+="    \xFE";
 z+="    If Success Then\xFE";
 z+="        @Session.AttachedDatabase = accountName\xFE";
 z+="        If System(1) = \"js\" Then window.saveAtSession()\xFE";
 z+="    Else\xFE";
 z+="        @Errors = \"No such account \":accountName\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    Return Success\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="// \xFE";
 z+="// Returns \"!Error\", \"\", or httpAddress\xFE";
 z+="//   \"\": implies that the account isn't there\xFE";
 z+="//   \"!]\" implies error\xFE";
 z+="//   \".\" implies database is internal\xFE";
 z+="//\xFE";
 z+="function AttachRemoteDB(ByVal accountName As String, ByVal Permanent As Boolean) As String\xFE";
 z+="    accountName = LCase(accountName)\xFE";
 z+="    Dim httpAddressNSid As String \xFE";
 z+="    \xFE";
 z+="    Dim CachedAccounts As String = @Session.CachedAccounts\xFE";
 z+="    Locate accountName In CachedAccounts<1> Setting Spot Then\xFE";
 z+="        httpAddressNSid = Replace(CachedAccounts<2, Spot>, \"%%\", Chr(253))\xFE";
 z+="    Else\xFE";
 z+="\xFE";
 z+="        // A Q-PTR to another account -- attempt to attach to the account\xFE";
 z+="        Dim fSystem As Table\xFE";
 z+="        I_Open \"system\" To fSystem Else Return \"\"\xFE";
 z+="        \xFE";
 z+="        Dim QAct As String\xFE";
 z+="        I_Read QAct From fSystem, accountName Else Return \"\"\xFE";
 z+="\xFE";
 z+="        Dim A1 As String = UCase(QAct<1>)\xFE";
 z+="        Dim Provider As String = QAct<2>\xFE";
 z+="        Dim _Password = QAct<4>\xFE";
 z+="        Dim ProviderType As String = Left(A1, 1)\xFE";
 z+="        \xFE";
 z+="        If Left(A1,1) <> \"@\" Then\xFE";
 z+="            If ProviderType <> \"J\" And ProviderType <> \"P\" Then Return \"\"\xFE";
 z+="            If Provider = \".\" Then Return Provider\xFE";
 z+="            If Left(Provider, 2) = \"./\" Then\xFE";
 z+="                if ProviderType = \"F\" then return provider\xFE";
 z+="                if ProviderType = \"P\" then Provider = @jsbRoot:Mid(Provider, 3)\xFE";
 z+="            end if\xFE";
 z+="            If Left(Provider, 4) <> \"http\" And Left(Provider, 2) <> \"//\" Then @Errors = \"Bad MD QPtr: \":accountName; Return \"!\":@Errors\xFE";
 z+="            If Right(Provider, 1) <> \"/\" Then Provider = Provider:\"/\"\xFE";
 z+="        End If\xFE";
 z+="\xFE";
 z+="        // Prompt for Username / Password?\xFE";
 z+="        httpAddressNSid = promptForUserNameAndPassword(accountName, QAct)\xFE";
 z+="        If !httpAddressNSid Then Return \"!\":@Errors\xFE";
 z+="        \xFE";
 z+="        CachedAccounts<1, Spot> = accountName\xFE";
 z+="        CachedAccounts<2, Spot> = Replace(httpAddressNSid, Chr(253), \"%%\")\xFE";
 z+="        @Session.CachedAccounts = CachedAccounts\xFE";
 z+="\xFE";
 z+="        If Right(QAct<1>, 1) <> \"!\" And Len(_Password) Then\xFE";
 z+="            QAct<4> = Stx(Encode(_Password))\xFE";
 z+="            QAct<1> = QAct<1>:\"!\"\xFE";
 z+="            I_Write QAct On fSystem, accountName Else Null\xFE";
 z+="        End If\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    If Permanent Then\xFE";
 z+="        @Session.AttachedDatabase = accountName\xFE";
 z+="        If System(1) = \"js\" Then window.saveAtSession()\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    Return httpAddressNSid\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="function promptForUserNameAndPassword(ByVal accountName As String, ByVal QAct As String) As String\xFE";
 z+="    * $options aspxc\xFE";
 z+="    @Errors = \"No prompting for aspxc\"\xFE";
 z+="    return \"\"\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="// Returns httpAddressNSid string\xFE";
 z+="function promptForUserNameAndPassword(ByVal accountName As String, ByVal QAct As String) As String\xFE";
 z+="    * $options aspxc-\xFE";
 z+="\xFE";
 z+="    Dim A1 As String = UCase(QAct<1>)\xFE";
 z+="    Dim Provider As String = QAct<2>\xFE";
 z+="    Dim UserName As String = QAct<3>\xFE";
 z+="    Dim _Password As String = QAct<4>\xFE";
 z+="    Dim InitialDB As String = QAct<5>\xFE";
 z+="    Dim httpAddressNSid As String\xFE";
 z+="    Dim ProviderType As String = Left(A1, 1)\xFE";
 z+="    \xFE";
 z+="    If Right(A1, 1) = \"!\" Then\xFE";
 z+="        A1 = Left(A1, Len(A1) - 1)\xFE";
 z+="        try\xFE";
 z+="            P = Xts(_Password)\xFE";
 z+="            if stx(P) = _Password Then _Password = Decode(p)\xFE";
 z+="        end try\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    If Left(Provider, 2) = \"./\" And ProviderType = \"P\" then Provider = @jsbRoot:Mid(Provider, 3)\xFE";
 z+="    If Right(Provider, 1) <> \"/\" Then Provider = Provider:\"/\"\xFE";
 z+="    \xFE";
 z+="    If Instr(Provider, \"<<username>>\") Or Instr(Provider, \"<<password>>\") Then\xFE";
 z+="        If UserName = \"\" Or _Password = \"\" Then\xFE";
 z+="            Msg = \"Attach to database\"\xFE";
 z+="            Loop\xFE";
 z+="                Ans = @LoginBox(Msg, \"Login required to attach to \":accountName, \"\")\xFE";
 z+="                If Ans = Chr(27) Then \xFE";
 z+="                    @Errors = \"User Canceled Attach\"\xFE";
 z+="                    Return \"\"\xFE";
 z+="                End If\xFE";
 z+="                \xFE";
 z+="                Provider = QAct<2>\xFE";
 z+="                If Left(Provider, 2) = \"./\" And ProviderType = \"P\" then Provider = @jsbRoot:Mid(Provider, 3)\xFE";
 z+="                If Right(Provider, 1) <> \"/\" Then Provider = Provider:\"/\"\xFE";
 z+="                \xFE";
 z+="                Provider = Replace(Provider, \"<<username>>\", UserName)\xFE";
 z+="                Provider = Replace(Provider, \"<<password>>\", _Password)\xFE";
 z+="                \xFE";
 z+="                If Left(A1,1) = \"@\" Then\xFE";
 z+="                    Login = \"jsb_odb.\":Mid(A1, 2):\"_Login\"\xFE";
 z+="                    Call @Login(ByRef httpAddressNSid, ByVal Provider, ByVal UserName, ByVal _Password, ByVal InitialDB)\xFE";
 z+="                    If httpAddressNSid Then httpAddressNSid = A1:Vm():httpAddressNSid\xFE";
 z+="                Else\xFE";
 z+="                    httpAddressNSid = @Jsb_odb.rpc_Login(Provider, UserName, _Password, InitialDB)\xFE";
 z+="                End If\xFE";
 z+="                \xFE";
 z+="            While !httpAddressNSid Do\xFE";
 z+="                Msg = @Errors\xFE";
 z+="            Repeat\xFE";
 z+="            return httpAddressNSid\xFE";
 z+="        end if\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    Provider = Replace(Provider, \"<<username>>\", UserName)\xFE";
 z+="    Provider = Replace(Provider, \"<<password>>\", _Password)\xFE";
 z+="    \xFE";
 z+="    If Left(A1,1) = \"@\" Then\xFE";
 z+="        Login = \"jsb_odb.\":Mid(A1, 2):\"_Login\"\xFE";
 z+="        Call @Login(ByRef httpAddressNSid, ByVal Provider, ByVal UserName, ByVal _Password, ByVal InitialDB)\xFE";
 z+="        If httpAddressNSid Then httpAddressNSid = A1:Vm():httpAddressNSid\xFE";
 z+="    Else\xFE";
 z+="        httpAddressNSid = @Jsb_odb.rpc_Login(Provider, UserName, _Password, InitialDB)\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    return httpAddressNSid\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="Sub DetachDB(optional byval removeCache As Boolean)\xFE";
 z+="    Account = @Session.AttachedDatabase\xFE";
 z+="    If Account and removeCache Then\xFE";
 z+="        CachedAccounts = @Session.CachedAccounts\xFE";
 z+="        Locate Account In CachedAccounts<1> Setting Spot Then\xFE";
 z+="            httpAddress = Replace(CachedAccounts<2, Spot>, \"%%\", Chr(253))\xFE";
 z+="            If Left(httpAddress, 1) = \"@\" Then\xFE";
 z+="                Dim A1 As String = Field(httpAddress, Vm(), 1)\xFE";
 z+="                Dim LoginInfo As String = DropLeft(httpAddress, Vm())\xFE";
 z+="                Dim Dt As String = \"jsb_odb.\":Mid(A1, 2):\"_Logout\"\xFE";
 z+="                Dim Success As Boolean\xFE";
 z+="                Call @Dt(LoginInfo, Success)\xFE";
 z+="                If !Success Then Print @Errors\xFE";
 z+="            End If\xFE";
 z+="            \xFE";
 z+="            CachedAccounts = Delete(CachedAccounts, 2, Spot)\xFE";
 z+="            CachedAccounts = Delete(CachedAccounts, 1, Spot)\xFE";
 z+="            \xFE";
 z+="            @Session.CachedAccounts = CachedAccounts\xFE";
 z+="        End If\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    @Session.AttachedDatabase = \"\"\xFE";
 z+="    \xFE";
 z+="    // Try internal attach\xFE";
 z+="    I_AttachDB \"\" Else Print @Errors\xFE";
 z+="    Clearselect\xFE";
 z+="    \xFE";
 z+="    If System(1) = \"js\" Then window.saveAtSession()\xFE";
 z+="End Sub\xFE";
 z+=""
window.cached_jsb_odb["attach"]=z;
var z="\xFE";
 z+="function AttachDBextended(byval databaseName As String, optional ByVal systemDbTemplateName As String, optional ByRef connectionString As String, optional ByRef UserName As String, optional ByRef Password As String, optional ByRef InitialCatalog As String) As String\xFE";
 z+="    Dim attachedDB As String = @Session.AttachedDatabase\xFE";
 z+="    \xFE";
 z+="    attachdb \"\" Else Null\xFE";
 z+="    Dim fSystem As FileHandle\xFE";
 z+="    I_Open \"system\" to fSystem Else Return False\xFE";
 z+="    Dim sysrec As String = \"\"\xFE";
 z+="    \xFE";
 z+="    if !databaseName Or databaseName = @Account then \xFE";
 z+="        Dim databasePath As String = @Account\xFE";
 z+="    else\xFE";
 z+="        if !systemDbTemplateName then systemDbTemplateName = \"databaseBuilder_ro\"\xFE";
 z+="        \xFE";
 z+="        Attachdb \"db_\":databaseName Then \xFE";
 z+="            databasePath = \"db_\":databaseName\xFE";
 z+="        else\xFE";
 z+="            I_Read sysrec From fSystem, databaseName Then\xFE";
 z+="                Attachdb databaseName Else \xFE";
 z+="                    @Errors = \"Can't attach to \":databaseName; \xFE";
 z+="                    Attachdb attachedDB Else Null\xFE";
 z+="                    Return False \xFE";
 z+="                End If\xFE";
 z+="                \xFE";
 z+="                databasePath = databaseName\xFE";
 z+="\xFE";
 z+="            Else\xFE";
 z+="                Dim XX As String\xFE";
 z+="                I_Read xx From fSystem, \"db_\":databaseName Then \xFE";
 z+="                    @Errors = \"Can't attach to \":databaseName\xFE";
 z+="                    Attachdb attachedDB Else Null\xFE";
 z+="                    Return False \xFE";
 z+="                End If\xFE";
 z+="                \xFE";
 z+="                \xFE";
 z+="                I_Read sysrec From fSystem, systemDbTemplateName Else \xFE";
 z+="                    @Errors = \"Can't attach to \":databaseName\xFE";
 z+="                    Attachdb attachedDB Else Null\xFE";
 z+="                    Return False // no base to work from\xFE";
 z+="                End If\xFE";
 z+="                    \xFE";
 z+="                SysRec = ReplaceI(SysRec, \"ApplicationIntent=ReadOnly\", \"\")\xFE";
 z+="                \xFE";
 z+="                Dim Ice As String = \"Initial Catalog=\"\xFE";
 z+="                Dim I As Integer = Instr(sysrec, Ice)\xFE";
 z+="                If !I Then Stop \"Can't attach to \":databaseName\xFE";
 z+="                I += Len(Ice)\xFE";
 z+="                Dim E As Integer = instrI(I, sysrec, ';')\xFE";
 z+="                If !E Then E = Instr(I, sysrec, Am())\xFE";
 z+="                If !E Then \xFE";
 z+="                    @Errors = \"Can't attach to \":databaseName\xFE";
 z+="                    Attachdb attachedDB Else Null\xFE";
 z+="                    Return False\xFE";
 z+="                End If\xFE";
 z+="                \xFE";
 z+="                sysrec = Left(sysrec, I-1):databaseName:Mid(sysrec, E)\xFE";
 z+="                \xFE";
 z+="                databasePath = \"db_\":databaseName\xFE";
 z+="                I_Write sysrec On fSystem, databasePath Else Return False\xFE";
 z+="                \xFE";
 z+="                Attachdb databasePath Else \xFE";
 z+="                    Delete fSystem, databasePath Else Null\xFE";
 z+="                    @Errors = \"Can't attach to \":databaseName\xFE";
 z+="                    Attachdb attachedDB Else Null\xFE";
 z+="                    Return false\xFE";
 z+="                End If\xFE";
 z+="            End If\xFE";
 z+="        End If\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    // Successfully attached\xFE";
 z+="    if !sysrec then\xFE";
 z+="        I_Read sysrec From fSystem, databasePath Else Return databasePath\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    // Break-out sysrec:\xFE";
 z+="    //    Provider=SQLOLEDB.1;Data Source=ifwissql;Initial Catalog=IFWIS_MASTER;ApplicationIntent=ReadOnly;Password=xxx\xFE";
 z+="  \xFE";
 z+="    If UCase(Left(sysrec<1>, 1)) = \"D\" Then\xFE";
 z+="        connectionString= sysrec<2>\xFE";
 z+="        Username = sysrec<3>\xFE";
 z+="        Password = sysrec<4>\xFE";
 z+="        \xFE";
 z+="        Try\xFE";
 z+="            if Instr(sysrec<1>, \"!\") then Password = decode(xts(Password))\xFE";
 z+="        Catch Err\xFE";
 z+="        End Try\xFE";
 z+="        \xFE";
 z+="        connectionString = ReplaceI(connectionString, \"<<root>>\", @JSBRootDir)\xFE";
 z+="        connectionString = ReplaceI(connectionString, \"<<rootaccount>>\", @jsbrootactdir)\xFE";
 z+="        connectionString = ReplaceI(connectionString, \"<<app_data>>\", @JSBRootDir:\"App_Data\")\xFE";
 z+="        connectionString = ReplaceI(connectionString, \"<<bin>>\", @JSBRootDir:`bin`)\xFE";
 z+="        connectionString = ReplaceI(connectionString, \"<<database>>\", @JSBRootDir:`App_Data\\_database`)\xFE";
 z+="        connectionString = ReplaceI(connectionString, \"<<_database>>\", @JSBRootDir:`App_Data\\_database`)\xFE";
 z+="        connectionString = ReplaceI(connectionString, \"<<passwd>>\", Password)\xFE";
 z+="        connectionString = ReplaceI(connectionString, \"<<pwd>>\", Password)\xFE";
 z+="        connectionString = ReplaceI(connectionString, \"<<password>>\", Password)\xFE";
 z+="        connectionString = ReplaceI(connectionString, \"<<username>>\", Username)\xFE";
 z+="        connectionString = ReplaceI(connectionString, \"<<userid>>\", Username)\xFE";
 z+="\xFE";
 z+="        \xFE";
 z+="        // Check direct names used instead of attrbutes 3 and 4\xFE";
 z+="        Dim trimmedCS As String = connectionString\xFE";
 z+="        Loop While Instr(trimmedCS, \" =\") Do trimmedCS = Replace(trimmedCS, \" =\", \"=\") Repeat\xFE";
 z+="        Loop While Instr(trimmedCS, \" ;\") Do trimmedCS = Replace(trimmedCS, \" ;\", \";\") Repeat\xFE";
 z+="        Loop While Instr(trimmedCS, \"= \") Do trimmedCS = Replace(trimmedCS, \"= \", \"=\") Repeat\xFE";
 z+="        Loop While Instr(trimmedCS, \"; \") Do trimmedCS = Replace(trimmedCS, \"; \", \";\") Repeat\xFE";
 z+="\xFE";
 z+="        //  ODBC uses dbq=path; uid=admin; pwd=xxx\xFE";
 z+="        //  Access and Sql use User ID= and ...Password=\xFE";
 z+="        \xFE";
 z+="        Dim P As String = \"Password=\"; I = InStrI(trimmedCS, P)\xFE";
 z+="        If !I Then P = \"pwd=\"; I = InStrI(trimmedCS, P)\xFE";
 z+="        If I Then Password = Field(Mid(trimmedCS, I + Len(P)), \";\", 1)\xFE";
 z+="\xFE";
 z+="        Dim U As String = \"User ID=\"; I = InStrI(trimmedCS, U)\xFE";
 z+="        If !I Then U = \"uid=\"; I = InStrI(trimmedCS, U)\xFE";
 z+="        If I Then Username = Field(Mid(trimmedCS, I + Len(U)), \";\", 1)\xFE";
 z+="        \xFE";
 z+="        Dim IC As String = \"Initial Catalog=\"\xFE";
 z+="        I = InStrI(trimmedCS, IC)\xFE";
 z+="        If I Then InitialCatalog = Field(Mid(trimmedCS, I + Len(IC)), \";\", 1)\xFE";
 z+="        \xFE";
 z+="        Dim DBPath As String = \"Data Source=\"\xFE";
 z+="        I = InstrI(trimmedCS, DBPath)\xFE";
 z+="        If !I Then DBPath = \"dbq=\"; I = InstrI(trimmedCS, DBPath)\xFE";
 z+="        If I Then databasePath = Field(Mid(trimmedCS, I+Len(DBPath)), \";\", 1)\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    if left(databasePath, 1) = '\"' and Right(databasePath, 1) = '\"' Then \xFE";
 z+="        databasePath = Mid(databasePath, 2, Len(databasePath) - 2)\xFE";
 z+="    Else if left(databasePath, 1) = \"'\" and Right(databasePath, 1) = \"'\" Then \xFE";
 z+="        databasePath = Mid(databasePath, 2, Len(databasePath) - 2)\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    Return databasePath\xFE";
 z+="end function\xFE";
 z+=""
window.cached_jsb_odb["attachdbextended"]=z;
var z="/*\xFE";
 z+="   This bin protocol will create one large binary file, which is divided into three sections: bitTable, HashStorageSpace, and OverflowStorageSpace\xFE";
 z+="   File Names may be suffixed with |FileSize  (defaults to one gigibyte)\xFE";
 z+="   Note that items are limited in size to be no bigger than a block (less header info (about 80 bytes))\xFE";
 z+="*/\xFE";
 z+="\xFE";
 z+="Sub bin_db\xFE";
 z+="    * Just a place holder so we skip the compiler error\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub bin_Login(ByRef LoginInfo, ByVal Provider, ByVal UserName, ByVal _Password, ByVal InitialDB)\xFE";
 z+="    @Errors = \"Attaching to a bin FILE isn't possbile\"\xFE";
 z+="    LoginInfo = \"\"\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="// ==================================== Code to deal with files ====================================\xFE";
 z+="// ==================================== Code to deal with files ====================================\xFE";
 z+="// ==================================== Code to deal with files ====================================\xFE";
 z+="\xFE";
 z+="// Hybrid files are normal files, only their content is different.\xFE";
 z+="// The contents are hashed by itemid and placed into buckets of json structures\xFE";
 z+="// Each bucket is a collection of items { \"ItemID1\": \"...data...\", \"ItemID2\": \"...data...\", ... }\xFE";
 z+="//\xFE";
 z+="// FName may be suffixed with |fileSize|blkSize\xFE";
 z+="//\xFE";
 z+="Sub bin_Open(ByVal LoginInfo, ByVal DictData, ByVal pFName, ByRef fHandle, ByRef Success)\xFE";
 z+="\xFE";
 z+="    FName = Field(pFName, \"|\", 1)\xFE";
 z+="    newFileSize = Field(pFName, \"|\", 2)\xFE";
 z+="    newBlkSize = Field(pFName, \"|\", 3)\xFE";
 z+="    IName = Field(pFName, \"|\", 4)\xFE";
 z+="    if !IName Then IName = FieldRight(`\\`:FieldRight(\"/\":FName, \"/\"), `\\`)\xFE";
 z+="    \xFE";
 z+="    DictData = LCase(DictData)\xFE";
 z+="    If DictData = \"dict\" then \xFE";
 z+="       i_open \"dict\", FName to fHandle then Success = True Else Success = False\xFE";
 z+="       return\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    binFileSpecs = initBinFileIO(true, dictData, FName, IName, newFileSize, newBlkSize, version)\xFE";
 z+="    \xFE";
 z+="    if !binFileSpecs then\xFE";
 z+="        Success = False\xFE";
 z+="        Return\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    Success = True\xFE";
 z+="    fHandle = DictData:Am():FName:Am():IName:Am():binFileSpecs.binFileSize:Am():binFileSpecs.blkSize:Am():version\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub bin_CreateFile(ByVal LoginInfo, ByVal FileName, ByRef fHandle, ByRef Success)\xFE";
 z+="    I_CreateFile Field(FileName, \"|\", 1) Then\xFE";
 z+="        Call bin_Open(LoginInfo, \"\", FileName, fHandle, Success)\xFE";
 z+="    Else\xFE";
 z+="        Success = False\xFE";
 z+="    End If\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="function bin_reopen(ByVal fHandle, byRef binFileSpecs)\xFE";
 z+="    dictData = fHandle<1>\xFE";
 z+="    fName = fHandle<2>\xFE";
 z+="    iName = fHandle<3>\xFE";
 z+="    binFileSize = fHandle<4>\xFE";
 z+="    blkSize = fHandle<5>\xFE";
 z+="    version = fHandle<6>\xFE";
 z+="    \xFE";
 z+="    binFileSpecs = initBinFileIO(false, dictData, fName, iName, binFileSize, blkSize, version)\xFE";
 z+="    \xFE";
 z+="    i_open dictdata, fName to fHandle Then Return fHandle\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="Sub bin_ListFiles(LoginInfo, ByRef Result, ByRef Success)\xFE";
 z+="    // Normal list\xFE";
 z+="    I_ListFiles To Result Else Result = \"\"\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub bin_DeleteFile(ByVal fHandle, ByRef Success)\xFE";
 z+="    fHandle = bin_reopen(fHandle, binFileSpecs)\xFE";
 z+="    I_DeleteFile fHandle Then Success = 1 Else Success = 0\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub bin_ClearFile(ByVal fHandle, ByRef Success)\xFE";
 z+="    fHandle = bin_reopen(fHandle, binFileSpecs)\xFE";
 z+="    I_ClearFile fHandle Then Success = 1 Else Success = 0\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub bin_primarykeyname(ByVal fHandle, ByRef Result As String, ByRef Success As Boolean)\xFE";
 z+="    fHandle = bin_reopen(fHandle, binFileSpecs)\xFE";
 z+="    Result = primaryKeyName(fHandle)\xFE";
 z+="    Success = Result <> \"\"\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub bin_ReadJSon(ByRef Item, ByVal fHandle, ByVal IName, ByRef Success)\xFE";
 z+="    Call bin_ReadX(Item, fHandle, IName, Success, \"JSon\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub bin_ReadJSonU(ByRef Item, ByVal fHandle, ByVal IName, ByRef Success)\xFE";
 z+="    Call bin_ReadX(Item, fHandle, IName, Success, \"JSonU\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub bin_ReadXML(ByRef Item, ByVal fHandle, ByVal IName, ByRef Success)\xFE";
 z+="    Call bin_ReadX(Item, fHandle, IName, Success, \"XML\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub bin_ReadXMLU(ByRef Item, ByVal fHandle, ByVal IName, ByRef Success)\xFE";
 z+="    Call bin_ReadX(Item, fHandle, IName, Success, \"XMLU\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub bin_Read(ByRef Item, ByVal fHandle, ByVal IName, ByRef Success)\xFE";
 z+="    Call bin_ReadX(Item, fHandle, IName, Success, \"\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub bin_ReadU(ByRef Item, ByVal fHandle, ByVal IName, ByRef Success)\xFE";
 z+="    Call bin_ReadX(Item, fHandle, IName, Success, \"U\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub bin_ReadV(ByRef Item, ByVal fHandle, ByVal IName, ByVal AtrNo, ByRef Success)\xFE";
 z+="    Call bin_ReadX(Item, fHandle, IName, Success, \"\")\xFE";
 z+="    If !Success Then Return\xFE";
 z+="    Item = Item<AtrNo>\xFE";
 z+="    Return\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub bin_ReadVU(ByRef Item, ByVal fHandle, ByVal IName, ByVal AtrNo, ByRef Success)\xFE";
 z+="    Call bin_ReadX(Item, fHandle, IName, Success, \"U\")\xFE";
 z+="    If !Success Then Return\xFE";
 z+="    Item = Item<AtrNo>\xFE";
 z+="    Return\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub bin_ReadX(ByRef Item, ByVal fHandle, ByVal IName, ByRef Success, ByVal RType)\xFE";
 z+="    fHandle = bin_reopen(fHandle, binFileSpecs)\xFE";
 z+="    \xFE";
 z+="    Item = binReadFileEntry(binFileSpecs, IName)\xFE";
 z+="    if isNull(Item) Then @Errors = \"\"; Return\xFE";
 z+="    \xFE";
 z+="    If Left(RType, 1) = \"J\" Then\xFE";
 z+="        If isValidJson(Item) Then\xFE";
 z+="            Item = JSon(Item)\xFE";
 z+="        Else\xFE";
 z+="            Item = { ItemID: IName, ItemContent: Item }\xFE";
 z+="        End If\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    Success = True\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub bin_DeleteItem(ByVal fHandle, ByVal IName, ByRef Success)\xFE";
 z+="    fHandle = bin_reopen(fHandle, binFileSpecs)\xFE";
 z+="    Success = binDeleteFileEntry(binFileSpecs, IName)\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub bin_Write(ByVal Item, ByVal fHandle, ByVal IName, ByRef Success)\xFE";
 z+="    Call bin_WriteX(Item, fHandle, IName, Success, \"\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub bin_WriteU(ByVal Item, ByVal fHandle, ByVal IName, ByRef Success)\xFE";
 z+="    Call bin_WriteX(Item, fHandle, IName, Success, \"U\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub bin_WriteJSon(ByVal Item, ByVal fHandle, ByVal IName, ByRef Success)\xFE";
 z+="    Call bin_WriteX(Item, fHandle, IName, Success, \"JSon\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub bin_WriteJSonU(ByVal Item, ByVal fHandle, ByVal IName, ByRef Success)\xFE";
 z+="    Call bin_WriteX(Item, fHandle, IName, Success, \"JSonU\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub bin_WriteXml(ByVal Item, ByVal fHandle, ByVal IName, ByRef Success)\xFE";
 z+="    Call bin_WriteX(Item, fHandle, IName, Success, \"Xml\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub bin_WriteXmlU(ByVal Item, ByVal fHandle, ByVal IName, ByRef Success)\xFE";
 z+="    Call bin_WriteX(Item, fHandle, IName, Success, \"XmlU\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub bin_WriteX(ByVal Item, ByVal fHandle, ByVal IName, ByRef Success, ByVal wType)\xFE";
 z+="    fHandle = bin_reopen(fHandle, binFileSpecs)\xFE";
 z+="    Success = binWriteFileEntry(binFileSpecs, Item, IName)\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="// ==================================== Code to deal with selectlists ====================================\xFE";
 z+="// ==================================== Code to deal with selectlists ====================================\xFE";
 z+="// ==================================== Code to deal with selectlists ====================================\xFE";
 z+="\xFE";
 z+="Sub bin_Select(Cols, ByVal fHandle, ByVal WhereClause, ByRef Success)\xFE";
 z+="    fHandle = bin_reopen(fHandle, binFileSpecs)\xFE";
 z+="    ids = getItemIDList(binFileSpecs)\xFE";
 z+="    formlist ids\xFE";
 z+="    Success = 1\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub bin_SelectTo(Cols, ByVal fHandle, ByVal WhereClause, ByRef Sl, ByRef Success)\xFE";
 z+="    fHandle = bin_reopen(fHandle, binFileSpecs)\xFE";
 z+="    ids = getItemIDList(binFileSpecs)\xFE";
 z+="    if !ids then ids = []\xFE";
 z+="    formlist ids to Sl\xFE";
 z+="    Success = 1\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hyb_doSelectFilter(Cols, ByVal fHandle, ByVal WhereClause, ByRef Success, ByRef Results)\xFE";
 z+="    fHandle = bin_reopen(fHandle, binFileSpecs)\xFE";
 z+="    \xFE";
 z+="    // Build a list of item ids in \xFE";
 z+="    Results = []\xFE";
 z+="    // ...\xFE";
 z+="    // ...\xFE";
 z+="    \xFE";
 z+="    \xFE";
 z+="    Success = True\xFE";
 z+="    \xFE";
 z+="    if (!Cols And !WhereClause) Or (!Results) Then Return\xFE";
 z+="\xFE";
 z+="    Call ParseSqlColumns(WhereClause, false, IgnoreColumns, WhereHasFunctions, WhereHasOperators, usesItemContent, hasOrderBy)\xFE";
 z+="    Call ParseSqlColumns(COLS, true, DisplayColumns, ColumnsHasFunctions, ColumnsHasOperators, usesItemContent, ignoreorderby)\xFE";
 z+="\xFE";
 z+="    SelectedItemIDs = Results\xFE";
 z+="    Results = Null\xFE";
 z+="    \xFE";
 z+="    ' Need to read all items into SelectedItems\xFE";
 z+="    if WhereClause then\xFE";
 z+="        if !filterJsonArray(SelectedItemIDs, SelectedItems, WhereClause) Then Success = False; Return\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    if ColumnsHasFunctions or ColumnsHasOperators then\xFE";
 z+="        ' This will create an item in TMP, compile it, and run it to get the results\xFE";
 z+="        if !processColumns(DisplayColumns, SelectedItems, SelectedItemIDs) Then Success = False; Return\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    Results = { SelectedItemIDs: SelectedItemIDs }\xFE";
 z+="    Results.SelectedItems = SelectedItems\xFE";
 z+="    Results.OnlyReturnItemIDs = COLS = \"\"\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="// ==================================== Code to deal with the binary internal struture ====================================\xFE";
 z+="// ==================================== Code to deal with the binary internal struture ====================================\xFE";
 z+="// ==================================== Code to deal with the binary internal struture ====================================\xFE";
 z+="\xFE";
 z+="function binHashItemName(ByVal binFileSpecs, ByVal ItemName)\xFE";
 z+="    H = 0\xFE";
 z+="    \xFE";
 z+="    if binFileSpecs.version > 1 then\xFE";
 z+="        nn = \"\"\xFE";
 z+="        for i = 1 to len(itemName)\xFE";
 z+="           c = Asc(itemName[i,1])\xFE";
 z+="           if c > 'a' Then C -= Asc('a')\xFE";
 z+="           if c > 'A' Then C -= Asc('A')\xFE";
 z+="           if c > ' ' Then C -= Asc(' ')\xFE";
 z+="           nn := Chr(c)\xFE";
 z+="        next\xFE";
 z+="        \xFE";
 z+="        X = Stx(nn)\xFE";
 z+="    else\xFE";
 z+="    \xFE";
 z+="        X = Stx(ItemName)\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    for I = 1 to Len(X) Step 6\xFE";
 z+="       SixPack = X[I, 6]\xFE";
 z+="       H = H + Xtd(SixPack)\xFE";
 z+="    Next\xFE";
 z+="    \xFE";
 z+="    return H Mod binFileSpecs.dataSpaceBlocks\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="\xFE";
 z+="// Reopen binary file\xFE";
 z+="function binFileHandle(ByVal binFileSpecs)\xFE";
 z+="    i_open binFileSpecs.binDictData, binFileSpecs.binFileName to fHandle then return fHandle\xFE";
 z+="    return Null\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="// ==================================== Initializing the data structure that keeps track of our binary file ====================================\xFE";
 z+="// ==================================== Initializing the data structure that keeps track of our binary file ====================================\xFE";
 z+="// ==================================== Initializing the data structure that keeps track of our binary file ====================================\xFE";
 z+="\xFE";
 z+="function initBinFileIO(validateFileSpace, dictdata, binFileName, binItemName, newFileSize, newBlkSize, version)\xFE";
 z+="\xFE";
 z+="    if validateFileSpace then\xFE";
 z+="        Kilo = 1024\xFE";
 z+="        Mega = Kilo * Kilo\xFE";
 z+="        GigaByte =  Mega * Kilo\xFE";
 z+="        version = 2\xFE";
 z+="        \xFE";
 z+="        i_open dictdata, binFileName to fbinFHandle Else Return Null\xFE";
 z+="        \xFE";
 z+="        I_readblk realFileSpecs From fbinFHandle, binItemName, 0, 256 Then\xFE";
 z+="            if Left(realFileSpecs, 1) = \"*\" and Count(realFileSpecs, \"*\") = 3 Then\xFE";
 z+="                binFileSize = Val(field(realFileSpecs, \"*\", 2))\xFE";
 z+="                blkSize = Val(field(realFileSpecs, \"*\", 3))\xFE";
 z+="                \xFE";
 z+="            Elseif newFileSize Then\xFE";
 z+="                // old file\xFE";
 z+="                binFileSize = newFileSize\xFE";
 z+="                blkSize = newBlkSize\xFE";
 z+="                version = 1\xFE";
 z+="                \xFE";
 z+="            Else\xFE";
 z+="                if msgbox(\"You binary block file '\":binItemName:\"' is corrupt; Delete '\":binItemName:\"'?\", \"Yes,No\") <> \"Yes\" Then \xFE";
 z+="                   @Errors = \"Your parameters for your sdCard file \":binItemName:\" have changed.  Please reset them or delete this item\"\xFE";
 z+="                   msgbox(@Errors)\xFE";
 z+="                   return null\xFE";
 z+="                end if\xFE";
 z+="                delete fbinFHandle, binItemName else return Null\xFE";
 z+="                return initBinFileIO(validateFileSpace, dictdata, binFileName, binItemName, newFileSize, newBlkSize, version)\xFE";
 z+="            end if\xFE";
 z+="        Else\xFE";
 z+="            binFileSize = newFileSize\xFE";
 z+="            blkSize = newBlkSize\xFE";
 z+="        End if\xFE";
 z+="        \xFE";
 z+="        if !binFileSize Then \xFE";
 z+="            Ans = MsgBox(\"What size of binary file do you want\", \"1MB, 5MB, 50MB, 1GB, 2GB, 5GB, 10GB, 100GB\")\xFE";
 z+="            if !Ans or Ans = \"\" Then\xFE";
 z+="                @Errors = \"Aborted\"\xFE";
 z+="                return null\xFE";
 z+="            end if\xFE";
 z+="            \xFE";
 z+="            if right(ans, 2) = \"MB\" then binFileSize = Val(Ans) * Mega else binFileSize = Val(Ans) * GigaByte \xFE";
 z+="        end if\xFE";
 z+="        \xFE";
 z+="        if binFileSize < 5 * Mega Then binFileSize = 5 * Mega\xFE";
 z+="            \xFE";
 z+="\xFE";
 z+="    Else\xFE";
 z+="        binFileSize = newFileSize\xFE";
 z+="        blkSize = newBlkSize\xFE";
 z+="    End if\xFE";
 z+="\xFE";
 z+="    // We will limit item sizes to 32K if not given\xFE";
 z+="    if !blkSize Then blkSize = 32 * Kilo\xFE";
 z+="    if blkSize < 32 * Kilo Then blkSize = 32 * Kilo\xFE";
 z+="    \xFE";
 z+="    if version > 1 then bitTable1stBlockNo = 1 else bitTable1stBlockNo = 0\xFE";
 z+="    \xFE";
 z+="    // Compute bitTable, DataSpace, and then Overflow\xFE";
 z+="\xFE";
 z+="    // make about 25% of space for overflow\xFE";
 z+="    if version > 1 then overflowSize = CInt(binFileSize * .50) Else overflowSize = CInt(binFileSize * .20) \xFE";
 z+="    overflowSize = CInt(overflowSize / 8) * 8 ;* insure it is a multiple of 8 (no partial bytes in bit table)\xFE";
 z+="    overFlowBlocks = CInt(overflowSize / blkSize) + 1\xFE";
 z+="    \xFE";
 z+="    // determine a bitTableSize based on blkSize\xFE";
 z+="    bitTableSize = CInt((overFlowBlocks-1) / 8) + 1\xFE";
 z+="    bitTableBlks = CInt((bitTableSize-1) / blkSize) + 1\xFE";
 z+="    \xFE";
 z+="    // Compute overflow size (determined by size of bit table)\xFE";
 z+="    overFlowBlocks = bitTableSize * 8\xFE";
 z+="    overflowSize = overFlowBlocks * blkSize\xFE";
 z+="    \xFE";
 z+="    // reserved size is size of bitTableSize plus overflowSize\xFE";
 z+="    reservedBlks =  overFlowBlocks + bitTableBlks\xFE";
 z+="    \xFE";
 z+="    // remaining space is used for data\xFE";
 z+="    dataSpaceSize = binFileSize - (reservedBlks * blkSize)\xFE";
 z+="    dataSpaceBlocks = CInt((dataSpaceSize-1) / blkSize) + 1\xFE";
 z+="    dataSpaceSize = dataSpaceBlocks * blkSize\xFE";
 z+="    \xFE";
 z+="    // ===   ===   ===   ===   ===  Compute offsets of each of the 3 spaces  ===   ===   ===   ===   === \xFE";
 z+="    \xFE";
 z+="    dataSpace1stBlockNo = bitTable1stBlockNo + bitTableBlks\xFE";
 z+="    overFlow1stBlockNo = dataSpace1stBlockNo + dataSpaceBlocks\xFE";
 z+="    totalBlocks = overFlow1stBlockNo + overFlowBlocks\xFE";
 z+="\xFE";
 z+="    lastByteOffset = totalBlocks * blkSize - 1\xFE";
 z+="    \xFE";
 z+="    binFileSpecs = {\xFE";
 z+="        binDictData: dictdata,\xFE";
 z+="        binFileName: BINFILENAME,\xFE";
 z+="        binItemName: binItemName,\xFE";
 z+="        binFileSize: binFileSize,\xFE";
 z+="        blkSize: blkSize,\xFE";
 z+="        FileNameSize: 80,\xFE";
 z+="        totalBlocks: totalBlocks,\xFE";
 z+="        listIdName: \"*itemidlist*\",\xFE";
 z+="        \xFE";
 z+="        bitTable1stBlockNo: bitTable1stBlockNo,\xFE";
 z+="        bitTableSize: bitTableSize,\xFE";
 z+="        bitTableBlks: bitTableBlks,\xFE";
 z+="\xFE";
 z+="        // remaining space is used for data\xFE";
 z+="        dataSpace1stBlockNo: dataSpace1stBlockNo,\xFE";
 z+="        dataSpaceSize: dataSpaceSize,\xFE";
 z+="        dataSpaceBlocks: dataSpaceBlocks,\xFE";
 z+="        \xFE";
 z+="        // Compute overflow size (determine by size of bit table)\xFE";
 z+="        overFlow1stBlockNo: overFlow1stBlockNo,\xFE";
 z+="        overflowSize: overflowSize,\xFE";
 z+="        overFlowBlocks: overFlowBlocks,\xFE";
 z+="        \xFE";
 z+="        cachedMaxCnt: 10,\xFE";
 z+="        cachedBlockNos: [],\xFE";
 z+="        cachedBlocks: {}\xFE";
 z+="    }\xFE";
 z+="    \xFE";
 z+="    \xFE";
 z+="    if !validateFileSpace Then Return binFileSpecs\xFE";
 z+="    \xFE";
 z+="    // Make sure we can read last byte\xFE";
 z+="    I_readblk LastByte From fbinFHandle, binItemName, lastByteOffset, 1 Then\xFE";
 z+="        // if nothing beyond that, we'll call it good\xFE";
 z+="        I_readblk nonExistantByte From fbinFHandle, binItemName, lastByteOffset + 1, 1 Else Return binFileSpecs\xFE";
 z+="    End if\xFE";
 z+="    \xFE";
 z+="    // If it's not new file, tell user\xFE";
 z+="    I_readblk firstByte From fbinFHandle, binItemName, 0, 1 Then\xFE";
 z+="       if msgbox(\"You binary block file '\":binItemName:\"' is corrupt; Delete '\":binItemName:\"'?\", \"Yes,No\") <> \"Yes\" Then \xFE";
 z+="           @Errors = \"Your parameters for your sdCard file \":binItemName:\" have changed.  Please reset them or delete this item\"\xFE";
 z+="           msgbox(@Errors)\xFE";
 z+="           return null\xFE";
 z+="        end if\xFE";
 z+="\xFE";
 z+="        delete fbinFHandle, binItemName else return Null\xFE";
 z+="        return initBinFileIO(validateFileSpace, dictdata, binFileName, binItemName, newFileSize, newBlkSize, version)\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    if system(1) = \"aspx\" then \xFE";
 z+="        StepSize = CInt(GigaByte / 10)\xFE";
 z+="        if !StepSize Or StepSize > lastByteOffset Then StepSize = lastByteOffset\xFE";
 z+="        emptyBlk = Chr(0)\xFE";
 z+="    Else \xFE";
 z+="        if window.dotNetObj then\xFE";
 z+="            StepSize = CInt(GigaByte / 10)\xFE";
 z+="            if !StepSize Or StepSize > lastByteOffset Then StepSize = lastByteOffset\xFE";
 z+="            emptyBlk = Chr(0)\xFE";
 z+="        else\xFE";
 z+="            StepSize = blkSize\xFE";
 z+="            emptyBlk = strRpt(Chr(0), StepSize)\xFE";
 z+="        end if\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    Steps = CInt(lastByteOffset / StepSize) + 1\xFE";
 z+="    \xFE";
 z+="    b1 = @response.buffer()\xFE";
 z+="    \xFE";
 z+="    print @(-1):\"Creating \": CInt((lastByteOffset / GigaByte) * 10) / 10 :\" GigiByte binary File '\":binItemName:\"' in \":Steps:\" steps\"\xFE";
 z+="    print @Div(@ProgressBar('progressBarID', { style: 'position: absolute; width: 300px; top: 50%;' } ), { style: 'width: 300px; margin-left:auto; margin-right: auto' }):\xFE";
 z+="    \xFE";
 z+="    \xFE";
 z+="    Cnt = 1\xFE";
 z+="    b2 = @response.buffer()\xFE";
 z+="    Offset = blkSize\xFE";
 z+="    \xFE";
 z+="    fileSpecsBlk = \"*\":binFileSize:\"*\":blkSize:\"*\"\xFE";
 z+="    fileSpecsBlk := StrRpt(Chr(0), blkSize - Len(fileSpecsBlk))\xFE";
 z+="    \xFE";
 z+="    i_write \"\" On fbinFHandle, binItemName Else Return Null\xFE";
 z+="    I_writeblk fileSpecsBlk On fbinFHandle, binItemName, 0 Else \xFE";
 z+="        @Errors = \"initBinFileIO: I_WRITEBLK error (Offset: 0) on \":binItemName:Crlf():@Errors\xFE";
 z+="        msgbox(@Errors)\xFE";
 z+="        return null\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    Loop until Offset >= lastByteOffset Do\xFE";
 z+="        I_readblk someByte From fbinFHandle, binItemName, Offset, 1 Else \xFE";
 z+="            Print @updateProgressBar('progressBarID', Cnt, 1, Steps):; @Server.Flush\xFE";
 z+="            I_writeblk emptyBlk On fbinFHandle, binItemName, Offset Else \xFE";
 z+="                @Errors = \"initBinFileIO: I_WRITEBLK error (Offset: \":Offset:\") on \":binItemName:Crlf():@Errors\xFE";
 z+="                msgbox(@Errors)\xFE";
 z+="                return null\xFE";
 z+="            end if\xFE";
 z+="        End If\xFE";
 z+="        \xFE";
 z+="        Offset += StepSize\xFE";
 z+="        If Offset > lastByteOffset Then Offset = lastByteOffset\xFE";
 z+="        cnt += 1\xFE";
 z+="    Repeat\xFE";
 z+="    @response.buffer(b1)\xFE";
 z+="    \xFE";
 z+="    I_writeblk Chr(0) On fbinFHandle, binItemName, lastByteOffset Else \xFE";
 z+="        @Errors = \"initBinFileIO: I_WRITEBLK (lastByteOffset: \":lastByteOffset:\") error on \":binItemName:Crlf():@Errors\xFE";
 z+="        msgbox(@Errors)\xFE";
 z+="        return null\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    // Read byte we just write\xFE";
 z+="    I_readblk LastByte From fbinFHandle, binItemName, lastByteOffset, 1 Else \xFE";
 z+="        @Errors = \"initBinFileIO: unable to read byte just written\":Crlf():@Errors\xFE";
 z+="        msgbox(@Errors)\xFE";
 z+="        return null\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    // Validte\xFE";
 z+="    if LastByte <> Chr(0) Then \xFE";
 z+="        @Errors = \"initBinFileIO: Trailing zero missing on \":binItemName\xFE";
 z+="        msgbox(@Errors)\xFE";
 z+="        return null\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    // Shouldn't be anything past end of file\xFE";
 z+="    I_readblk LastByte From fbinFHandle, binItemName, lastByteOffset + 1, 1 Then \xFE";
 z+="        @Errors = \"initBinFileIO: binary file exceeds expected size\"\xFE";
 z+="        msgbox(@Errors)\xFE";
 z+="        return null\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    Return binFileSpecs\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="\xFE";
 z+="// ==================================== FileEntry routines are the level items and items ids ====================================\xFE";
 z+="// ==================================== FileEntry routines are the level items and items ids ====================================\xFE";
 z+="// ==================================== FileEntry routines are the level items and items ids ====================================\xFE";
 z+="\xFE";
 z+="// NextPosition will be setup for the following item only when an item is found\xFE";
 z+="function binReadFileEntry(binFileSpecs, FileName, optional blkNo, optional blk, optional AtPosition, optional NextPosition)\xFE";
 z+="    blkNo = binFileSpecs.dataSpace1stBlockNo + binHashItemName(binFileSpecs, FileName)\xFE";
 z+="    \xFE";
 z+="    Loop\xFE";
 z+="        blk = binReadBlock(binFileSpecs, blkNo)\xFE";
 z+="        \xFE";
 z+="        // Block is: nextBlkNo(4 bytes): [ ... file-Entrys ... ] \xFE";
 z+="        Position = 1\xFE";
 z+="        nextBlockNo = 0\xFE";
 z+="        nextBlockNo = nextBlockNo * 256 + Asc(blk[Position,1]); Position += 1\xFE";
 z+="        nextBlockNo = nextBlockNo * 256 + Asc(blk[Position,1]); Position += 1\xFE";
 z+="        nextBlockNo = nextBlockNo * 256 + Asc(blk[Position,1]); Position += 1\xFE";
 z+="        nextBlockNo = nextBlockNo * 256 + Asc(blk[Position,1]); Position += 1\xFE";
 z+="        \xFE";
 z+="        Loop\xFE";
 z+="            // fileentry is preAmble(1):FileEntryName(80):FileEntrySize(2 bytes):FileEntry:PostAmble(FF\xFE";
 z+="            AtPosition = Position\xFE";
 z+="            preAmble = blk[Position,1]; Position += 1\xFE";
 z+="            \xFE";
 z+="            if preAmble = chr(0) Then break\xFE";
 z+="            \xFE";
 z+="            if preAmble <> chr(1) then \xFE";
 z+="                @Errors = \"Preamble is corrupt in block\"\xFE";
 z+="                msgbox(@Errors)\xFE";
 z+="                return null\xFE";
 z+="            end if\xFE";
 z+="            \xFE";
 z+="            FileEntryName = blk[Position, binFileSpecs.FileNameSize]; Position += binFileSpecs.FileNameSize\xFE";
 z+="            ZeroPos = InStr(FileEntryName, Chr(2))\xFE";
 z+="            if ZeroPos then FileEntryName = Left(FileEntryName, ZeroPos-1)\xFE";
 z+="            \xFE";
 z+="            foundIt = LCase(FileName) = LCase(FileEntryName)\xFE";
 z+="            \xFE";
 z+="            FileEntrySize = 0\xFE";
 z+="            FileEntrySize = FileEntrySize * 256 + Asc(blk[Position,1]) ; Position += 1\xFE";
 z+="            FileEntrySize = FileEntrySize * 256 + Asc(blk[Position,1]) ; Position += 1\xFE";
 z+="    \xFE";
 z+="            if foundIt Then FileEntry = blk[position, FileEntrySize]\xFE";
 z+="            Position += FileEntrySize\xFE";
 z+="        \xFE";
 z+="            postAmble = blk[Position,1]; Position += 1\xFE";
 z+="            if FileEntrySize And postAmble <> chr(255) then \xFE";
 z+="                @Errors = \"postAmble is corrupt on FileEntry \":FileEntryName\xFE";
 z+="               msgbox(@Errors)\xFE";
 z+="               return null\xFE";
 z+="            end if\xFE";
 z+="            \xFE";
 z+="            if foundIt then \xFE";
 z+="                NextPosition = Position\xFE";
 z+="                return FileEntry\xFE";
 z+="            end if\xFE";
 z+="            \xFE";
 z+="        while Position < binFileSpecs.blkSize And FileEntryName Do Repeat\xFE";
 z+="    \xFE";
 z+="    While nextBlockNo do\xFE";
 z+="        blkNo = nextBlockNo\xFE";
 z+="    Repeat\xFE";
 z+="        \xFE";
 z+="    return NUll\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="sub updateItemIdList(binFileSpecs, FileName, isDelete)\xFE";
 z+="    if FileName = binFileSpecs.listIdName Then Return\xFE";
 z+="    \xFE";
 z+="    itemidlist = binReadFileEntry(binFileSpecs, binFileSpecs.listIdName)\xFE";
 z+="    if !itemidlist then itemidlist = \"\"\xFE";
 z+="    \xFE";
 z+="    locate filename in itemidlist setting spot then\xFE";
 z+="       if !isDelete Then return\xFE";
 z+="       itemidlist = delete(itemidlist, spot)\xFE";
 z+="    else\xFE";
 z+="       if isDelete Then Return\xFE";
 z+="       if Len(itemidlist) > 32000 Then Return\xFE";
 z+="       \xFE";
 z+="       itemidlist<-1> = FileName\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    binWriteFileEntry(binFileSpecs, itemidlist, binFileSpecs.listIdName)\xFE";
 z+="end sub\xFE";
 z+="\xFE";
 z+="function getItemIDList(binFileSpecs)\xFE";
 z+="    ids = binReadFileEntry(binFileSpecs, binFileSpecs.listIdName)\xFE";
 z+="    if len(ids) < 32000 Then return ids\xFE";
 z+="    \xFE";
 z+="    \xFE";
 z+="    return ids\xFE";
 z+="    \xFE";
 z+="    // slow way\xFE";
 z+="    ids = []\xFE";
 z+="    for dataBlkI = 0 to binFileSpecs.dataSpaceBlocks - 1\xFE";
 z+="        blkNo = binFileSpecs.dataSpace1stBlockNo + dataBlkI\xFE";
 z+="        \xFE";
 z+="        Loop\xFE";
 z+="            blk = binReadBlock(binFileSpecs, blkNo)\xFE";
 z+="            \xFE";
 z+="            // Block is: nextBlkNo(4 bytes): [ ... file-Entrys ... ] \xFE";
 z+="            Position = 1\xFE";
 z+="            nextBlockNo = 0\xFE";
 z+="            nextBlockNo = nextBlockNo * 256 + Asc(blk[Position,1]); Position += 1\xFE";
 z+="            nextBlockNo = nextBlockNo * 256 + Asc(blk[Position,1]); Position += 1\xFE";
 z+="            nextBlockNo = nextBlockNo * 256 + Asc(blk[Position,1]); Position += 1\xFE";
 z+="            nextBlockNo = nextBlockNo * 256 + Asc(blk[Position,1]); Position += 1\xFE";
 z+="            \xFE";
 z+="            Loop\xFE";
 z+="                // fileentry is preAmble(1):FileEntryName(80):FileEntrySize(2 bytes):FileEntry:PostAmble(FF\xFE";
 z+="                AtPosition = Position\xFE";
 z+="                preAmble = blk[Position,1]; Position += 1\xFE";
 z+="                \xFE";
 z+="                if preAmble = chr(0) Then break\xFE";
 z+="                \xFE";
 z+="                if preAmble <> chr(1) then \xFE";
 z+="                    @Errors = \"Preamble is corrupt in block\"\xFE";
 z+="                    msgbox(@Errors)\xFE";
 z+="                    return null\xFE";
 z+="                end if\xFE";
 z+="                \xFE";
 z+="                FileEntryName = blk[Position, binFileSpecs.FileNameSize]; Position += binFileSpecs.FileNameSize\xFE";
 z+="                ZeroPos = InStr(FileEntryName, Chr(2))\xFE";
 z+="                if ZeroPos then FileEntryName = Left(FileEntryName, ZeroPos-1)\xFE";
 z+="                \xFE";
 z+="                FileEntrySize = 0\xFE";
 z+="                FileEntrySize = FileEntrySize * 256 + Asc(blk[Position,1]) ; Position += 1\xFE";
 z+="                FileEntrySize = FileEntrySize * 256 + Asc(blk[Position,1]) ; Position += 1\xFE";
 z+="        \xFE";
 z+="                Position += FileEntrySize\xFE";
 z+="            \xFE";
 z+="                postAmble = blk[Position,1]; Position += 1\xFE";
 z+="                if FileEntrySize And postAmble <> chr(255) then \xFE";
 z+="                    @Errors = \"postAmble is corrupt on FileEntry \":FileEntryName\xFE";
 z+="                   msgbox(@Errors)\xFE";
 z+="                   return null\xFE";
 z+="                end if\xFE";
 z+="                \xFE";
 z+="                ids[-1] = FileEntryName\xFE";
 z+="            while Position < binFileSpecs.blkSize And FileEntryName Do Repeat\xFE";
 z+="        \xFE";
 z+="        While nextBlockNo do\xFE";
 z+="            blkNo = nextBlockNo\xFE";
 z+="        Repeat\xFE";
 z+="    Next\xFE";
 z+="    \xFE";
 z+="    return ids\xFE";
 z+="\xFE";
 z+="        \xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="function binWriteFileEntry(binFileSpecs, newData, FileName)\xFE";
 z+="    binDeleteFileEntry(binFileSpecs, FileName)\xFE";
 z+="    \xFE";
 z+="    // Search for a block that has enough space\xFE";
 z+="    blkNo = binFileSpecs.dataSpace1stBlockNo + binHashItemName(binFileSpecs, FileName)\xFE";
 z+="    FileNameSize = binFileSpecs.FileNameSize\xFE";
 z+="    dataLen = Len(newData)\xFE";
 z+="    \xFE";
 z+="    neededSpace = 1 + FileNameSize + 2 + dataLen + 1\xFE";
 z+="    \xFE";
 z+="    if neededSpace > binFileSpecs.blkSize Then\xFE";
 z+="        debug \xFE";
 z+="        @Errors = \"Item is too large\"\xFE";
 z+="        return null\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    Loop\xFE";
 z+="        RemainingSpace = binRemainingBlkSpace(binFileSpecs, blkNo, blk, EmptyPosition, nextBlockNo)\xFE";
 z+="        \xFE";
 z+="    Until neededSpace <= RemainingSpace Do\xFE";
 z+="        if !nextBlockNo Then\xFE";
 z+="            \xFE";
 z+="            // get some overflow\xFE";
 z+="            nextBlockNo = binGetOverflowBlk(binFileSpecs)\xFE";
 z+="            \xFE";
 z+="            if !nextBlockNo then \xFE";
 z+="                @Errors = \"Out of sd file free space in \": binFileSpecs.binItemName\xFE";
 z+="                return null\xFE";
 z+="            end if\xFE";
 z+="            \xFE";
 z+="            nbo = nextBlockNo\xFE";
 z+="            B4 = nbo mod 256; nbo = CInt(nbo / 256)\xFE";
 z+="            B3 = nbo mod 256; nbo = CInt(nbo / 256)\xFE";
 z+="            B2 = nbo mod 256; nbo = CInt(nbo / 256)\xFE";
 z+="            B1 = nbo mod 256; nbo = CInt(nbo / 256)\xFE";
 z+="            if nbo then debug ; // should be zero\xFE";
 z+="            \xFE";
 z+="            blk = chr(b1):chr(b2):chr(b3):chr(b4):Mid(blk, 5)\xFE";
 z+="            binWriteBlock(binFileSpecs, blkNo, blk)\xFE";
 z+="            \xFE";
 z+="            blk = StrRpt(Chr(0), binFileSpecs.blkSize)\xFE";
 z+="            binWriteBlock(binFileSpecs, nextBlockNo, blk)\xFE";
 z+="        end if\xFE";
 z+="        \xFE";
 z+="        blkNo = nextBlockNo\xFE";
 z+="    Repeat\xFE";
 z+="    \xFE";
 z+="    // Write new entry\xFE";
 z+="    preAmble = Chr(1)\xFE";
 z+="    newFileName = FileName:StrRpt(Chr(2), FileNameSize - Len(FileName))\xFE";
 z+="    \xFE";
 z+="    ascFileSize = Chr(CInt(dataLen / 256)) : Chr(dataLen mod 256)\xFE";
 z+="    postAmble = Chr(255)\xFE";
 z+="    \xFE";
 z+="    fileEntry = preAmble:newFileName:ascFileSize:newData:postAmble\xFE";
 z+="    if Len(FileEntry) <> neededSpace then debug\xFE";
 z+="    \xFE";
 z+="    newBlk = Left(blk, EmptyPosition-1):fileEntry\xFE";
 z+="    AddZeros = binFileSpecs.blkSize - len(newBlk)\xFE";
 z+="    newBlk := StrRpt(Chr(0), addZeros)\xFE";
 z+="    \xFE";
 z+="    binWriteBlock(binFileSpecs, blkNo, newBlk)\xFE";
 z+="    \xFE";
 z+="    Call updateItemIdList(binFileSpecs, FileName, False)\xFE";
 z+="    return True\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="function binDeleteFileEntry(binFileSpecs, FileName)\xFE";
 z+="    Entry = binReadFileEntry(binFileSpecs, FileName, blkNo, blk, atPosition, NextPosition)\xFE";
 z+="    if isNull(Entry) Then Return Null\xFE";
 z+="    \xFE";
 z+="    newBlk = Left(blk, atPosition-1)\xFE";
 z+="    \xFE";
 z+="    // move everything over the top of this entry\xFE";
 z+="    loop\xFE";
 z+="        nextEntry = binGetEntryAtPosition(binFileSpecs, blk, NextPosition, nextFileName)\xFE";
 z+="    while !IsNull(nextEntry) Do\xFE";
 z+="        preAmble = Chr(1)\xFE";
 z+="        nextFileName := StrRpt(Chr(2), binFileSpecs.FileNameSize - Len(nextFileName))\xFE";
 z+="        nextEntryLen = Len(nextEntry)\xFE";
 z+="        nextFileSize = Chr(CInt(nextEntryLen / 256)) : Chr(nextEntryLen mod 256)\xFE";
 z+="        postAmble = Chr(255)\xFE";
 z+="        \xFE";
 z+="        newBlk := preAmble:nextFileName:nextFileSize:nextEntry:postAmble\xFE";
 z+="    Repeat\xFE";
 z+="    \xFE";
 z+="    newBlk := StrRpt(Chr(0), binFileSpecs.blkSize - len(newBlk))\xFE";
 z+="    \xFE";
 z+="    binWriteBlock(binFileSpecs, blkNo, newBlk)\xFE";
 z+="    \xFE";
 z+="    Call updateItemIdList(binFileSpecs, FileName, True)\xFE";
 z+="    return True\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="// binGetEntryAtPosition: position outselves for a read, write, or delete\xFE";
 z+="function binGetEntryAtPosition(binFileSpecs, blk, Position, FileEntryName)\xFE";
 z+="    preAmble = blk[Position,1]; Position += 1\xFE";
 z+="    if preAmble = chr(0) then return NULL\xFE";
 z+="    \xFE";
 z+="    if preAmble <> chr(1) then \xFE";
 z+="        @Errors = \"Preamble is corrupt \":asc(preAmble)\xFE";
 z+="       msgbox(@Errors)\xFE";
 z+="       return null\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    FileEntryName = blk[Position, binFileSpecs.FileNameSize]; Position += binFileSpecs.FileNameSize\xFE";
 z+="    ZeroPos = InStr(FileEntryName, Chr(2))\xFE";
 z+="    if ZeroPos then FileEntryName = Left(FileEntryName, ZeroPos-1)\xFE";
 z+="    \xFE";
 z+="    FileEntrySize = 0\xFE";
 z+="    FileEntrySize = FileEntrySize * 256 + Asc(blk[Position,1]) ; Position += 1\xFE";
 z+="    FileEntrySize = FileEntrySize * 256 + Asc(blk[Position,1]) ; Position += 1\xFE";
 z+="\xFE";
 z+="    FileEntry = blk[position, FileEntrySize]\xFE";
 z+="    Position += FileEntrySize\xFE";
 z+="\xFE";
 z+="    postAmble = blk[Position,1]; Position += 1\xFE";
 z+="    if FileEntrySize And postAmble <> chr(255) then \xFE";
 z+="        @Errors = \"postAmble is corrupt on FileEntry \":FileEntryName\xFE";
 z+="           msgbox(@Errors)\xFE";
 z+="           return null\xFE";
 z+="        end if\xFE";
 z+="        \xFE";
 z+="    if FileEntrySize then return FileEntry\xFE";
 z+="    return Null\xFE";
 z+="end function        \xFE";
 z+="\xFE";
 z+="// ==================================== Blk routines deal with reading and writing segment blocks (all the same size) ====================================\xFE";
 z+="// ==================================== Blk routines deal with reading and writing segment blocks (all the same size) ====================================\xFE";
 z+="// ==================================== Blk routines deal with reading and writing segment blocks (all the same size) ====================================\xFE";
 z+="\xFE";
 z+="// BlockNo is 0..\xFE";
 z+="function binReadBlock(binFileSpecs, blockNo)\xFE";
 z+="    cachedBlockNos = binFileSpecs.cachedBlockNos\xFE";
 z+="    \xFE";
 z+="    sBlkNo = \"B\":BlockNo\xFE";
 z+="    locate sBlkNo in cachedBlockNos Setting Spot Then\xFE";
 z+="        if Spot <> 1 then\xFE";
 z+="            cachedBlockNos.Delete(Spot)\xFE";
 z+="            cachedBlockNos.Insert(1, sBlkNo)\xFE";
 z+="        end if\xFE";
 z+="        \xFE";
 z+="        return binFileSpecs.cachedBlocks[sBlkNo]\xFE";
 z+="    End if\xFE";
 z+="             \xFE";
 z+="    fbinFHandle = binFileHandle(binFileSpecs)\xFE";
 z+="    blkSize = binFileSpecs.blkSize\xFE";
 z+="    offset = blockNo * blkSize\xFE";
 z+="    ID = binFileSpecs.binItemName\xFE";
 z+="    \xFE";
 z+="    I_readblk blk From fbinFHandle, ID, offset, blkSize Else \xFE";
 z+="        @Errors = \"binReadBlock error: \":@Errors\xFE";
 z+="        msgbox(@Errors)\xFE";
 z+="        return null\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    if len(blk) <> blkSize then \xFE";
 z+="        @Errors = \"readblk size error\":len(blk)\xFE";
 z+="        msgbox(@Errors)\xFE";
 z+="        return null\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    binAddToCache(binFileSpecs, blockNo, Blk)\xFE";
 z+="    \xFE";
 z+="    if len(blk) <> blkSize then \xFE";
 z+="        @Errors = \"readblk size error\":len(blk)\xFE";
 z+="        msgbox(@Errors)\xFE";
 z+="        return null\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    \xFE";
 z+="    return blk\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="function binWriteBlock(binFileSpecs, blockNo, Blk)\xFE";
 z+="    fbinFHandle = binFileHandle(binFileSpecs)\xFE";
 z+="    blkSize = binFileSpecs.blkSize\xFE";
 z+="    offset = blockNo * blkSize\xFE";
 z+="    ID = binFileSpecs.binItemName\xFE";
 z+="    \xFE";
 z+="    if blockNo >= binFileSpecs.totalBlocks then msgbox(\"binWriteBlock out of range\"); debug\xFE";
 z+="    if len(blk) <> blkSize then msgbox(\"writeblk size error\":len(blk)); debug\xFE";
 z+="\xFE";
 z+="    I_writeBlk blk On fbinFHandle, ID, offset Else \xFE";
 z+="        @Errors = \"binWriteBlock error: \":@Errors\xFE";
 z+="        msgbox(@errors)\xFE";
 z+="        return null\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    binAddToCache(binFileSpecs, blockNo, Blk)\xFE";
 z+="    return true\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="\xFE";
 z+="function binRemainingBlkSpace(binFileSpecs, blkNo, blk, EmptyPosition, nextBlockNo)\xFE";
 z+="    blk = binReadBlock(binFileSpecs, blkNo)\xFE";
 z+="    \xFE";
 z+="    // Block is: nextBlkNo(4 bytes): [ ... file-Entrys ... ] \xFE";
 z+="    Position = 1\xFE";
 z+="    nextBlockNo = 0\xFE";
 z+="    nextBlockNo = nextBlockNo * 256 + Asc(blk[Position,1]); Position += 1\xFE";
 z+="    nextBlockNo = nextBlockNo * 256 + Asc(blk[Position,1]); Position += 1\xFE";
 z+="    nextBlockNo = nextBlockNo * 256 + Asc(blk[Position,1]); Position += 1\xFE";
 z+="    nextBlockNo = nextBlockNo * 256 + Asc(blk[Position,1]); Position += 1\xFE";
 z+="    \xFE";
 z+="    Loop\xFE";
 z+="        // fileentry is preAmble(1):FileEntryName(80):FileEntrySize(2 bytes):FileEntry:PostAmble(FF\xFE";
 z+="        EmptyPosition = Position\xFE";
 z+="        preAmble = blk[Position,1]; Position += 1\xFE";
 z+="        \xFE";
 z+="        if preAmble = chr(0) Then\xFE";
 z+="            // end of chain\xFE";
 z+="            RemainingSpace = binFileSpecs.blkSize - EmptyPosition + 1\xFE";
 z+="            return RemainingSpace\xFE";
 z+="        End If\xFE";
 z+="\xFE";
 z+="        if preAmble <> chr(1) then \xFE";
 z+="            @Errors = \"Preamble is corrupt in block\"\xFE";
 z+="            msgbox(@Errors)\xFE";
 z+="            break\xFE";
 z+="        end if\xFE";
 z+="        \xFE";
 z+="        FileEntryName = blk[Position, binFileSpecs.FileNameSize]; Position += binFileSpecs.FileNameSize\xFE";
 z+="        ZeroPos = InStr(FileEntryName, Chr(2))\xFE";
 z+="        if ZeroPos then FileEntryName = Left(FileEntryName, ZeroPos-1)\xFE";
 z+="        \xFE";
 z+="        if (!FileEntryName) Then\xFE";
 z+="            RemainingSpace = binFileSpecs.blkSize - EmptyPosition + 1\xFE";
 z+="            return RemainingSpace\xFE";
 z+="        end if\xFE";
 z+="        \xFE";
 z+="        FileEntrySize = 0\xFE";
 z+="        FileEntrySize = FileEntrySize * 256 + Asc(blk[Position,1]) ; Position += 1\xFE";
 z+="        FileEntrySize = FileEntrySize * 256 + Asc(blk[Position,1]) ; Position += 1\xFE";
 z+="\xFE";
 z+="        Position += FileEntrySize\xFE";
 z+="    \xFE";
 z+="        postAmble = blk[Position,1]; Position += 1\xFE";
 z+="        if postAmble <> chr(255) then \xFE";
 z+="            @Errors = \"postAmble is corrupt on FileEntry \":FileEntryName\xFE";
 z+="            msgbox(@Errors)\xFE";
 z+="            break\xFE";
 z+="        end if\xFE";
 z+="        \xFE";
 z+="    while Position < binFileSpecs.blkSize Do Repeat\xFE";
 z+="      \xFE";
 z+="        \xFE";
 z+="    // Out of bounds\xFE";
 z+="    return 0\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="function binAddToCache(binFileSpecs, blockNo, Blk)\xFE";
 z+="    if binFileSpecs.cachedMaxCnt < 1 then return null\xFE";
 z+="    \xFE";
 z+="    cachedBlockNos = binFileSpecs.cachedBlockNos\xFE";
 z+="    cachedBlocks = binFileSpecs.cachedBlocks\xFE";
 z+="    \xFE";
 z+="    sBlkNo = \"B\":BlockNo\xFE";
 z+="    \xFE";
 z+="    locate sBlkNo in cachedBlockNos Setting Spot Then cachedBlockNos.Delete(Spot)\xFE";
 z+="    \xFE";
 z+="    cachedBlockNos.Insert(1, sBlkNo)\xFE";
 z+="    cachedBlocks[sBlkNo] = Blk\xFE";
 z+="    \xFE";
 z+="    loop while UBound(cachedBlockNos) > binFileSpecs.cachedMaxCnt do\xFE";
 z+="        dBlkNo = CStr(cachedBlockNos[binFileSpecs.cachedMaxCnt+1])\xFE";
 z+="        cachedBlockNos.delete(binFileSpecs.cachedMaxCnt+1)\xFE";
 z+="        remove cachedBlocks, CStr(dBlkNo)\xFE";
 z+="    repeat \xFE";
 z+="    \xFE";
 z+="    return true\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="function binGetOverflowBlk(binFileSpecs)\xFE";
 z+="    for bitTblBlkNo = 0 to binFileSpecs.bitTableBlks-1\xFE";
 z+="        bitTblBlk = binReadBlock(binFileSpecs, binFileSpecs.bitTable1stBlockNo + bitTblBlkNo)\xFE";
 z+="        \xFE";
 z+="        if len(bitTblBlk) <> binFileSpecs.blkSize then debug\xFE";
 z+="        \xFE";
 z+="        previousByteCnt = bitTblBlkNo * binFileSpecs.blkSize\xFE";
 z+="        \xFE";
 z+="        for bitTblByteNo = 0 to binFileSpecs.blkSize-1\xFE";
 z+="            if previousByteCnt + bitTblByteNo >= binFileSpecs.bitTableSize then return NULL // FULL\xFE";
 z+="        \xFE";
 z+="            bitTblByte = Asc(bitTblBlk[bitTblByteNo+1, 1])\xFE";
 z+="            if bitTblByte <> 255 Then\xFE";
 z+="                // found a zero bit (indicating a free block)\xFE";
 z+="                for bitNo = 0 to 7\xFE";
 z+="                    bitMask = 2 ^ (7-bitNo)\xFE";
 z+="                    if bitAnd(bitTblByte, bitMask) = 0 Then\xFE";
 z+="                        bitTblByte = bitOr(bitTblByte, bitMask)\xFE";
 z+="\xFE";
 z+="                        if len(bitTblBlk) <> binFileSpecs.blkSize then debug\xFE";
 z+="                        \xFE";
 z+="                        bitTblBlk = Left(bitTblBlk, bitTblByteNo): Chr(bitTblByte) : Mid(bitTblBlk, bitTblByteNo+2)\xFE";
 z+="                        if len(bitTblBlk) <> binFileSpecs.blkSize then debug\xFE";
 z+="                        \xFE";
 z+="                        binWriteBlock(binFileSpecs, binFileSpecs.bitTable1stBlockNo + bitTblBlkNo, bitTblBlk)\xFE";
 z+="                        \xFE";
 z+="                        freeBlockNo = binFileSpecs.overFlow1stBlockNo + (bitTblBlkNo * binFileSpecs.blkSize) * 8\xFE";
 z+="                        freeBlockNo += bitTblByteNo * 8\xFE";
 z+="                        freeBlockNo += bitNo\xFE";
 z+="                        return freeBlockNo\xFE";
 z+="                    end if\xFE";
 z+="                next\xFE";
 z+="            end if\xFE";
 z+="        next\xFE";
 z+="    next\xFE";
 z+="    \xFE";
 z+="    return NULL // FULL\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="function binUsedOverflowCnt(binFileSpecs)\xFE";
 z+="    Cnt = 0\xFE";
 z+="    \xFE";
 z+="    for bitTblBlkNo = 0 to binFileSpecs.bitTableBlks-1\xFE";
 z+="        bitTblBlk = binReadBlock(binFileSpecs, binFileSpecs.bitTable1stBlockNo + bitTblBlkNo)\xFE";
 z+="        previousByteCnt = bitTblBlkNo * binFileSpecs.blkSize\xFE";
 z+="        \xFE";
 z+="        for bitTblByteNo = 0 to binFileSpecs.blkSize-1\xFE";
 z+="            if previousByteCnt + bitTblByteNo >= binFileSpecs.bitTableSize then return Cnt\xFE";
 z+="        \xFE";
 z+="            bitTblByte = Asc(bitTblBlk[bitTblByteNo+1, 1])\xFE";
 z+="            if bitTblByte Then\xFE";
 z+="                if bitTblByte = 255 Then\xFE";
 z+="                    Cnt += 8\xFE";
 z+="                Else\xFE";
 z+="                    for bitNo = 0 to 7\xFE";
 z+="                        bitMask = 2 ^ (7-bitNo)\xFE";
 z+="                        if bitAnd(bitTblByte, bitMask) Then Cnt += 1\xFE";
 z+="                    Next\xFE";
 z+="                End If\xFE";
 z+="            end if\xFE";
 z+="        next\xFE";
 z+="    next\xFE";
 z+="    \xFE";
 z+="    return Cnt\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="function binReleaseBlk(binFileSpecs, overFlowBlkNo)\xFE";
 z+="    if overFlowBlkNo < binFileSpecs.overFlow1stBlockNo Then debug // out of range\xFE";
 z+="    \xFE";
 z+="    relBlkNo = overFlowBlkNo - binFileSpecs.overFlow1stBlockNo\xFE";
 z+="    bitNo = relBlkNo mod 8\xFE";
 z+="    bitTblByteNo = CInt(relBlkNo / 8)\xFE";
 z+="    \xFE";
 z+="    if bitTblByteNo >= binFileSpecs.bitTableSize then debug // out of range\xFE";
 z+="    \xFE";
 z+="    \xFE";
 z+="    bitTblBlkNo = CInt(bitTblByteNo / binFileSpecs.blkSize)\xFE";
 z+="    bitTblByteNo = bitTblByteNo Mod binFileSpecs.blkSize\xFE";
 z+="    bitTblBlk = binReadBlock(binFileSpecs, binFileSpecs.bitTable1stBlockNo + bitTblBlkNo)\xFE";
 z+="    \xFE";
 z+="    bitTblByte = Asc(bitTblBlk[bitTblByteNo+1, 1])\xFE";
 z+="    \xFE";
 z+="    // Clear entry and write\xFE";
 z+="    bitMask = bitXOr(255, 2 ^ (7-bitNo))\xFE";
 z+="    bitTblByte = bitAnd(bitTblByte, bitMask)\xFE";
 z+="    bitTblBlk = Left(bitTblBlk, bitTblByteNo): Chr(bitTblByte) : Mid(bitTblBlk, bitTblByteNo+2)\xFE";
 z+="\xFE";
 z+="    binWriteBlock(binFileSpecs, binFileSpecs.bitTable1stBlockNo + bitTblBlkNo, bitTblBlk)\xFE";
 z+="         \xFE";
 z+="    return true\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="function binIsBlockInuse(binFileSpecs, overFlowBlkNo)\xFE";
 z+="    if overFlowBlkNo < binFileSpecs.overFlow1stBlockNo Then debug // out of range\xFE";
 z+="    \xFE";
 z+="    relBlkNo = overFlowBlkNo - binFileSpecs.overFlow1stBlockNo\xFE";
 z+="    bitNo = relBlkNo mod 8\xFE";
 z+="    bitTblByteNo = CInt(relBlkNo / 8)\xFE";
 z+="    \xFE";
 z+="    if bitTblByteNo >= binFileSpecs.bitTableSize then debug // out of range\xFE";
 z+="    \xFE";
 z+="    bitTblBlkNo = CInt(bitTblByteNo / binFileSpecs.blkSize)\xFE";
 z+="    bitTblByteNo = bitTblByteNo Mod binFileSpecs.blkSize\xFE";
 z+="    bitTblBlk = binReadBlock(binFileSpecs, binFileSpecs.bitTable1stBlockNo + bitTblBlkNo)\xFE";
 z+="    \xFE";
 z+="    bitTblByte = Asc(bitTblBlk[bitTblByteNo+1, 1])\xFE";
 z+="    \xFE";
 z+="    bitMask = 2 ^ (7-bitNo)\xFE";
 z+="    return bitAnd(bitTblByte, bitMask)\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="\xFE";
 z+=""
window.cached_jsb_odb["bin_db"]=z;
var z="*\xFE";
 z+="* This version of the DropBox API interface uses DROPBOX V2 ( https://dropbox.github.io/dropbox-api-v2-explorer/ )\xFE";
 z+="*\xFE";
 z+="program dropbox\xFE";
 z+="    ' This is only for testing, use TCL \"ATTACH DROPBOX\" \xFE";
 z+="    @Session.dropbox_cached_folders = {}\xFE";
 z+="    call dropbox_Login(LoginInfo, Provider, UserName, _Password, InitialDB)\xFE";
 z+="    print \"we got a key \":LoginInfo\xFE";
 z+="    @session.CachedAccounts = \"dropbox\":AM():\"@dropbox%%\":LoginInfo\xFE";
 z+="end program\xFE";
 z+="\xFE";
 z+="Sub dropbox_dropOldCache()\xFE";
 z+="* $options IJS\xFE";
 z+="    if !@Session.dropbox_cached_items Then @Session.dropbox_cached_items = {}\xFE";
 z+="    if !@Session.dropbox_cached_timer Then @Session.dropbox_cached_timer = {}\xFE";
 z+="\xFE";
 z+="    For Each CKey In @Session.dropbox_cached_items\xFE";
 z+="        If CKey Then\xFE";
 z+="            If @Session.dropbox_cached_timer[Ckey] + 1000 < timer() Then\xFE";
 z+="                Remove @Session.dropbox_cached_items, CKey\xFE";
 z+="                Remove @Session.dropbox_cached_timer, CKey\xFE";
 z+="            End If\xFE";
 z+="        End If\xFE";
 z+="    Next\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="function dropbox_decodeHandle(dbHandle, loginInfo)\xFE";
 z+="    loginInfo = Field(dbHandle, VM(), 2)\xFE";
 z+="    return Field(dbHandle, VM(), 1)\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="// Returns @Errors and Empty LoginInfo on error\xFE";
 z+="sub dropbox_Login(ByRef LoginInfo, ByVal Provider, ByVal UserName, ByVal _Password, ByVal InitialDB)\xFE";
 z+="    accessToken = oauth_Login(\"dropbox_config\")\xFE";
 z+="    if !accessToken Then return\xFE";
 z+="    Call dropbox_ListFiles(accessToken, FileNames, Success)\xFE";
 z+="    \xFE";
 z+="    // Make sure jsb_dictionaries exists and tapefile\xFE";
 z+="    locate 'jsb_dictionaries' in FileNames Else Call dropbox_CreateFile(accessToken, 'data', 'jsb_dictionaries', Success)\xFE";
 z+="    locate 'tapefile' in FileNames Else Call dropbox_CreateFile(accessToken, '', 'tapefile', Success)\xFE";
 z+="end sub\xFE";
 z+="\xFE";
 z+="Sub dropbox_Logout(ByVal LoginInfo, ByRef Success)\xFE";
 z+="    Call dropbox_dropOldCache() ' Will Create @Session.dropbox_cached_items if necessary\xFE";
 z+="    @Session.dropbox_cached_folders = {}\xFE";
 z+="    \xFE";
 z+="    s = @session.CachedAccounts\xFE";
 z+="    locate 'dropbox' in s<1> setting spot then\xFE";
 z+="        s = delete(s, 1, spot)\xFE";
 z+="        s = delete(s, 2, spot)\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    // List a directory\xFE";
 z+="    Url = `https://api.dropboxapi.com/2/auth/token/revoke`\xFE";
 z+="    header = [\"Content-Type: application/json\", \"Authorization: Bearer \":LoginInfo]\xFE";
 z+="    sdoc = @jsb_bf.Get(Url, \"POST\", Header, \"null\")\xFE";
 z+="    if IsNothing(sdoc) Or sdoc = \"null\" then\xFE";
 z+="        success = true\xFE";
 z+="        @Session.access_token = \"\"\xFE";
 z+="        return\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    Success = False\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="// print @jsb_odb.dropbox_accountInfo\xFE";
 z+="function dropbox_accountInfo()\xFE";
 z+="    s = @session.CachedAccounts\xFE";
 z+="    locate 'dropbox' in s<1> setting spot else return \"not attached to dropbox\"\xFE";
 z+="    at = field(s<2, spot>, \"%%\", 2)\xFE";
 z+="\xFE";
 z+="    // Get account into\xFE";
 z+="    Url = `https://api.dropboxapi.com/2/users/get_current_account`\xFE";
 z+="    header = [\"Content-Type: application/json\" , \"Authorization: Bearer \":at]\xFE";
 z+="\xFE";
 z+="    j = @jsb_bf.Get(Url, \"POST\", Header, \"null\")\xFE";
 z+="    if !j then return @Errors\xFE";
 z+="    return json(j)\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="Sub dropbox_ListFiles(ByVal LoginInfo, ByRef FileNames, ByRef Success)\xFE";
 z+="    Call dropbox_dropOldCache() ' Will Create @Session.dropbox_cached_items if necessary\xFE";
 z+="    Result = \"\"\xFE";
 z+="    @Session.dropbox_cached_folders = {}\xFE";
 z+="    \xFE";
 z+="    FileNames = []\xFE";
 z+="    Folders = {}\xFE";
 z+="    \xFE";
 z+="    // List a directory\xFE";
 z+="    header = [\"Content-Type: application/json\", \"Authorization: Bearer \":LoginInfo]\xFE";
 z+="    Url = `https://api.dropboxapi.com/2/files/list_folder`\xFE";
 z+="    Body = { path: '' }\xFE";
 z+="    \xFE";
 z+="    Loop\xFE";
 z+="        sdoc = @jsb_bf.Get(Url, \"POST\", Header, Body)\xFE";
 z+="        if IsNothing(sdoc) Then \xFE";
 z+="            success = false\xFE";
 z+="            return\xFE";
 z+="        end if\xFE";
 z+="\xFE";
 z+="        jc = JSon(sdoc).entries\xFE";
 z+="        for each item in jc\xFE";
 z+="            Folders[LCase(item.name)] = item[\".tag\"] = \"folder\"\xFE";
 z+="            if item[\".tag\"] = \"folder\" then FileNames[-1] = item.name\xFE";
 z+="        next\xFE";
 z+="        \xFE";
 z+="    While jc.has_more do\xFE";
 z+="        Url = `https://api.dropboxapi.com/2/files/list_folder/continue`\xFE";
 z+="        Body = { cursor: jc.cursor }\xFE";
 z+="    Repeat\xFE";
 z+="  \xFE";
 z+="    // List the dictionaries\xFE";
 z+="    header = [\"Content-Type: application/json\", \"Authorization: Bearer \":LoginInfo]\xFE";
 z+="    Url = `https://api.dropboxapi.com/2/files/list_folder`\xFE";
 z+="    Body = { path: '/jsb_dictionaries' }\xFE";
 z+="    \xFE";
 z+="    Loop\xFE";
 z+="        sdoc = @jsb_bf.Get(Url, \"POST\", Header, Body)\xFE";
 z+="        if IsNothing(sdoc) Then Break\xFE";
 z+="\xFE";
 z+="        jc = JSon(sdoc).entries\xFE";
 z+="        for each item in jc\xFE";
 z+="            Folders[\"jsb_dictionaries/\":LCase(item.name)] = item[\".tag\"] = \"folder\"\xFE";
 z+="        next\xFE";
 z+="        \xFE";
 z+="    While jc.has_more do\xFE";
 z+="        Url = `https://api.dropboxapi.com/2/files/list_folder/continue`\xFE";
 z+="        Body = { cursor: jc.cursor }\xFE";
 z+="    Repeat\xFE";
 z+="    \xFE";
 z+="    Url = `https://api.dropboxapi.com/2/files/list_folder`\xFE";
 z+="    header = [\"Content-Type: application/json\", \"Authorization: Bearer \":LoginInfo]\xFE";
 z+="    sdoc = @jsb_bf.Get(Url, \"POST\", Header, { path: \"/jsb_dictionaries\" })\xFE";
 z+="    if sdoc then\xFE";
 z+="        jc = JSon(sdoc).entries\xFE";
 z+="        for each item in jc\xFE";
 z+="            if item[\".tag\"] = \"folder\" then Folders[\"jsb_dictionaries/\":LCase(item.name)] = True\xFE";
 z+="        next\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="// Leave as array\xFE";
 z+="// FileNames = Join(FileNames, Chr(254))\xFE";
 z+="\xFE";
 z+="    @Session.dropbox_cached_folders = Folders\xFE";
 z+="    Success = True\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="// True (folder), False(file), Null(does not exist)\xFE";
 z+="function dropbox_isFolder(ByVal LoginInfo, ByVal Path)\xFE";
 z+="    // Get meta data\xFE";
 z+="    if left(path, 1) = \"/\" then path = mid(path, 2)\xFE";
 z+="    \xFE";
 z+="    Return @Session.dropbox_cached_folders[Lcase(Path)]\xFE";
 z+="\xFE";
 z+="    Url = `https://api.dropboxapi.com/2/files/get_metadata`\xFE";
 z+="    header = [\"Content-Type: application/json\" , \"Authorization: Bearer \":LoginInfo]\xFE";
 z+="    sdoc = @jsb_bf.Get(Url, \"POST\", Header, { path: \"/\":path } )\xFE";
 z+="    if !sdoc then \xFE";
 z+="        If Header<1> = 409 then @Errors = \"\" ;* Does not exist\xFE";
 z+="        @Session.dropbox_cached_folders[Lcase(Path)] = false\xFE";
 z+="        return null ;* Doesn't exist\xFE";
 z+="    end if\xFE";
 z+="    j = JSon(sdoc)\xFE";
 z+="    isFolder = j[\".tag\"] = \"folder\"\xFE";
 z+="    \xFE";
 z+="    @Session.dropbox_cached_folders[Lcase(Path)] = isFolder\xFE";
 z+="    Return isFolder\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="Sub dropbox_Open(ByVal LoginInfo, ByVal DictData, ByVal FName, ByRef dbHandle, ByRef Success) \xFE";
 z+="    if lcase(DictData) = \"dict\" then \xFE";
 z+="        // make sure jsb_dictionaries exists and create it if necessary\xFE";
 z+="        if !dropbox_isFolder(LoginInfo, \"jsb_dictionaries\") then\xFE";
 z+="            // create directory\xFE";
 z+="            Url = `https://api.dropboxapi.com/2/files/create_folder`\xFE";
 z+="            header = [\"Content-Type: application/json\", \"Authorization: Bearer \":LoginInfo]\xFE";
 z+="            Item = @jsb_bf.Get(Url, \"POST\", Header, { path: \"/jsb_dictionaries\" })\xFE";
 z+="            if IsNothing(Item) Then Return\xFE";
 z+="        end if\xFE";
 z+="\xFE";
 z+="        path = \"jsb_dictionaries/\":fname \xFE";
 z+="    else  \xFE";
 z+="        path = fname\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    if dropbox_isFolder(LoginInfo, path) then\xFE";
 z+="        Success = True\xFE";
 z+="        dbHandle = \"@dropbox.\":path:VM():LoginInfo\xFE";
 z+="    else\xFE";
 z+="        Success = False\xFE";
 z+="    end if\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub dropbox_Select(ByVal Cols, byval dbHandle, ByVal WhereClause, ByRef Success)\xFE";
 z+="    Call dropbox_Select(Cols, dbHandle, WhereClause, Success, Results)\xFE";
 z+="    if Success Then FormList Results\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub dropbox_SelectTo(ByVal Cols, ByVal dbHandle, ByVal WhereClause, SL, ByRef Success)\xFE";
 z+="    Call dropbox_Select(Cols, dbHandle, WhereClause, Success, Results)\xFE";
 z+="    if Success Then FormList Results To SL\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub dropbox_Select(ByVal Cols, ByVal dbHandle, ByVal WhereClause, ByRef Success, ByRef Results)\xFE";
 z+="    LoginInfo = Nothing\xFE";
 z+="    Call dropbox_dropOldCache() ' Will Create @Session.dropbox_cached_items if necessary\xFE";
 z+="    path = dropbox_decodeHandle(dbHandle, LoginInfo)\xFE";
 z+="\xFE";
 z+="    Url = `https://api.dropboxapi.com/2/files/list_folder`\xFE";
 z+="    header = [\"Content-Type: application/json\" , \"Authorization: Bearer \":LoginInfo]\xFE";
 z+="    sdoc = @jsb_bf.Get(Url, \"POST\", Header, { path: \"/\":path })\xFE";
 z+="    if IsNothing(sdoc) then\xFE";
 z+="        success = false\xFE";
 z+="        return\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    Results = []\xFE";
 z+="    jc = JSon(sdoc).entries\xFE";
 z+="    for each item in jc\xFE";
 z+="        if item[\".tag\"] = \"file\" then Results[-1] = item.name\xFE";
 z+="    next\xFE";
 z+="    Success = True\xFE";
 z+="\xFE";
 z+="    if (!Cols And !WhereClause) Or (!Results) Then Return\xFE";
 z+="\xFE";
 z+="    Call ParseSqlColumns(WhereClause, false, IgnoreColumns, WhereHasFunctions, WhereHasOperators, usesItemContent, hasOrderBy)\xFE";
 z+="    Call ParseSqlColumns(COLS, true, DisplayColumns, ColumnsHasFunctions, ColumnsHasOperators, usesItemContent, ignoreorderby)\xFE";
 z+="\xFE";
 z+="    SelectedItemIDs = Results\xFE";
 z+="    Results = Null\xFE";
 z+="    \xFE";
 z+="    ' Need to read all items into SelectedItems\xFE";
 z+="    if WhereClause then\xFE";
 z+="        if !filterJsonArray(SelectedItemIDs, SelectedItems, WhereClause) Then Success = False; Return\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    if ColumnsHasFunctions or ColumnsHasOperators then\xFE";
 z+="        ' This will create an item in TMP, compile it, and run it to get the results\xFE";
 z+="        if !processColumns(DisplayColumns, SelectedItems, SelectedItemIDs) Then Success = False; Return\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    Results = { SelectedItemIDs: SelectedItemIDs }\xFE";
 z+="    Results.SelectedItems = SelectedItems\xFE";
 z+="    Results.OnlyReturnItemIDs = COLS = \"\"\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub dropbox_CreateFile(ByVal LoginInfo, byval dd, ByVal FName, ByRef Success)\xFE";
 z+="    Success = False\xFE";
 z+="    dd = lcase(dd)\xFE";
 z+="\xFE";
 z+="    if !dd or dd = \"data\" then\xFE";
 z+="        mt = dropbox_isFolder(LoginInfo, fname)\xFE";
 z+="        if !mt then\xFE";
 z+="            if !IsNull(mt) then\xFE";
 z+="                @Errors = \"File already exists with the same name\"\xFE";
 z+="                return\xFE";
 z+="            end if\xFE";
 z+="\xFE";
 z+="            // create path\xFE";
 z+="            Url = `https://api.dropboxapi.com/2/files/create_folder`\xFE";
 z+="            header = [\"Content-Type: application/json\", \"Authorization: Bearer \":LoginInfo]\xFE";
 z+="            Item = @jsb_bf.Get(Url, \"POST\", Header, { path: \"/\":@UrlEncode(fname) })\xFE";
 z+="            if IsNothing(Item) Then Return\xFE";
 z+="            \xFE";
 z+="            @Session.dropbox_cached_folders[Lcase(fname)] = True\xFE";
 z+="        end if\xFE";
 z+="    end if\xFE";
 z+="  \xFE";
 z+="    if !dd or dd = \"dict\" then\xFE";
 z+="        // make sure jsb_dictionaries exists and create it if necessary\xFE";
 z+="        if !dropbox_isFolder(LoginInfo, \"jsb_dictionaries\") then\xFE";
 z+="            // create directory\xFE";
 z+="            Url = `https://api.dropboxapi.com/2/files/create_folder`\xFE";
 z+="            header = [\"Content-Type: application/json\", \"Authorization: Bearer \":LoginInfo]\xFE";
 z+="            Item = @jsb_bf.Get(Url, \"POST\", Header, { path: \"/jsb_dictionaries\" } )\xFE";
 z+="            if IsNothing(Item) Then Return\xFE";
 z+="        end if\xFE";
 z+="\xFE";
 z+="        mt = dropbox_isFolder(LoginInfo, \"jsb_dictionaries/\":fname)\xFE";
 z+="        if !dropbox_isFolder(LoginInfo, \"jsb_dictionaries/\":fname) then\xFE";
 z+="            if !IsNull(mt) then\xFE";
 z+="                @Errors = \"File already exists with the same name\"\xFE";
 z+="                return\xFE";
 z+="            end if\xFE";
 z+="\xFE";
 z+="            // create path for dictionary\xFE";
 z+="            Url = `https://api.dropboxapi.com/2/files/create_folder`\xFE";
 z+="            header = [\"Content-Type: application/json\", \"Authorization: Bearer \":LoginInfo]\xFE";
 z+="            Item = @jsb_bf.Get(Url, \"POST\", Header, { path: \"/jsb_dictionaries/\":fname })\xFE";
 z+="            if IsNothing(Item) Then Return\xFE";
 z+="            \xFE";
 z+="            @Session.dropbox_cached_folders[\"jsb_dictionaries/\":Lcase(fname)] = True\xFE";
 z+="        end if\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    Success = True\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub dropbox_ReadJSon(ByRef Item, ByVal dbHandle, ByVal IName, ByRef Success)\xFE";
 z+="    Call dropbox_ReadX(Item, dbHandle, IName, Success, \"JSon\")\xFE";
 z+="    If (Left(Item, 1) = \"{\" Or Left(Item, 1) = \"[\") And Success Then Item = JSon(item)\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub dropbox_ReadJSonU(ByRef Item, ByVal dbHandle, ByVal IName, ByRef Success)\xFE";
 z+="    Call dropbox_ReadX(Item, dbHandle, IName, Success, \"JSonU\")\xFE";
 z+="    If (Left(Item, 1) = \"{\" Or Left(Item, 1) = \"[\") And Success Then Item = JSon(item)\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub dropbox_ReadXML(ByRef Item, ByVal dbHandle, ByVal IName, ByRef Success)\xFE";
 z+="    Call dropbox_ReadX(Item, dbHandle, IName, Success, \"XML\")\xFE";
 z+="    If Left(Item, 1) = \"<\" And Success Then Item = XML(item)\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub dropbox_ReadXMLU(ByRef Item, ByVal dbHandle, ByVal IName, ByRef Success)\xFE";
 z+="    Call dropbox_ReadX(Item, dbHandle, IName, Success, \"XMLU\")\xFE";
 z+="    If Left(Item, 1) = \"<\" And Success Then Item = XML(item)\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub dropbox_Read(ByRef Item, ByVal dbHandle, ByVal IName, ByRef Success)\xFE";
 z+="    Call dropbox_ReadX(Item, dbHandle, IName, Success, \"\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub dropbox_ReadU(ByRef Item, ByVal dbHandle, ByVal IName, ByRef Success)\xFE";
 z+="    Call dropbox_ReadX(Item, dbHandle, IName, Success, \"U\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub dropbox_ReadV(ByRef Item, ByVal dbHandle, ByVal IName, ByVal AtrNo, ByRef Success)\xFE";
 z+="    Call dropbox_ReadX(Item, dbHandle, IName, Success, \"\")\xFE";
 z+="    If !Success Then Return\xFE";
 z+="    Item = Item<AtrNo>\xFE";
 z+="    Return\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub dropbox_ReadVU(ByRef Item, ByVal dbHandle, ByVal IName, ByVal AtrNo, ByRef Success)\xFE";
 z+="    Call dropbox_ReadX(Item, dbHandle, IName, Success, \"U\")\xFE";
 z+="    If !Success Then Return\xFE";
 z+="    Item = Item<AtrNo>\xFE";
 z+="    Return\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub dropbox_ReadX(ByRef Item, ByVal dbHandle, ByVal IName, ByRef Success, ByVal Opts)\xFE";
 z+="    Call dropbox_dropOldCache() ' Will Create @Session.dropbox_cached_items if necessary\xFE";
 z+="\xFE";
 z+="    Item = \"\"\xFE";
 z+="    Success = False\xFE";
 z+="\xFE";
 z+="    path = dropbox_decodeHandle(dbHandle, LoginInfo)\xFE";
 z+="\xFE";
 z+="    // Check Cache\xFE";
 z+="    Key = LCase(path:\"&&\":IName)\xFE";
 z+="    if @Session.dropbox_cached_items[key] And Right(Opts, 1) <> \"U\" then \xFE";
 z+="        Success = True\xFE";
 z+="        Item = @Session.dropbox_cached_items[key]\xFE";
 z+="        @Session.dropbox_cached_timer[key] = timer()\xFE";
 z+="        Return\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    isFolder = dropbox_isFolder(LoginInfo, Path:`/`:IName)\xFE";
 z+="    if isFolder then \xFE";
 z+="        @Errors = \"Attempted READ on directory\"\xFE";
 z+="        Return\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    // read the file\xFE";
 z+="    Url = `https://content.dropboxapi.com/2/files/download`\xFE";
 z+="    args = \"Dropbox-API-Arg: \": { path: `/`:Path:`/`:IName }\xFE";
 z+="    // CT =  [\"text/plain\", \"text/plain; charset=utf-8\", \"application/octet-stream\", \"application/octet-stream; charset=utf-8\"]\xFE";
 z+="    header = [\"Authorization: Bearer \":LoginInfo, \"Content-Type: application/octet-stream\", args]\xFE";
 z+="\xFE";
 z+="    Item = @jsb_bf.Get(Url, \"POST\", Header, \"\")\xFE";
 z+="    if IsNothing(Item) Then Return\xFE";
 z+="\xFE";
 z+="    Select Case Opts\xFE";
 z+="        Case \"JSon\", \"JSonU\"\xFE";
 z+="            On Error Goto ErrOut\xFE";
 z+="            Item = json(Item)\xFE";
 z+="\xFE";
 z+="        Case \"XML\", \"XMLU\"\xFE";
 z+="            On Error Goto ErrOut\xFE";
 z+="            Item = xml(Item)\xFE";
 z+="    End Select\xFE";
 z+="\xFE";
 z+="    @Session.dropbox_cached_items[key] = Item\xFE";
 z+="    @Session.dropbox_cached_timer[key] = timer()\xFE";
 z+="    Success = True\xFE";
 z+="\xFE";
 z+="errout: \xFE";
 z+="    Return\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub dropbox_DeleteFile(byval dbHandle, ByRef Success)\xFE";
 z+="    LoginInfo = Nothing\xFE";
 z+="    \xFE";
 z+="    Call dropbox_dropOldCache() ' Will Create @Session.dropbox_cached_items if necessary\xFE";
 z+="    \xFE";
 z+="    path = dropbox_decodeHandle(dbHandle, LoginInfo)\xFE";
 z+="\xFE";
 z+="    PKey = LCase(path:\"&&\")\xFE";
 z+="    For Each CKey In @Session.dropbox_cached_items\xFE";
 z+="        If CKey Then\xFE";
 z+="            If Left(CKey, Len(Pkey)) = PKey Then \xFE";
 z+="                Remove @Session.dropbox_cached_items, CKey\xFE";
 z+="                Remove @Session.dropbox_cached_timer, CKey\xFE";
 z+="            end if\xFE";
 z+="        end if\xFE";
 z+="    Next\xFE";
 z+="\xFE";
 z+="    // delete the directory\xFE";
 z+="    Url = `https://api.dropboxapi.com/2/files/delete`\xFE";
 z+="    header = [\"Content-Type: application/json\", \"Authorization: Bearer \":LoginInfo]\xFE";
 z+="    Item = @jsb_bf.Get(Url, \"POST\", Header, { path: `/`:Path } )\xFE";
 z+="\xFE";
 z+="    if !Item Then \xFE";
 z+="        if header<1> = 404 then\xFE";
 z+="            success = True\xFE";
 z+="            return\xFE";
 z+="        end if\xFE";
 z+="        return\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    @Session.dropbox_cached_folders[Lcase(path)] = False\xFE";
 z+="    \xFE";
 z+="    Success = True\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub dropbox_ClearFile(byval dbHandle, ByRef Success)\xFE";
 z+="    LoginInfo = Nothing\xFE";
 z+="    \xFE";
 z+="    Call dropbox_DeleteFile(dbHandle, Success) ' Will Create @Session.dropbox_cached_items if necessary\xFE";
 z+="    if !Success Then Return\xFE";
 z+="\xFE";
 z+="    Success = False\xFE";
 z+="    path = dropbox_decodeHandle(dbHandle, LoginInfo)\xFE";
 z+="    Url = `https://api.dropboxapi.com/2/files/create_folder`\xFE";
 z+="    header = [\"Content-Type: application/json\", \"Authorization: Bearer \":LoginInfo]\xFE";
 z+="    Item = @jsb_bf.Get(Url, \"POST\", Header, { path: `/`:Path } )\xFE";
 z+="    if IsNothing(Item) Then Return\xFE";
 z+="    Success = True\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub dropbox_DeleteItem(byval dbHandle, ByVal IName, ByRef Success)\xFE";
 z+="    LoginInfo = Nothing\xFE";
 z+="    \xFE";
 z+="    Call dropbox_dropOldCache() ' Will Create @Session.dropbox_cached_items if necessary\xFE";
 z+="\xFE";
 z+="    path = dropbox_decodeHandle(dbHandle, LoginInfo)\xFE";
 z+="    Success = False\xFE";
 z+="\xFE";
 z+="    Key = LCase(Path:\"&&\":IName)\xFE";
 z+="    if @Session.dropbox_cached_items Then \xFE";
 z+="        Remove @Session.dropbox_cached_items, Key\xFE";
 z+="        Remove @Session.dropbox_cached_timer, Key\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    // delete the file\xFE";
 z+="    Url = `https://api.dropboxapi.com/2/files/delete`\xFE";
 z+="    header = [\"Content-Type: application/json\", \"Authorization: Bearer \":LoginInfo]\xFE";
 z+="    Item = @jsb_bf.Get(Url, \"POST\", Header, { path: `/`:Path:`/`:IName })\xFE";
 z+="\xFE";
 z+="    if !Item Then \xFE";
 z+="        if header<1> = 404 then\xFE";
 z+="            success = True\xFE";
 z+="            return\xFE";
 z+="        end if\xFE";
 z+="        return\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    Success = True\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub dropbox_Write(byval Item, byval dbHandle, byval IName, ByRef Success)\xFE";
 z+="    Call dropbox_WriteX(Item, dbHandle, IName, Success, \"\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub dropbox_WriteU(byval Item, byval dbHandle, byval IName, ByRef Success)\xFE";
 z+="    Call dropbox_WriteX(Item, dbHandle, IName, Success, \"U\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub dropbox_WriteJSon(byval Item, byval dbHandle, byval IName, ByRef Success)\xFE";
 z+="    Call dropbox_WriteX(Item, dbHandle, IName, Success, \"JSon\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub dropbox_WriteJSonU(byval Item, byval dbHandle, byval IName, ByRef Success)\xFE";
 z+="    Call dropbox_WriteX(Item, dbHandle, IName, Success, \"JSonU\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub dropbox_WriteXml(byval Item, byval dbHandle, byval IName, ByRef Success)\xFE";
 z+="    Call dropbox_WriteX(Item, dbHandle, IName, Success, \"Xml\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub dropbox_WriteXmlU(byval Item, byval dbHandle, byval IName, ByRef Success)\xFE";
 z+="    Call dropbox_WriteX(Item, dbHandle, IName, Success, \"XmlU\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub dropbox_WriteX(byval Item, byval dbHandle, byval IName, ByRef Success, byval Opts)\xFE";
 z+="    Success = False\xFE";
 z+="    LoginInfo = Nothing\xFE";
 z+="    \xFE";
 z+="    Call dropbox_dropOldCache() ' Will Create @Session.dropbox_cached_items if necessary\xFE";
 z+="\xFE";
 z+="    path = dropbox_decodeHandle(dbHandle, LoginInfo)\xFE";
 z+="\xFE";
 z+="    // Check Cache\xFE";
 z+="    Key = LCase(path:\"&&\":IName)\xFE";
 z+="    if InStr(IName, \".\") Then Ext = RightField(IName, \".\") Else Ext = \"txt\"\xFE";
 z+="    mime_type = @mimeType(Ext)\xFE";
 z+="\xFE";
 z+="    // write a file\xFE";
 z+="    args = \"Dropbox-API-Arg: \": { path: `/`:Path:`/`:IName, mode: 'overwrite', autorename: false, mute: false }\xFE";
 z+="    Url = `https://content.dropboxapi.com/2/files/upload`\xFE";
 z+="    header = [\"Content-Type: application/octet-stream\", \"Authorization: Bearer \":LoginInfo, \"Accept: */*\", \"Accept-Encoding: gzip, deflate, br\", args]\xFE";
 z+="\xFE";
 z+="    NR = @jsb_bf.Get(Url, \"POST\", Header, Item)\xFE";
 z+="\xFE";
 z+="    If IsNothing(NR) Then Return\xFE";
 z+="\xFE";
 z+="    Success = True\xFE";
 z+="\xFE";
 z+="    * If the Commit for the WriteU later fails, we need to be sure to invalidate the cache\xFE";
 z+="    @Session.dropbox_cached_items[key] = Item\xFE";
 z+="    @Session.dropbox_cached_timer[key] = timer() \xFE";
 z+="End Sub\xFE";
 z+=""
window.cached_jsb_odb["dropbox"]=z;
var z="function email(emailFrom, emailTo, CC, BCC, emailSubject, emailBody)\xFE";
 z+="   *$options js\xFE";
 z+="\xFE";
 z+="    var isHtml = (Left(emailBody, 1) == \"<\");\xFE";
 z+="    \xFE";
 z+="    on Error Goto Failed\xFE";
 z+="    if (isPhoneGap() And window.hasEmailSupport) Then\xFE";
 z+="        If !isArray(emailTo) Then emailTo = [CStr(emailTo)]\xFE";
 z+="        If !Cc Then Cc = Null Else\xFE";
 z+="            If !isArray(Cc) Then Cc = [CStr(Cc)]\xFE";
 z+="            If LBound(Cc) = 1 Then Cc.shift();\xFE";
 z+="        End If\xFE";
 z+="    \xFE";
 z+="        If !Bcc Then Bcc = Null Else\xFE";
 z+="            If !isArray(Bcc) Then Bcc = [CStr(Bcc)]\xFE";
 z+="            If LBound(Bcc) = 1 Then Bcc.shift();\xFE";
 z+="        End If\xFE";
 z+="    \xFE";
 z+="        window.Cordova.plugins.email.open({\xFE";
 z+="            isHtml: isHtml,\xFE";
 z+="            to: emailTo,\xFE";
 z+="            cc: CC,\xFE";
 z+="            bcc: BCC,\xFE";
 z+="            subject: emailSubject,\xFE";
 z+="            body: emailBody\xFE";
 z+="        })\xFE";
 z+="        \xFE";
 z+="        return True\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    if (window.dotNetObj) Then\xFE";
 z+="        // jsb_config email = { host: \"\", port: 80, ssl: true, username: \"\", password: \"\", from: \"\" }\xFE";
 z+="        \xFE";
 z+="        var Port = 0; var SSL = \"false\"; var Host = \"\"; var networkID = \"\"; var networkPassword = \"\"; var fromName = \"\";\xFE";
 z+="        em = @jsbConfig(\"email\")\xFE";
 z+="        if isJson(em) Then\xFE";
 z+="            host = em.host\xFE";
 z+="            if em.port then port = em.port\xFE";
 z+="            ssl = em.ssl:\"\"\xFE";
 z+="            networkID = em.username\xFE";
 z+="            networkPassword = em.password\xFE";
 z+="            if !emailFrom Then emailFrom = em.from\xFE";
 z+="        end if\xFE";
 z+="        \xFE";
 z+="        var errs = window.dotNetObj.dnoSendMailMessage(Host, Port, SSL, networkID, networkPassword, emailFrom, fromName, emailTo, CC, BCC, emailSubject, emailBody);\xFE";
 z+="        if (Left(errs, 2) <> \"**\") Then Return True\xFE";
 z+="        \xFE";
 z+="         At_Errors = Mid(errs, 2);\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    if window.dotNetObj Or isPhoneGap() Then\xFE";
 z+="        var isHtml = (Left(emailBody, 1) == \"<\");\xFE";
 z+="         \xFE";
 z+="        var emlContent = \"data:message/rfc822 eml; charset=utf-8,\";\xFE";
 z+="        emlContent := 'To: ' : emailTo : '\\n';\xFE";
 z+="        if (CC) then emlContent := 'CC: ' : CC : '\\n';\xFE";
 z+="        if (BCC) then emlContent := 'BCC: ' : BCC : '\\n';\xFE";
 z+="        emlContent := 'Subject: ' : emailSubject : '\\n';\xFE";
 z+="        emlContent := 'X-Unsent: 1' : '\\n';\xFE";
 z+="    \xFE";
 z+="        if (isHtml) then emlContent := 'Content-Type: text/html' : '\\n'; else emlContent := 'Content-Type: text/plain' : '\\n';\xFE";
 z+="        emlContent := '' : '\\n';\xFE";
 z+="        emlContent := Change(emailBody, crlf(), \"</br>\");\xFE";
 z+="    \xFE";
 z+="        if (!$('#emailLink').length) then $('body').append(\"<a id='emailLink'>email Link</a>\");\xFE";
 z+="    \xFE";
 z+="        $('#emailLink').attr(\"href\", encodeURI(emlContent))\xFE";
 z+="        $('#emailLink').attr(\"download\", 'jsbEMail.eml')\xFE";
 z+="        $('#emailLink').hide()\xFE";
 z+="    \xFE";
 z+="        document.getElementById('emailLink').click(); //click the link\xFE";
 z+="        return true\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    window.open('mailto:' : urlEncode(emailTo) : '?subject=' : urlEncode(emailSubject) : ':body=' : urlEncode(emailBody));\xFE";
 z+="\xFE";
 z+="Failed:\xFE";
 z+="   Return False\xFE";
 z+="End Function\xFE";
 z+=""
window.cached_jsb_odb["email"]=z;
var z="/*\xFE";
 z+="   This hyb protocol will hash by item name, and store data in groups of json\xFE";
 z+="   File Names may be suffixed with |Modulo\xFE";
 z+="*/\xFE";
 z+="\xFE";
 z+="Sub Hyb_db\xFE";
 z+="    * Just a place holder so we skip the compiler error\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hyb_Login(ByVal LoginInfo, ByVal Provider, ByVal UserName, ByVal _Password, ByVal InitialDB)\xFE";
 z+="    @Errors = \"Attaching to the hybrid DB isn't possbile\"\xFE";
 z+="    LoginInfo = \"\"\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="// ==================================== Code to deal with files ====================================\xFE";
 z+="// ==================================== Code to deal with files ====================================\xFE";
 z+="// ==================================== Code to deal with files ====================================\xFE";
 z+="\xFE";
 z+="// Hybrid files are normal files, only their content is different.\xFE";
 z+="// The contents are hashed by itemid and placed into buckets of json structures\xFE";
 z+="// Each bucket is a collection of items { \"ItemID1\": \"...data...\", \"ItemID2\": \"...data...\", ... }\xFE";
 z+="//\xFE";
 z+="// FName may be suffixed with |Modulo\xFE";
 z+="//\xFE";
 z+="Sub hyb_Open(ByVal LoginInfo, ByVal DictData, ByVal FName, ByRef fHandle, ByRef Success)\xFE";
 z+="    ' Do the normal open for the fHandle\xFE";
 z+="\xFE";
 z+="    I_open DictData, Field(FName, \"|\", 1) To fHandle Else\xFE";
 z+="        Success = False\xFE";
 z+="        Return\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    Success = True\xFE";
 z+="    DictData = LCase(DictData)\xFE";
 z+="    If DictData <> \"dict\" Then DictData = \"data\"\xFE";
 z+="    \xFE";
 z+="    Modulo = Field(FName, \"|\", 2)\xFE";
 z+="    if !Modulo Then Modulo = 97\xFE";
 z+="    fHandle = DictData:Am():Field(FName, \"|\", 1):Am():Modulo\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hyb_CreateFile(ByVal LoginInfo, ByVal FileName, ByRef fHandle, ByRef Success)\xFE";
 z+="    // Normal create\xFE";
 z+="    Success = False\xFE";
 z+="    I_CreateFile Field(FileName, \"|\", 1) Then\xFE";
 z+="        I_open FileName To fHandle Then\xFE";
 z+="            Success = True\xFE";
 z+="            fHandle = \"\":Am():Field(FileName, \"|\", 1):Am():Field(FileName, \"|\", 2)\xFE";
 z+="        End If\xFE";
 z+="    End If\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="function Hyb_reopen(ByVal fHandle, Modulo)\xFE";
 z+="    Modulo = fHandle<3>\xFE";
 z+="    I_open fHandle<1>, fHandle<2> To nHandle Then Return nHandle\xFE";
 z+="    Alert('I was unable to reopen then table ':fHandle<2>:'!');\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="Sub hyb_ListFiles(ByVal LoginInfo, ByRef Result, ByRef Success)\xFE";
 z+="    // Normal list\xFE";
 z+="    I_ListFiles To Result Else Result = \"\"\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hyb_DeleteFile(ByVal fHandle, Success)\xFE";
 z+="    fHandle = Hyb_reopen(fHandle, Modulo)\xFE";
 z+="    I_DeleteFile fHandle Then Success = 1 Else Success = 0\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hyb_ClearFile(ByVal fHandle, Success)\xFE";
 z+="    fHandle = Hyb_reopen(fHandle, Modulo)\xFE";
 z+="    I_ClearFile fHandle Then Success = 1 Else Success = 0\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="// ==================================== Code to deal with items ====================================\xFE";
 z+="// ==================================== Code to deal with items ====================================\xFE";
 z+="// ==================================== Code to deal with items ====================================\xFE";
 z+="function hyb_hashName(IName, Modulo)\xFE";
 z+="    HashID = 0\xFE";
 z+="    For I = 1 To Len(IName)\xFE";
 z+="        C = Seq(IName[I,1])\xFE";
 z+="        If HashID > 1234567890000 Then\xFE";
 z+="            HashID += C\xFE";
 z+="        ElseIf C >= 48 And C <= 57 Then\xFE";
 z+="            HashID = HashID * 10 + C-48 // digits\xFE";
 z+="        ElseIf C >= 97 And C <= 122 Then\xFE";
 z+="            HashID = HashID * 26 + C-97 // a-z\xFE";
 z+="        ElseIf C >= 65 And C <= 90 Then\xFE";
 z+="            HashID = HashID * 26 + C-65 // A-Z\xFE";
 z+="        Else\xFE";
 z+="            HashID = HashID + C\xFE";
 z+="        End If\xFE";
 z+="    Next\xFE";
 z+="    Return \"bucket_\":HashID Mod Modulo\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="Sub Hyb_primarykeyname(ByVal fHandle, ByRef Result As String, ByRef Success As Boolean)\xFE";
 z+="    fHandle = Hyb_reopen(fHandle, Modulo)\xFE";
 z+="    Result = primaryKeyName(fHandle)\xFE";
 z+="    Success = Result <> \"\"\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hyb_ReadJSon(Item, fHandle, IName, Success)\xFE";
 z+="    Call hyb_ReadX(Item, fHandle, IName, Success, \"JSon\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hyb_ReadJSonU(Item, fHandle, IName, Success)\xFE";
 z+="    Call hyb_ReadX(Item, fHandle, IName, Success, \"JSonU\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hyb_ReadXML(Item, fHandle, IName, Success)\xFE";
 z+="    Call hyb_ReadX(Item, fHandle, IName, Success, \"XML\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hyb_ReadXMLU(Item, fHandle, IName, Success)\xFE";
 z+="    Call hyb_ReadX(Item, fHandle, IName, Success, \"XMLU\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hyb_Read(Item, fHandle, IName, Success)\xFE";
 z+="    Call hyb_ReadX(Item, fHandle, IName, Success, \"\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hyb_ReadU(Item, fHandle, IName, Success)\xFE";
 z+="    Call hyb_ReadX(Item, fHandle, IName, Success, \"U\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hyb_ReadV(Item, fHandle, IName, AtrNo, Success)\xFE";
 z+="    Call hyb_ReadX(Item, fHandle, IName, Success, \"\")\xFE";
 z+="    If !Success Then Return\xFE";
 z+="    Item = Item<AtrNo>\xFE";
 z+="    Return\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hyb_ReadVU(Item, fHandle, IName, AtrNo, Success)\xFE";
 z+="    Call hyb_ReadX(Item, fHandle, IName, Success, \"U\")\xFE";
 z+="    If !Success Then Return\xFE";
 z+="    Item = Item<AtrNo>\xFE";
 z+="    Return\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hyb_ReadX(Item, ByVal fHandle, IName, Success, RType)\xFE";
 z+="    fHandle = Hyb_reopen(fHandle, Modulo)\xFE";
 z+="    bucketID = hyb_hashName(IName, Modulo)\xFE";
 z+="    \xFE";
 z+="    Success = False\xFE";
 z+="    If Right(RType, 1) = \"U\" Then\xFE";
 z+="        I_ReadJSonU Bucket From fHandle, bucketID Else Return\xFE";
 z+="    Else\xFE";
 z+="        I_ReadJSon Bucket From fHandle, bucketID Else Return\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    Item = Bucket[LCase(IName)]\xFE";
 z+="    If !Item Then @Errors = \"\"; Return\xFE";
 z+="    \xFE";
 z+="    If Left(RType, 1) = \"J\" Then\xFE";
 z+="        If isValidJson(Item) Then\xFE";
 z+="            Item = JSon(Item)\xFE";
 z+="        Else\xFE";
 z+="            Item = { ItemID: IName, ItemContent: Item }\xFE";
 z+="        End If\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    Success = True\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hyb_DeleteItem(ByVal fHandle, IName, Success)\xFE";
 z+="    fHandle = Hyb_reopen(fHandle, Modulo)\xFE";
 z+="    bucketID = hyb_hashName(IName, Modulo)\xFE";
 z+="    \xFE";
 z+="    Success = 1\xFE";
 z+="    I_ReadJSon Bucket From fHandle, bucketID Else Return\xFE";
 z+="    \xFE";
 z+="    Remove Bucket, LCase(IName)\xFE";
 z+="    \xFE";
 z+="    Success = 0\xFE";
 z+="    if Len(Bucket) = 0 Then\xFE";
 z+="        I_Delete fHandle, bucketID Else Return\xFE";
 z+="    Else\xFE";
 z+="        I_Write Bucket On fHandle, bucketID Else Return\xFE";
 z+="    End If\xFE";
 z+="    Success = True\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hyb_Write(ByVal Item, fHandle, ByVal IName, Success)\xFE";
 z+="    Call hyb_WriteX(Item, fHandle, IName, Success, \"\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hyb_WriteU(Item, fHandle, IName, Success)\xFE";
 z+="    Call hyb_WriteX(Item, fHandle, IName, Success, \"U\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hyb_WriteJSon(Item, fHandle, IName, Success)\xFE";
 z+="    Call hyb_WriteX(Item, fHandle, IName, Success, \"JSon\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hyb_WriteJSonU(Item, fHandle, IName, Success)\xFE";
 z+="    Call hyb_WriteX(Item, fHandle, IName, Success, \"JSonU\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hyb_WriteXml(Item, fHandle, IName, Success)\xFE";
 z+="    Call hyb_WriteX(Item, fHandle, IName, Success, \"Xml\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hyb_WriteXmlU(Item, fHandle, IName, Success)\xFE";
 z+="    Call hyb_WriteX(Item, fHandle, IName, Success, \"XmlU\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hyb_WriteX(ByVal Item, ByVal fHandle, ByVal IName, Success, wType)\xFE";
 z+="    fHandle = Hyb_reopen(fHandle, Modulo)\xFE";
 z+="    bucketID = hyb_hashName(IName, Modulo)\xFE";
 z+="    \xFE";
 z+="    I_ReadJSonU Bucket From fHandle, bucketID Else Bucket = {}\xFE";
 z+="\xFE";
 z+="    If Left(wType, 1) = \"J\" Then\xFE";
 z+="        If isValidJson(Item) Then\xFE";
 z+="            Item = JSon(Item)\xFE";
 z+="        Else\xFE";
 z+="            Item = { ItemID: IName, ItemContent: Item }\xFE";
 z+="        End If\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    Bucket[LCase(IName)] = Item\xFE";
 z+="    \xFE";
 z+="    Success = False\xFE";
 z+="    If Right(wType, 1) = \"U\" Then\xFE";
 z+="        I_WriteU Bucket On fHandle, bucketID Else Return\xFE";
 z+="    Else\xFE";
 z+="        I_Write Bucket On fHandle, bucketID Else Return\xFE";
 z+="    End If\xFE";
 z+="    Success = True\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="// ==================================== Code to deal with selectlists ====================================\xFE";
 z+="// ==================================== Code to deal with selectlists ====================================\xFE";
 z+="// ==================================== Code to deal with selectlists ====================================\xFE";
 z+="\xFE";
 z+="Sub hyb_Select(Cols, ByVal fHandle, WhereClause, Success)\xFE";
 z+="    fHandle = Hyb_reopen(fHandle, Modulo)\xFE";
 z+="    I_Select Cols From fHandle Where WhereClause Then Success = 1 Else Success = 0\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hyb_SelectTo(Cols, ByVal fHandle, WhereClause, Sl, Success)\xFE";
 z+="    fHandle = Hyb_reopen(fHandle, Modulo)\xFE";
 z+="    I_Select Cols From fHandle Where WhereClause To Sl Then Success = 1 Else Success = 0\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hyb_doSelectFilter(Cols, ByVal fHandle, WhereClause, Success, Results)\xFE";
 z+="    Success = True\xFE";
 z+="\xFE";
 z+="    // Build a list of item ids in \xFE";
 z+="    Results = []\xFE";
 z+="    // ...\xFE";
 z+="    // ...\xFE";
 z+="    \xFE";
 z+="    \xFE";
 z+="    Success = True\xFE";
 z+="    \xFE";
 z+="    if (!Cols And !WhereClause) Or (!Results) Then Return\xFE";
 z+="\xFE";
 z+="    Call ParseSqlColumns(WhereClause, false, IgnoreColumns, WhereHasFunctions, WhereHasOperators, usesItemContent, hasOrderBy)\xFE";
 z+="    Call ParseSqlColumns(COLS, true, DisplayColumns, ColumnsHasFunctions, ColumnsHasOperators, usesItemContent, ignoreorderby)\xFE";
 z+="\xFE";
 z+="    SelectedItemIDs = Results\xFE";
 z+="    Results = Null\xFE";
 z+="    \xFE";
 z+="    ' Need to read all items into SelectedItems\xFE";
 z+="    if WhereClause then\xFE";
 z+="        if !filterJsonArray(SelectedItemIDs, SelectedItems, WhereClause) Then Success = False; Return\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    if ColumnsHasFunctions or ColumnsHasOperators then\xFE";
 z+="        ' This will create an item in TMP, compile it, and run it to get the results\xFE";
 z+="        if !processColumns(DisplayColumns, SelectedItems, SelectedItemIDs) Then Success = False; Return\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    Results = { SelectedItemIDs: SelectedItemIDs }\xFE";
 z+="    Results.SelectedItems = SelectedItems\xFE";
 z+="    Results.OnlyReturnItemIDs = COLS = \"\"\xFE";
 z+="End Sub\xFE";
 z+=""
window.cached_jsb_odb["hyb_db"]=z;
var z="/*\xFE";
 z+="   This is the main interface code for database opens, reads, writes, ....\xFE";
 z+="   To by-pass this code, use the i_xxxx versions of opem, read, write, etc...\xFE";
 z+="   \xFE";
 z+="   You may specifically request a type of open by either using a protocol (as in ppp:filename), or by creating an MD entry:  Q^^ppp:filename\xFE";
 z+="\xFE";
 z+="*/\xFE";
 z+="\xFE";
 z+="Sub I_db()\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub clearRefCache(ByVal fHandle As Object)\xFE";
 z+="    Dim RefCache As JSON = @Session[\"RefCache\"]\xFE";
 z+="    If RefCache Then\xFE";
 z+="        fHandle = LCase(fHandle)\xFE";
 z+="        Dim keys2Delete As Array = []\xFE";
 z+="        For Each RefKey As String In RefCache\xFE";
 z+="            If Field(RefKey, Chr(250), 1) = fHandle Then keys2Delete[-1] = RefKey\xFE";
 z+="        Next\xFE";
 z+="        For Each RefKey As String In keys2Delete\xFE";
 z+="            Remove RefCache, RefKey\xFE";
 z+="        Next\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    Dim FileName As String = LCase(fHandle2FileName(fHandle))\xFE";
 z+="    If FileName = \"system\" Or FileName = \"jsb_users\" Then\xFE";
 z+="        If System(1) = \"gae\" Then Execute \"clear-cache\" ;* Clears Mem-Cache\xFE";
 z+="        @Session.CachedAccounts = \"\"\xFE";
 z+="        @Session.rpc_cached_opens = {}\xFE";
 z+="        @Session.last_rpc_Address = \"\"\xFE";
 z+="        @Session.rpc_cached_logins = {}\xFE";
 z+="        @Session.rpc_cached_items = {}\xFE";
 z+="        @Session.RefCache = {}\xFE";
 z+="        If System(1) = \"js\" Then window.saveAtSession()\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    If FileName = \"jsb_config\" Then\xFE";
 z+="        For Each Key  As String In @Application.keys\xFE";
 z+="            If Left(Key, 7) = 'config ' Then @Application[Key] = Nothing\xFE";
 z+="        Next\xFE";
 z+="        If System(1) = \"js\" Then window.saveAtSession()\xFE";
 z+="    End If\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="function validOdbProtocols() As Array\xFE";
 z+="    return [\"rmt\", \"hyb\", \"log\", \"rpc\", \"dropbox\", \"sheets\", \"hbd\", \"bin\"] // .. soon .. \"email\", \"gdrive\", \"photos\"  (Note \"hbd\" is an example protocol)\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="function ListFiles(ByRef Result As String) As Boolean\xFE";
 z+="    Dim Account As String = @Session.AttachedDatabase\xFE";
 z+="    Dim CachedAccounts As String = @Session.CachedAccounts\xFE";
 z+="    Dim Spot As Integer\xFE";
 z+="    Dim Errors As String\xFE";
 z+="    \xFE";
 z+="    Locate Account In CachedAccounts<1> Setting Spot Then \xFE";
 z+="        Dim httpAddress As String = Replace(CachedAccounts<2, Spot>, \"%%\", Chr(253))\xFE";
 z+="        \xFE";
 z+="        If Left(httpAddress, 1) = \"@\" Then\xFE";
 z+="            Dim A1 As String = Field(httpAddress, Vm(), 1)\xFE";
 z+="            Dim LoginInfo As String = DropLeft(httpAddress, Vm())\xFE";
 z+="            Dim odbSub As String = \"jsb_odb.\":Mid(A1, 2):\"_ListFiles\"\xFE";
 z+="            Dim Success As Boolean\xFE";
 z+="            Call @odbSub(ByVal LoginInfo, ByRef Result, ByRef Success)\xFE";
 z+="            Return Success\xFE";
 z+="            \xFE";
 z+="        ElseIf httpAddress Then\xFE";
 z+="            Call rpc_ListFiles(httpAddress, Result, Errors)\xFE";
 z+="            Return Errors = \"\"\xFE";
 z+="        End If\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    Dim aResult As Object\xFE";
 z+="    I_ListFiles To aResult Else Return 0\xFE";
 z+="    Result = CStr(aResult)\xFE";
 z+="    Return 1\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="function Open(ByVal DictData As String, ByVal Fname As String, byRef fHandle As Object) As Boolean\xFE";
 z+="    Fname = LTrim(RTrim(Fname))\xFE";
 z+="    Dim Lfname As String = LCase(Trim(Fname))\xFE";
 z+="    If Lfname = \"\" Then Return Nothing\xFE";
 z+="    \xFE";
 z+="    DictData = LCase(Trim(DictData))\xFE";
 z+="    If Left(Lfname, 5) = \"dict \" Or Left(Lfname, 5) = \"data \" Then\xFE";
 z+="        DictData = Left(lfName, 4)\xFE";
 z+="        Fname = Mid(FName, 6)\xFE";
 z+="        lfName = Mid(lfName, 6)\xFE";
 z+="    End If\xFE";
 z+="    if dictdata <> \"dict\" then dictdata = \"data\"\xFE";
 z+="    \xFE";
 z+="    // these must already exists and be local\xFE";
 z+="    If lfName = \"system\" Or lfName = \"md\" Then\xFE";
 z+="        I_Open DictData, FName To fHandle Then Return True Else Return False\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    // check for Q-Log\xFE";
 z+="    Dim fMD As Table\xFE";
 z+="    I_Open \"md\" To fMD Else Return False\xFE";
 z+="    \xFE";
 z+="    Dim QRec As String\xFE";
 z+="    I_Read QRec From fMD, FName Else QRec = \"\"\xFE";
 z+="    Dim LQRec1 As String = LCase(QRec<1>)\xFE";
 z+="    \xFE";
 z+="    // Check for \"ql\" log files (allows ql of other protocols)\xFE";
 z+="    Dim enableLogFile As Integer\xFE";
 z+="    Locate \"ql\" In LQRec1<1> Setting enableLogFile Then\xFE";
 z+="        Dim QFName As String = Trim(QRec<2, enableLogFile>)\xFE";
 z+="        If QFName = \"\" Then QFName = FName\xFE";
 z+="        \xFE";
 z+="        * Make sure log file exists (use open, not _open so QPTR to SDCard willl work)\xFE";
 z+="        Dim QFLogfileName As String = Trim(QRec<3, enableLogFile>)\xFE";
 z+="        If QFLogfileName = \"\" Then QFLogfileName = \"dblog\"\xFE";
 z+="        \xFE";
 z+="        // Instead of calling the protocol log_Open, I do it here to prevent circular opens\xFE";
 z+="        dictdata = lcase(dictdata)\xFE";
 z+="        if dictdata <> \"dict\" then dictdata = \"data\"\xFE";
 z+="        fHandle = \"@log.\":DictData:AM():QFName:AM():QFLogfileName\xFE";
 z+="        \xFE";
 z+="        Dim xfHandle As Object\xFE";
 z+="        if QFName = FName then\xFE";
 z+="            // Prevent circular open with i_open\xFE";
 z+="            i_open dictdata, QFName to xfHandle else return false\xFE";
 z+="        else\xFE";
 z+="            open dictdata, QFName to xfHandle else return false\xFE";
 z+="            fHandle := AM():\"a\" // allow logging of any file\xFE";
 z+="        end if\xFE";
 z+="        Return True\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    // Check for Q md entry\xFE";
 z+="    Dim isQDRec As Integer\xFE";
 z+="    Locate \"qd\" In LQRec1<1> Setting isQDRec Then\xFE";
 z+="        Dim isQRec As Integer = isQDRec\xFE";
 z+="    Else\xFE";
 z+="        isQDRec = 0\xFE";
 z+="        Locate \"q\" In LQRec1<1> Setting isQRec Else isQRec = 0\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    Dim protocol As String = \"\"\xFE";
 z+="    If Instr(FName, \":\") Then\xFE";
 z+="        protocol = lcase(Field(FName, \":\", 1))\xFE";
 z+="        locate protocol in validOdbProtocols() Then\xFE";
 z+="            FName = DropLeft(FName, \":\")\xFE";
 z+="            If Left(FName, 1) = \"@\" Then fName = Mid(fName, 2)\xFE";
 z+="        Else\xFE";
 z+="            protocol = \"\"\xFE";
 z+="        End If\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    If isQRec Then\xFE";
 z+="        QFName = Trim(QRec<3, isQRec>)\xFE";
 z+="        If QFName = \"\" Then QFName = FName\xFE";
 z+="        if !protocol And InStr(QFName, \":\") Then\xFE";
 z+="            protocol = lcase(Field(QFName, \":\", 1))\xFE";
 z+="            locate protocol in validOdbProtocols() Then\xFE";
 z+="                QFName = DropLeft(QFName, \":\")\xFE";
 z+="                If Left(QFName, 1) = \"@\" Then QFName = Mid(QFName, 2)\xFE";
 z+="                FName = QFName\xFE";
 z+="            Else\xFE";
 z+="                protocol = \"\"\xFE";
 z+="            End If\xFE";
 z+="        end if\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    Dim rmtOnly As Boolean = protocol = \"rmt\" \xFE";
 z+="        \xFE";
 z+="    // Check for a protocol\xFE";
 z+="    if !rmtOnly then\xFE";
 z+="        If protocol Then\xFE";
 z+="            Dim cName As String = \"jsb_odb|\":protocol:\"_open\"\xFE";
 z+="            Dim Success As Boolean\xFE";
 z+="            Call @cName(ByVal DictData, ByVal FName, ByRef fHandle, ByRef Success) \xFE";
 z+="            if TypeOfFile(fHandle) Then return Success\xFE";
 z+="            fHandle = \"@\":protocol:\".\":fHandle\xFE";
 z+="            return Success\xFE";
 z+="        end if\xFE";
 z+="    \xFE";
 z+="        // Local versions come before q-ptrs\xFE";
 z+="        I_Open DictData, FName To fHandle Then Return True\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    // Check for Q versions and set QActName\xFE";
 z+="    If isQDRec Then \xFE";
 z+="        If DictData = \"dict\" Then\xFE";
 z+="            // DICT is local\xFE";
 z+="            I_Open \"dict\", QFName To fHandle Then Return True\xFE";
 z+="            I_createfile \"dict \":QFName Else Return False\xFE";
 z+="            I_Open \"dict\", QFName To fHandle Then Return True\xFE";
 z+="            Return False\xFE";
 z+="        End If \xFE";
 z+="    End If\xFE";
 z+="     \xFE";
 z+="    If isQRec Then\xFE";
 z+="        Dim QActName As String = Trim(QRec<2, isQRec>)\xFE";
 z+="        QFName = Trim(QRec<3, isQRec>)\xFE";
 z+="        If QFName = \"\" Then QFName = FName\xFE";
 z+="\xFE";
 z+="        if QActName Then\xFE";
 z+="            Dim httpAddress As String = AttachRemoteDB(QActName, fALSE)\xFE";
 z+="            If Left(httpAddress, 1) = \"!\" Then Return False ;* AttachDB error (!)\xFE";
 z+="            if httpAddress = \".\" then QActName = \"\"\xFE";
 z+="        End If\xFE";
 z+="        \xFE";
 z+="        // No Account given?\xFE";
 z+="        If QActName = \"\" Or QActName = \".\" Then\xFE";
 z+="            If LCase(QFName) = LCase(FName) Then Return False\xFE";
 z+="            if rmtOnly Then If left(LCase(QFName), 4) <> \"rmt:\" then QFName = \"rmt:\":QFName\xFE";
 z+="            Return @Jsb_odb.open(DictData, QFName, fHandle) ;* Check For Another Q-Ptr\xFE";
 z+="        End If\xFE";
 z+="    \xFE";
 z+="        // ====================== HANDLE Q ACCOUNTS via ATTACH ====================== \xFE";
 z+="        If Left(httpAddress, 1) = \"@\" Then\xFE";
 z+="            protocol = Mid(httpAddress<1, 1>, 2)\xFE";
 z+="            cName = \"jsb_odb|\":protocol:\"_open\"\xFE";
 z+="            Call @cName(ByVal httpAddress<1, 2>, ByVal DictData, ByVal QFName, ByRef fHandle, ByRef Success)\xFE";
 z+="            Return Success\xFE";
 z+="        End If\xFE";
 z+="    \xFE";
 z+="        If httpAddress Then\xFE";
 z+="            Call rpc_Open(httpAddress, DictData, QFName, fHandle, Success)\xFE";
 z+="            Return Success\xFE";
 z+="        End If\xFE";
 z+="    \xFE";
 z+="        // non-http - attempt internal Attach to a Database\xFE";
 z+="        Dim currentAccount As String = @Account\xFE";
 z+="        \xFE";
 z+="        // Try internal attach\xFE";
 z+="        I_AttachDB QActName Else\xFE";
 z+="            I_AttachDB currentAccount Else Null\xFE";
 z+="            @Errors = \"Unable to attach to account \":QActName\xFE";
 z+="            Return False\xFE";
 z+="        End If\xFE";
 z+="        Dim OpenSuccess As Boolean\xFE";
 z+="        I_Open DictData, QFName To fHandle Then OpenSuccess = True Else OpenSuccess = False\xFE";
 z+="        Dim openError As String = @Errors\xFE";
 z+="        \xFE";
 z+="        // reset current account\xFE";
 z+="        I_AttachDB currentAccount Else Null\xFE";
 z+="        \xFE";
 z+="        // return error or success\xFE";
 z+="        @Errors = openError\xFE";
 z+="        Return OpenSuccess\xFE";
 z+="    End If\xFE";
 z+="        \xFE";
 z+="    if rmtOnly then\xFE";
 z+="        I_Open DictData, FName To fHandle Then\xFE";
 z+="            if system(1) = \"js\" then\xFE";
 z+="               if Left(fHandle, 1) = \"/\" Then Return True // odbTypeHttp (H)\xFE";
 z+="            Else if system(1) = \"gae\" then\xFE";
 z+="               if Left(fHandle, 1) <> \"0\" Then Return True\xFE";
 z+="            Elseif system(1) = \"aspx\" then\xFE";
 z+="               if Left(fHandle, 4) = \"ado:\" Then Return True \xFE";
 z+="            End If\xFE";
 z+="        end if\xFE";
 z+="        Dim Errs As String = FName:\" does not exist remotely\"\xFE";
 z+="    else\xFE";
 z+="        I_Open DictData, FName To fHandle Then Return True\xFE";
 z+="        Errs = @Errors\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    // is this file in the attached database?\xFE";
 z+="    Dim Account As String = @Session.AttachedDatabase\xFE";
 z+="    Dim CachedAccounts As String = @Session.CachedAccounts\xFE";
 z+="    Dim Spot As Integer\xFE";
 z+="    Locate Account In CachedAccounts<1> Setting Spot Then \xFE";
 z+="        httpAddress = Replace(CachedAccounts<2, Spot>, \"%%\", Chr(253))\xFE";
 z+="        \xFE";
 z+="        If Left(httpAddress, 1) = \"@\" Then\xFE";
 z+="            Dim A1 As String = Field(httpAddress, Vm(), 1)\xFE";
 z+="            Dim LoginInfo As String = DropLeft(httpAddress, Vm())\xFE";
 z+="            Dim odbSub As String = \"jsb_odb.\":Mid(A1, 2):\"_open\"\xFE";
 z+="            Call @odbSub(ByVal LoginInfo, ByVal DictData, ByVal FName, ByRef fHandle, ByRef Success)\xFE";
 z+="            Return Success\xFE";
 z+="            \xFE";
 z+="        ElseIf httpAddress Then\xFE";
 z+="            Call rpc_Open(httpAddress, DictData, FName, fHandle, Success)\xFE";
 z+="            Return Success\xFE";
 z+="        End If\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    @Errors = Errs\xFE";
 z+="    Return False\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="function CreateFile(ByVal DictData As String, ByVal FileName As String) As Boolean\xFE";
 z+="    Dim Account As String = @Session.AttachedDatabase\xFE";
 z+="    Dim CachedAccounts As String = @Session.CachedAccounts\xFE";
 z+="    \xFE";
 z+="    if !Len(FileName) Then\xFE";
 z+="        FileName = RTrim(DictData)\xFE";
 z+="        DictData = \"\"\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    DictData = LCase(Trim(DictData))\xFE";
 z+="    FileName= RTrim(LTrim(FileName))\xFE";
 z+="    \xFE";
 z+="    Dim lfName As String = LCase(FileName)\xFE";
 z+="    If Left(lfName, 5) = \"dict \" Or Left(lfName, 5) = \"data \" Then\xFE";
 z+="        DictData = Left(lfName, 4)\xFE";
 z+="        FileName = Mid(FileName, 6)\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    Dim Spot As Integer\xFE";
 z+="    Locate Account In CachedAccounts<1> Setting Spot Then \xFE";
 z+="        Dim httpAddress As String = Replace(CachedAccounts<2, Spot>, \"%%\", Chr(253))\xFE";
 z+="        Dim Success As Boolean\xFE";
 z+="        \xFE";
 z+="        If Left(httpAddress, 1) = \"@\" Then\xFE";
 z+="            Dim A1 As String = Field(httpAddress, Vm(), 1)\xFE";
 z+="            Dim LoginInfo As String = DropLeft(httpAddress, Vm())\xFE";
 z+="            Dim rmtCall As String = \"jsb_odb.\":Mid(A1, 2):\"_CreateFile\"\xFE";
 z+="            Call @rmtCall(ByVal LoginInfo, ByVal DictData, ByVal FileName, ByRef Success)\xFE";
 z+="            Return Success\xFE";
 z+="            \xFE";
 z+="        ElseIf httpAddress Then\xFE";
 z+="            Dim fHandle As Object = Nothing\xFE";
 z+="            Call rpc_CreateFile(httpAddress, LTrim(DictData:\" \":FileName), fHandle, Success)\xFE";
 z+="            Return Success\xFE";
 z+="        End If\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    I_createfile LTrim(DictData:\" \"):FileName Then Return 1 Else Return 0\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="function ClearFile(ByVal fHandle As Object)  As Boolean\xFE";
 z+="    * $options gae\xFE";
 z+="    Call clearRefCache(fHandle)\xFE";
 z+="    \xFE";
 z+="    If Left(fHandle, 1) = \"@\" Then\xFE";
 z+="        cName = \"jsb_odb|\":Mid(Field(fHandle, \".\", 1), 2):\"_clearfile\"\xFE";
 z+="        rfHandle = Mid(fHandle, Col2()+1)\xFE";
 z+="        Call @cName(ByVal rfHandle, ByRef Success)\xFE";
 z+="        Return Success\xFE";
 z+="    End If\xFE";
 z+="    Loop\xFE";
 z+="        I_ClearFile fHandle Then Return True\xFE";
 z+="    While Instr(@Errors, \"retry:\") And System(1) = \"gae\" Do\xFE";
 z+="        @Server.Flush\xFE";
 z+="    Repeat\xFE";
 z+="\xFE";
 z+="    Return False\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="function ClearFile(ByVal fHandle As Object)  As Boolean\xFE";
 z+="    * $options aspx, js\xFE";
 z+="    \xFE";
 z+="    Call clearRefCache(fHandle)\xFE";
 z+="    \xFE";
 z+="    If Left(fHandle, 1) = \"@\" Then\xFE";
 z+="        Dim cName As String = \"jsb_odb|\":Mid(Field(fHandle, \".\", 1), 2):\"_clearfile\"\xFE";
 z+="        Dim rfHandle As String = Mid(fHandle, Col2()+1)\xFE";
 z+="        Dim Success As Boolean\xFE";
 z+="        Call @cName(ByVal rfHandle, ByRef Success)\xFE";
 z+="        Return Success\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    I_ClearFile fHandle Then Return True\xFE";
 z+="\xFE";
 z+="    Return False\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="function DeleteFile(ByVal fHandle As Object) As Boolean\xFE";
 z+="    Call clearRefCache(fHandle)\xFE";
 z+="    \xFE";
 z+="    If Left(fHandle, 1) = \"@\" Then\xFE";
 z+="        Dim cName As String = \"jsb_odb|\":Mid(Field(fHandle, \".\", 1), 2):\"_deletefile\"\xFE";
 z+="        Dim rfHandle As String = Mid(fHandle, Col2()+1)\xFE";
 z+="        Dim Success As Boolean\xFE";
 z+="        Call @cName(ByVal rfHandle, ByRef Success)\xFE";
 z+="        Return Success\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    I_DeleteFile fHandle Then Return 1 Else Return 0\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="function DeleteItem(ByVal fHandle As Object, ByVal IName As String) As Boolean\xFE";
 z+="    Call clearRefCache(fHandle)\xFE";
 z+="    \xFE";
 z+="    If Left(fHandle, 1) = \"@\" Then\xFE";
 z+="        Dim cName As String = \"jsb_odb|\":Mid(Field(fHandle, \".\", 1), 2):\"_deleteitem\"\xFE";
 z+="        Dim rfHandle As String = Mid(fHandle, Col2()+1)\xFE";
 z+="        Dim Success As Boolean\xFE";
 z+="        Call @cName(ByVal rfHandle, ByVal IName, ByRef Success)\xFE";
 z+="        Return Success\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    I_Delete fHandle, IName Then Return 1 Else Return 0\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="function Read(Item As String, ByVal fHandle As Object, ByVal IName As String) As Boolean\xFE";
 z+="    If Left(fHandle, 1) = \"@\" Then\xFE";
 z+="        Dim cName As String = \"jsb_odb|\":Mid(Field(fHandle, \".\", 1), 2):\"_read\"\xFE";
 z+="        Dim rfHandle As String = Mid(fHandle, Col2()+1)\xFE";
 z+="        Dim Success As Boolean\xFE";
 z+="        Call @cName(ByRef Item, ByVal rfHandle, ByVal IName, ByRef Success)\xFE";
 z+="        Return Success\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    Return @Jsb_odb.ReadX(Item, fHandle, IName, False)\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="* ReadM only use by javascript jsb\xFE";
 z+="function ReadM(Item, ByVal fHandle As Object, ByVal IName As String) As Boolean\xFE";
 z+="    * $options js\xFE";
 z+="    If Left(fHandle, 1) = \"@\" Then\xFE";
 z+="        Dim cName As String = \"jsb_odb|\":Mid(Field(fHandle, \".\", 1), 2):\"_read\"\xFE";
 z+="        Dim rfHandle As String = Mid(fHandle, Col2()+1)\xFE";
 z+="        Dim Success As Boolean\xFE";
 z+="        rfHandle = Mid(fHandle, Col2()+1)\xFE";
 z+="        Call @cName(ByRef Item, ByVal rfHandle, ByVal IName, ByRef Success)\xFE";
 z+="    Else\xFE";
 z+="        Success = @Jsb_odb.ReadX(Item, fHandle, IName, False)\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    If !Success Then Return False\xFE";
 z+="    Item = Split(Item, Am())\xFE";
 z+="    Return Success\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="* ReadM only use by javascript jsb\xFE";
 z+="function ReadMU(Item, ByVal fHandle As Object, ByVal IName As String) As Boolean\xFE";
 z+="    * $options js\xFE";
 z+="    If Left(fHandle, 1) = \"@\" Then\xFE";
 z+="        cName = \"jsb_odb|\":Mid(Field(fHandle, \".\", 1), 2):\"_readu\"\xFE";
 z+="        rfHandle = Mid(fHandle, Col2()+1)\xFE";
 z+="        Call @cName(ByRef Item, ByVal rfHandle, ByVal IName, ByRef Success)\xFE";
 z+="    Else\xFE";
 z+="        Success = @Jsb_odb.ReadX(Item, fHandle, IName, True)\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    If !Success Then Return False\xFE";
 z+="    Item = Split(Item, Am())\xFE";
 z+="    Return Success\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="\xFE";
 z+="function ReadU(Item As String, ByVal fHandle As Object, ByVal IName As String) As Boolean\xFE";
 z+="    If Left(fHandle, 1) = \"@\" Then\xFE";
 z+="        Dim cName As String = \"jsb_odb|\":Mid(Field(fHandle, \".\", 1), 2):\"_readu\"\xFE";
 z+="        Dim rfHandle As String = Mid(fHandle, Col2()+1)\xFE";
 z+="        Dim Success As Boolean\xFE";
 z+="        Call @cName(ByRef Item, ByVal rfHandle, ByVal IName, ByRef Success)\xFE";
 z+="        Return Success\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    Return @Jsb_odb.ReadX(Item, fHandle, IName, True)\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="function ReadX(Item As String, ByVal fHandle As Object, ByVal IName As String, ByVal IsReadU As Boolean) As Boolean\xFE";
 z+="    If LCase(Left(fHandle, 4)) = \"http\" Then\xFE";
 z+="        Dim fH As FileHandle\xFE";
 z+="        I_Open fHandle To Fh Else Return 0\xFE";
 z+="        I_Read Item From Fh, \"\" Then Return 1 Else Return 0\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    If IsReadU Then\xFE";
 z+="        I_ReadU Item From fHandle, IName Then Return 1 Else Return 0\xFE";
 z+="    Else\xFE";
 z+="        I_Read Item From fHandle, IName Then Return 1 Else Return 0\xFE";
 z+="    End If\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="function ReadJSon(Item As Object, ByVal fHandle As Object, ByVal IName As String) As Boolean\xFE";
 z+="    If Left(fHandle, 1) = \"@\" Then\xFE";
 z+="        Dim cName As String = \"jsb_odb|\":Mid(Field(fHandle, \".\", 1), 2):\"_readjson\"\xFE";
 z+="        Dim rfHandle As String = Mid(fHandle, Col2()+1)\xFE";
 z+="        Dim Success As Boolean\xFE";
 z+="        Call @cName(ByRef Item, ByVal rfHandle, ByVal IName, ByRef Success)\xFE";
 z+="        Return Success\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    I_ReadJSon Item From fHandle, IName Then Return True Else Return False\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="function ReadJSonU(Item As Object, ByVal fHandle As Object, ByVal IName As String) As Boolean\xFE";
 z+="    If Left(fHandle, 1) = \"@\" Then\xFE";
 z+="        Dim cName As String = \"jsb_odb|\":Mid(Field(fHandle, \".\", 1), 2):\"_readjsonu\"\xFE";
 z+="        Dim rfHandle As String = Mid(fHandle, Col2()+1)\xFE";
 z+="        Dim Success As Boolean\xFE";
 z+="        Call @cName(ByRef Item, ByVal rfHandle, ByVal IName, ByRef Success)\xFE";
 z+="        Return Success\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    I_ReadJSonU Item From fHandle, IName Then Return True Else Return False\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="function ReadV(Line As String, ByVal fHandle As Object, ByVal IName As String, ByVal AtrNo As Integer) As Boolean\xFE";
 z+="    * $options aspxc-\xFE";
 z+="    \xFE";
 z+="    If Left(fHandle, 1) = \"@\" Then\xFE";
 z+="        Dim cName As String = \"jsb_odb|\":Mid(Field(fHandle, \".\", 1), 2):\"_readv\"\xFE";
 z+="        Dim rfHandle As String = Mid(fHandle, Col2()+1)\xFE";
 z+="        Dim Success As Boolean\xFE";
 z+="        Call @cName(ByRef Item, ByVal rfHandle, ByVal IName, ByVal AtrNo, ByRef Success)\xFE";
 z+="        Return Success\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    I_ReadV Line From fHandle, IName, AtrNo Else Return False\xFE";
 z+="    Return True\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="function ReadVU(Line As String, ByVal fHandle As Object, ByVal IName As String, ByVal AtrNo As Integer) As Boolean\xFE";
 z+="    * $options aspxc-\xFE";
 z+="    \xFE";
 z+="    If Left(fHandle, 1) = \"@\" Then\xFE";
 z+="        Dim cName As String = \"jsb_odb|\":Mid(Field(fHandle, \".\", 1), 2):\"_readvu\"\xFE";
 z+="        Dim rfHandle As String = Mid(fHandle, Col2()+1)\xFE";
 z+="        Dim Success As Boolean\xFE";
 z+="        Call @cName(ByRef Item, ByVal rfHandle, ByVal IName, ByVal AtrNo, ByRef Success)\xFE";
 z+="        Return Success\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    I_ReadU Line From fHandle, IName Else Return False\xFE";
 z+="    Line = Item<AtrNo>\xFE";
 z+="    Return True\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="function ReadXml(Item As Object, ByVal fHandle As Object, ByVal IName As String) As Boolean\xFE";
 z+="    * $options aspxc-\xFE";
 z+="    If Left(fHandle, 1) = \"@\" Then\xFE";
 z+="        Dim cName As String = \"jsb_odb|\":Mid(Field(fHandle, \".\", 1), 2):\"_readxml\"\xFE";
 z+="        Dim rfHandle As String = Mid(fHandle, Col2()+1)\xFE";
 z+="        Dim Success As Boolean\xFE";
 z+="        Call @cName(ByRef Item, ByVal rfHandle, ByVal IName, ByRef Success)\xFE";
 z+="        Return Success\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    I_ReadXml Item From fHandle, IName Then Return True Else Return False\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="function ReadXmlU(Item As Object, ByVal fHandle As Object, ByVal IName As String) As Boolean\xFE";
 z+="    * $options aspxc-\xFE";
 z+="    If Left(fHandle, 1) = \"@\" Then\xFE";
 z+="        Dim cName As String = \"jsb_odb|\":Mid(Field(fHandle, \".\", 1), 2):\"_readxmlu\"\xFE";
 z+="        Dim rfHandle As String = Mid(fHandle, Col2()+1)\xFE";
 z+="        Dim Success As Boolean\xFE";
 z+="        Call @cName(ByRef Item, ByVal rfHandle, ByVal IName, ByRef Success)\xFE";
 z+="        Return Success\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    I_ReadXmlU Item From fHandle, IName Then Return True Else Return False\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="function Write(ByVal Item As String, ByVal fHandle As Object, ByVal IName As String) As Boolean\xFE";
 z+="    Call clearRefCache(fHandle)\xFE";
 z+="    \xFE";
 z+="    If Left(fHandle, 1) = \"@\" Then\xFE";
 z+="        Dim cName As String = \"jsb_odb|\":Mid(Field(fHandle, \".\", 1), 2):\"_write\"\xFE";
 z+="        Dim rfHandle As String = Mid(fHandle, Col2()+1)\xFE";
 z+="        Dim Success As Boolean\xFE";
 z+="        Call @cName(ByVal Item, ByVal rfHandle, ByVal IName, ByRef Success)\xFE";
 z+="        Return Success\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    I_Write  Item On fHandle, IName Then Return 1 Else Return 0\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="function WriteU(ByVal Item As String, ByVal fHandle As Object, ByVal IName As String) As Boolean\xFE";
 z+="    Call clearRefCache(fHandle)\xFE";
 z+="    \xFE";
 z+="    If Left(fHandle, 1) = \"@\" Then\xFE";
 z+="        Dim cName As String = \"jsb_odb|\":Mid(Field(fHandle, \".\", 1), 2):\"_writeu\"\xFE";
 z+="        Dim rfHandle As String = Mid(fHandle, Col2()+1)\xFE";
 z+="        Dim Success As Boolean\xFE";
 z+="        Call @cName(ByVal Item, ByVal rfHandle, ByVal IName, ByRef Success)\xFE";
 z+="        Return Success\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    I_WriteU Item On fHandle, IName Then Return 1 Else Return 0\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="function WriteJSon(ByVal Item  As Object, ByVal fHandle As Object, ByVal IName As String) As Boolean\xFE";
 z+="    Call clearRefCache(fHandle)\xFE";
 z+="    \xFE";
 z+="    If Left(fHandle, 1) = \"@\" Then\xFE";
 z+="        Dim cName As String = \"jsb_odb|\":Mid(Field(fHandle, \".\", 1), 2):\"_writejson\"\xFE";
 z+="        Dim rfHandle As String = Mid(fHandle, Col2()+1)\xFE";
 z+="        Dim Success As Boolean\xFE";
 z+="        Call @cName(ByVal Item, ByVal rfHandle, ByVal IName, ByRef Success)\xFE";
 z+="        Return Success\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    I_WriteJSon Item On fHandle, IName Then Return 1 Else Return 0\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="function WriteJSonU(ByVal Item As Object, ByVal fHandle As Object, ByVal IName As String) As Boolean\xFE";
 z+="    Call clearRefCache(fHandle)\xFE";
 z+="    \xFE";
 z+="    If Left(fHandle, 1) = \"@\" Then\xFE";
 z+="        Dim cName As String = \"jsb_odb|\":Mid(Field(fHandle, \".\", 1), 2):\"_writejsonu\"\xFE";
 z+="        Dim rfHandle As String = Mid(fHandle, Col2()+1)\xFE";
 z+="        Dim Success As Boolean\xFE";
 z+="        Call @cName(ByVal Item, ByVal rfHandle, ByVal IName, ByRef Success)\xFE";
 z+="        Return Success\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    I_WriteJsonU Item On fHandle, IName Then Return 1 Else Return 0\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="function WriteV(ByVal Line As String, ByVal fHandle As Object, ByVal IName As String, ByVal AtrNo As Integer) As Boolean\xFE";
 z+="*$options aspx, gae, aspxc-\xFE";
 z+="    I_Read Item From fHandle, IName Else Item = \"\"\xFE";
 z+="    Item<AtrNo> = Line\xFE";
 z+="    I_Write Item On fHandle, IName Then Return 1 Else Return 0\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="function WriteV(ByVal Line As String, ByVal fHandle As Object, ByVal IName As String, ByVal AtrNo As Integer) As Boolean\xFE";
 z+="*$options js\xFE";
 z+="    I_WriteV Line On fHandle, IName, AtrNo Then Return 1 Else Return 0\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="function WriteVU(ByVal Line As String, ByVal fHandle As Object, ByVal IName As String, ByVal AtrNo As Integer) As Boolean\xFE";
 z+="*$options aspx, gae, aspxc-\xFE";
 z+="    I_ReadU Item From fHandle, IName Else Item = \"\"\xFE";
 z+="    Item<AtrNo> = Line\xFE";
 z+="    I_WriteU Item On fHandle, IName Then Return 1 Else Return 0\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="function WriteVU(ByVal Line As String, ByVal fHandle As Object, ByVal IName As String, ByVal AtrNo As Integer) As Boolean\xFE";
 z+="*$options js\xFE";
 z+="    I_WriteVU Line On fHandle, IName, AtrNo Then Return 1 Else Return 0\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="function WriteXml(ByVal Item As Object, ByVal fHandle As Object, ByVal IName As String) As Boolean\xFE";
 z+="    * $options aspxc-\xFE";
 z+="    Call clearRefCache(fHandle)\xFE";
 z+="    \xFE";
 z+="    If Left(fHandle, 1) = \"@\" Then\xFE";
 z+="        cName = \"jsb_odb|\":Mid(Field(fHandle, \".\", 1), 2):\"_writexml\"\xFE";
 z+="        rfHandle = Mid(fHandle, Col2()+1)\xFE";
 z+="        Call @cName(ByVal Item, ByVal rfHandle, ByVal IName, ByRef Success)\xFE";
 z+="        Return Success\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    I_WriteXml Item On fHandle, IName Then Return 1 Else Return 0\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="function WriteXmlU(ByVal Item  As Object, ByVal fHandle As Object, ByVal IName As String) As Boolean\xFE";
 z+="    * $options aspxc-\xFE";
 z+="    Call clearRefCache(fHandle)\xFE";
 z+="    \xFE";
 z+="    If Left(fHandle, 1) = \"@\" Then\xFE";
 z+="        cName = \"jsb_odb|\":Mid(Field(fHandle, \".\", 1), 2):\"_writexmlu\"\xFE";
 z+="        rfHandle = Mid(fHandle, Col2()+1)\xFE";
 z+="        Call @cName(ByVal Item, ByVal rfHandle, ByVal IName, ByRef Success)\xFE";
 z+="        Return Success\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    I_WriteXmlU Item On fHandle, IName Then Return 1 Else Return 0\xFE";
 z+="End function"
window.cached_jsb_odb["i_db"]=z;
var z="sub log_db\xFE";
 z+="    * Just a place holder so we skip the compiler error\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub log_Login(ByRef LoginInfo, ByVal Provider, ByVal username As String, ByVal password As String, ByVal initialdb As String)\xFE";
 z+="   @Errors = \"Attaching to the log DB isn't possbile\"\xFE";
 z+="   LoginInfo = \"\"\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub log_Open(ByVal LoginInfo, ByVal DictData, ByVal FName, ByRef fHandle, ByRef Success)\xFE";
 z+="    ' Do the normal open for the fHandle\xFE";
 z+="    i_open dictdata, fname to fHandle else \xFE";
 z+="        Success = False\xFE";
 z+="        Return\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    Success = True\xFE";
 z+="    fhandle = DictData:AM():FNAME\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub log_CreateFile(ByVal LoginInfo, ByVal FileName, ByRef fHandle, ByRef Success)\xFE";
 z+="    Success = False\xFE";
 z+="    I_CreateFile FileName Then \xFE";
 z+="        i_open FileName To fHandle Then Success = True\xFE";
 z+="    End If\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub log_ReadJSon(ByRef Item, ByVal fHandle, ByVal IName, ByRef Success)\xFE";
 z+="    Call log_ReadX(Item, fHandle, IName, Success, \"JSon\")\xFE";
 z+="    If (Left(Item, 1) = \"{\" Or Left(Item, 1) = \"[\") And Success Then Item = JSon(item)\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub log_ReadJSonU(ByRef Item, ByVal fHandle, ByVal IName, ByRef Success)\xFE";
 z+="    Call log_ReadX(Item, fHandle, IName, Success, \"JSonU\")\xFE";
 z+="    If (Left(Item, 1) = \"{\" Or Left(Item, 1) = \"[\") And Success Then Item = JSon(item)\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub log_ReadXML(ByRef Item, ByVal fHandle, ByVal IName, ByRef Success)\xFE";
 z+="    Call log_ReadX(Item, fHandle, IName, Success, \"XML\")\xFE";
 z+="    If Left(Item, 1) = \"<\" And Success Then Item = XML(item)\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub log_ReadXMLU(ByRef Item, ByVal fHandle, ByVal IName, ByRef Success)\xFE";
 z+="    Call log_ReadX(Item, fHandle, IName, Success, \"XMLU\")\xFE";
 z+="    If Left(Item, 1) = \"<\" And Success Then Item = XML(item)\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub log_Read(ByRef Item, ByVal fHandle, ByVal IName, ByRef Success)\xFE";
 z+="    Call log_ReadX(Item, fHandle, IName, Success, \"\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub log_ReadU(ByRef Item, ByVal fHandle, ByVal IName, ByRef Success)\xFE";
 z+="    Call log_ReadX(Item, fHandle, IName, Success, \"U\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub log_ReadV(ByRef Item, ByVal fHandle, ByName IName, ByVal AtrNo, ByRef Success)\xFE";
 z+="    Call log_ReadX(Item, fHandle, IName, Success, \"\")\xFE";
 z+="    If !Success Then Return\xFE";
 z+="    Item = Item<AtrNo>\xFE";
 z+="    Return\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub log_ReadVU(ByRef Item, ByVal fHandle, ByName IName, ByVal AtrNo, ByRef Success)\xFE";
 z+="    Call log_ReadX(Item, fHandle, IName, Success, \"U\")\xFE";
 z+="    If !Success Then Return\xFE";
 z+="    Item = Item<AtrNo>\xFE";
 z+="    Return\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub log_ReadX(ByRef Item, byval fHandle, ByVal IName, ByRef Success, ByVal RType)\xFE";
 z+="    Item = \"\"\xFE";
 z+="    fHandle = log_reopen(fHandle)\xFE";
 z+="    Select Case RType\xFE";
 z+="       Case \"U\"\xFE";
 z+="           ReadU Item From fHandle, IName Then Success = True Else Success = False\xFE";
 z+="           \xFE";
 z+="       Case \"JSon\"\xFE";
 z+="           ReadJSon Item From fHandle, IName Then Success = True Else Success = False\xFE";
 z+="           \xFE";
 z+="       Case \"JSonU\"\xFE";
 z+="           ReadJSonU Item From fHandle, IName Then Success = True Else Success = False\xFE";
 z+="           \xFE";
 z+="       Case \"XML\"\xFE";
 z+="           ReadXML Item From fHandle, IName Then Success = True Else Success = False\xFE";
 z+="           \xFE";
 z+="       Case \"XMLU\"\xFE";
 z+="           ReadXMLU Item From fHandle, IName Then Success = True Else Success = False\xFE";
 z+="           \xFE";
 z+="       Case Else\xFE";
 z+="           Read Item From fHandle, IName Then Success = True Else Success = False\xFE";
 z+="    End Select\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub log_ListFiles(ByVal LoginInfo, ByRef Result, ByRef Success)\xFE";
 z+="    I_ListFiles To Result Else Result = \"\"\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub log_DeleteFile(byval fHandle, ByRef Success)\xFE";
 z+="    fHandle = log_reopen(fHandle)\xFE";
 z+="    DeleteFile fHandle Then Success = 1 Else Success = 0\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub log_primarykeyname(ByVal fHandle, ByRef Result As String, ByRef Success As Boolean)\xFE";
 z+="    fHandle = log_reopen(fHandle)\xFE";
 z+="    Result = primaryKeyName(fHandle)\xFE";
 z+="    Success = Result <> \"\"\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub log_ClearFile(byval fHandle, ByRef Success)\xFE";
 z+="    fHandle = log_reopen(fHandle)\xFE";
 z+="    ClearFile fHandle Then Success = 1 Else Success = 0\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub log_DeleteItem(byval fHandle, ByVal IName, ByRef Success)\xFE";
 z+="    nHandle = log_reopen(fHandle)\xFE";
 z+="    Delete nHandle, IName Then Success = 1 Else Success = 0\xFE";
 z+="    if Success Then Call log_UpdateLog(fHandle, IName, Chr(255):\"*DELETED*\":Chr(255))\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub log_Select(ByVal Cols, byval fHandle, ByVal WhereClause, ByRef Success)\xFE";
 z+="    fHandle = log_reopen(fHandle)\xFE";
 z+="    Select Cols from fHandle where WhereClause Then Success = 1 Else Success = 0\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub log_SelectTo(ByVal Cols, byval fHandle, ByVal WhereClause, ByRef SL, ByRef Success)\xFE";
 z+="    fHandle = log_reopen(fHandle)\xFE";
 z+="    Select cols from fHandle where WhereClause to SL Then Success = 1 Else Success = 0\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub log_Write(byval Item, fHandle, byval IName, ByRef Success)\xFE";
 z+="    Call log_WriteX(Item, fHandle, IName, Success, \"\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub log_WriteU(ByVal Item, ByVal fHandle, ByVal IName, ByRef Success)\xFE";
 z+="    Call log_WriteX(Item, fHandle, IName, Success, \"U\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub log_WriteJSon(ByVal Item, ByVal fHandle, ByVal IName, ByRef Success)\xFE";
 z+="    Call log_WriteX(Item, fHandle, IName, Success, \"JSon\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub log_WriteJSonU(ByVal Item, ByVal fHandle, ByVal IName, ByRef Success)\xFE";
 z+="    Call log_WriteX(Item, fHandle, IName, Success, \"JSonU\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub log_WriteXml(ByVal Item, ByVal fHandle, ByVal IName, ByRef Success)\xFE";
 z+="    Call log_WriteX(Item, fHandle, IName, Success, \"Xml\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub log_WriteXmlU(ByVal Item, ByVal fHandle, ByVal IName, ByRef Success)\xFE";
 z+="    Call log_WriteX(Item, fHandle, IName, Success, \"XmlU\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub log_WriteX(byval Item, byval fHandle, byval IName, ByRef Success, wType)\xFE";
 z+="    nHandle = log_reopen(fHandle)\xFE";
 z+="    Select Case wType\xFE";
 z+="       Case \"U\"\xFE";
 z+="           WriteU Item On fHandle, IName Then Success = True Else Success = False\xFE";
 z+="           \xFE";
 z+="       Case \"JSon\"\xFE";
 z+="           WriteJSon Item On nHandle, IName Then Success = True Else Success = False\xFE";
 z+="           \xFE";
 z+="       Case \"JSonU\"\xFE";
 z+="           WriteJSonU Item On nHandle, IName Then Success = True Else Success = False\xFE";
 z+="           \xFE";
 z+="       Case \"XML\"\xFE";
 z+="           WriteXML Item On nHandle, IName Then Success = True Else Success = False\xFE";
 z+="           \xFE";
 z+="       Case \"XMLU\"\xFE";
 z+="           WriteXMLU Item On nHandle, IName Then Success = True Else Success = False\xFE";
 z+="           \xFE";
 z+="       Case Else\xFE";
 z+="           Write Item On nHandle, IName Then Success = True Else Success = False\xFE";
 z+="    End Select\xFE";
 z+="    if Success Then Call log_UpdateLog(fHandle, IName, Item)\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="sub log_UpdateLog(fHandle, IName, Item)\xFE";
 z+="    * Update Log - fHandle is DictData<1>, FNAME<2>, fDbLog<3>\xFE";
 z+="    QFLogfileName = fHandle<3>\xFE";
 z+="    if !QFLogfileName Then QFLogfileName = \"dblog\"\xFE";
 z+="    \xFE";
 z+="    open QFLogfileName to fDbLog else \xFE";
 z+="        I_CreateFile QFLogfileName else \xFE";
 z+="            @Errors = 'Unable to create dbLog file:':QFLogfileName\xFE";
 z+="            Success = False\xFE";
 z+="            Return\xFE";
 z+="        end if\xFE";
 z+="        i_open QFLogfileName to fDbLog else \xFE";
 z+="            @Errors = 'Unable to open dbLog file:':QFLogfileName\xFE";
 z+="            Success = False\xFE";
 z+="            Return\xFE";
 z+="        end if\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    logID = CInt(now() * 60 * 6): '.log' ;* new log file every 10 minutes\xFE";
 z+="    i_ReadJson logRec From fDbLog, logID else logRec = [ { deviceSerialNumber: deviceserialnumber() } ]\xFE";
 z+="    lrec = { dictData: fHandle<1>, fileName: fHandle<2>, itemName: IName, dateTime: now() }\xFE";
 z+="    lrec.item = item\xFE";
 z+="    logRec[-1] = lrec\xFE";
 z+="    i_writejson logRec on fDbLog, logID Else @Alert(@errors)\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="function log_reopen(fHandle)\xFE";
 z+="    if fHandle<4> = \"a\" then\xFE";
 z+="        open fhandle<1>, fhandle<2> to nHandle Then Return nHandle\xFE";
 z+="    else\xFE";
 z+="        i_open fhandle<1>, fhandle<2> to nHandle Then Return nHandle\xFE";
 z+="    end if\xFE";
 z+="    alert('I was unable to reopen then table ':fHandle<2>:'!');\xFE";
 z+="end function\xFE";
 z+=""
window.cached_jsb_odb["log_db"]=z;
var z="/*\xFE";
 z+="    See: http://docs.identityserver.io/en/latest/endpoints/authorize.html\xFE";
 z+="         http://docs.identityserver.io/en/latest/endpoints/token.html\xFE";
 z+="         http://docs.identityserver.io/en/latest/endpoints/userinfo.html\xFE";
 z+="         \xFE";
 z+="    jsb_config oauthName_Config:\xFE";
 z+="        {\xFE";
 z+="         \"client_secret\": \"xxxxxxxxxx\",\xFE";
 z+="         \"authorize\": \"https://accounts.google.com/o/oauth2/v2/auth\",\xFE";
 z+="         \"token\": \"https://accounts.google.com/o/oauth2/v4/token\xFE";
 z+="         \"client_id\": \"331227674164-rv0l14alhk6di6m04p7l1rq0dut1dv78.apps.googleusercontent.com\",\xFE";
 z+="         \"jsbauthority\": \"https://jsonbasic.azurewebsites.net/sysprog\",\xFE";
 z+="         \"grant_type\": \"authorization_code\",\xFE";
 z+="         \"userinfo\": \"https://www.googleapis.com/oauth2/v2/userinfo\"\xFE";
 z+="        }\xFE";
 z+="*/\xFE";
 z+="\xFE";
 z+="sub oauth_subs\xFE";
 z+="end sub\xFE";
 z+="    \xFE";
 z+="program oLogin()\xFE";
 z+="    call pgm_authLogin\xFE";
 z+="end program\xFE";
 z+="\xFE";
 z+="program oauthLogin()\xFE";
 z+="    call pgm_authLogin\xFE";
 z+="end program\xFE";
 z+="\xFE";
 z+="//\xFE";
 z+="// May be called from jvascript (optionally with ?authority=oAuthAuthority&forceReapprove=booleanValue&returnurl=xxxx\xFE";
 z+="//  if no returnurl given - will close the page with close_html?access_token=nnnn\xFE";
 z+="//\xFE";
 z+="Sub pgm_authLogin\xFE";
 z+="    Dim oAuthAuthority As String = paramvar('authority')\xFE";
 z+="    Dim forceReapprove As Boolean = False\xFE";
 z+="    Dim rtnURL As String = @queryVar('returnurl')\xFE";
 z+="    if !rtnURL Then rtnURL = @queryVar('response_redirect')\xFE";
 z+="    \xFE";
 z+="    if oAuthAuthority then forceReapprove = paramvar('forceReapprove')\xFE";
 z+="    \xFE";
 z+="    /*     \xFE";
 z+="     if Right(rtnURL, 5) = \".html\" Or !rtnURL Then fromJSPage = \"1\" Else fromJSPage = \"0\"\xFE";
 z+="    */\xFE";
 z+="    \xFE";
 z+="    Dim access_token As String = oauth_Login(oAuthAuthority, forceReapprove)\xFE";
 z+="    if !access_token Then Stop @Errors\xFE";
 z+="    \xFE";
 z+="    if rtnUrl Then \xFE";
 z+="        //if InStr(rtnUrl, \"?\") Then rtnUrl := \"&\" Else rtnUrl := \"?\"\xFE";
 z+="        //rtnUrl := \"access_token=\":UrlEncode(access_token)\xFE";
 z+="        print @(-1):@Script(`window.location.href=`:jsEscapeString(rtnUrl))\xFE";
 z+="        @Server.Flush\xFE";
 z+="        stop\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    // We need to use response.redirect so that the rpcsid doesn't change\xFE";
 z+="    if @queryVar('returnurl') then @response.redirect(UrlDecode(@queryVar('returnurl')) )\xFE";
 z+="    if @queryVar('response_redirect') then @response.redirect(UrlDecode(queryVar('response_redirect')))\xFE";
 z+="    \xFE";
 z+="    Dim closeURL As String = @HtmlRoot:`close_html?access_token=`:@urlencode(access_token):`&userno=`:@UrlEncode(@userno)\xFE";
 z+="    \xFE";
 z+="    print @script(` \xFE";
 z+="        // debugger;\xFE";
 z+="        var myIFrame = parent.window['popOutID']\xFE";
 z+="        if (myIFrame) {\xFE";
 z+="            $(myIFrame).attr('src', \"`:closeURL:`\");\xFE";
 z+="        } else {\xFE";
 z+="            window.location.href = \"`:closeURL:`\";\xFE";
 z+="        }     \xFE";
 z+="    `);\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="// return an oauth access_token or null + @errors\xFE";
 z+="function oauth_Login(ByVal oAuthAuthority As String, byval forceReapprove As Boolean) As String\xFE";
 z+="    Dim userno As String = @userno\xFE";
 z+="    \xFE";
 z+="    Dim fTmp As fileHandle = fhandle('tmp')\xFE";
 z+="    \xFE";
 z+="    Dim _settings As JSON = Nothing\xFE";
 z+="    \xFE";
 z+="    if !oAuthAuthority Then \xFE";
 z+="        _settings = jsbConfig('authenticationtype', { value: 'local' })\xFE";
 z+="        oAuthAuthority = _settings.oauth_authority\xFE";
 z+="        if !oAuthAuthority Then Stop \"Please specify an oauth_authority in your default jsb_config authenticationtype\"\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    /*\xFE";
 z+="     rtnURL = UrlDecode(@queryVar('returnurl'))\xFE";
 z+="     if !rtnURL Then rtnURL = UrlDecode(@queryVar('response_redirect'))\xFE";
 z+="     if Right(rtnURL, 5) = \".html\" Or !rtnURL Then fromJSPage = \"1\" Else fromJSPage = \"0\"\xFE";
 z+="    */\xFE";
 z+="    \xFE";
 z+="    if Right(LCase(oAuthAuthority), 7) <> \"_config\" then oAuthAuthority := \"_config\"\xFE";
 z+="    i_readjson _settings from @fHandle('jsb_config'), oAuthAuthority else @Errors = oAuthAuthority:\" app _settings are not setup in jsb_config.\"; return Null\xFE";
 z+="    if Right(_settings.jsbauthority, 1) = \"/\" Then \xFE";
 z+="        _settings.jsbauthority = Left(_settings.jsbauthority, Len(_settings.jsbauthority) - 1)\xFE";
 z+="        i_write _settings on fHandle('jsb_config'), oAuthAuthority else null\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    // Steps:\xFE";
 z+="    //    1) We redirect the user to the oAuth login page (see _settings.authorize), passing a \"state\" parameter\xFE";
 z+="    //\xFE";
 z+="    //    2) after a login, the oauth will redirect the user to a known page (oauth_silent_redirect_uri) with an access code and the \"state\" we provided.\xFE";
 z+="    //       we exchange the access code for an access token, and then use the \"state\" to redirect the user back to where he came from.\xFE";
 z+="    //\xFE";
 z+="\xFE";
 z+="    \xFE";
 z+="    // Step 1:\xFE";
 z+="    //     Build URL to the oAuth server login page (_settings.authorize) to request a code\xFE";
 z+="\xFE";
 z+="    Dim Url As String = _settings.authorize\xFE";
 z+="    Url := `?response_type=code`\xFE";
 z+="    Url := `&client_id=`:UrlEncode(_settings.client_id)\xFE";
 z+="    if _settings.scope then Url := `&scope=`:UrlEncode(_settings.scope)\xFE";
 z+="    if _settings.response_mode then Url := `&response_mode=`:UrlEncode(_settings.response_mode)\xFE";
 z+="    \xFE";
 z+="    if forceReapprove then \xFE";
 z+="        if _settings.prompt then\xFE";
 z+="            // login: force login screen, none: don't show any login screens, and consent (force user to consent to giving app permisssions)\xFE";
 z+="            Url := `&prompt=login`\xFE";
 z+="        else\xFE";
 z+="            Url := `&force_reapprove=true`\xFE";
 z+="        end if\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    // Tell the oauth server where to redirect the user to exchange the code for a token (silent_redirect_uri)\xFE";
 z+="    Dim silent_redirect_uri As String = _settings.jsbauthority:\"/oauth_silent_redirect_uri\"\xFE";
 z+="    Dim SameOrigin As Boolean = Left(silent_redirect_uri, len(@jsbRootAct)) = @jsbRootAct \xFE";
 z+="    if instr(@url, \":443\") Then silent_redirect_uri = Replace(silent_redirect_uri, \"/\":Field(silent_redirect_uri, \"/\", 3):\"/\", \"/\":Field(silent_redirect_uri, \"/\", 3):\":443/\")\xFE";
 z+="    if Left(silent_redirect_uri, len(@jsbRootAct)) = @jsbRootAct Then SameOrigin = True\xFE";
 z+="    Url := `&redirect_uri=`:UrlEncode(silent_redirect_uri)\xFE";
 z+="    \xFE";
 z+="    // Build the \"state\" the will eventually be passed back to us, so we know where the send the user next\xFE";
 z+="    // use \"atoken_\" to write the access token on the server and we will fetch with a rest call\xFE";
 z+="    Dim rtnToURL As String\xFE";
 z+="    if SameOrigin then rtnToURL = @jsbRootAct:\"oauth_redirect_uri\" Else rtnToURL = \"atoken_\":DropIfLeft(userno, \":\")\xFE";
 z+="    Url := `&state=`:@UrlEncode(oAuthAuthority:\"*\":userno:\"*\":rtnToURL:\"*\":@url)\xFE";
 z+="    \xFE";
 z+="    Dim browserScript As String = @hidden(\"accesstoken\", \"\"):@Script(`\xFE";
 z+="        window.checkClosed = function () {\xFE";
 z+="            if (!winObj || winObj.closed || typeof winObj.closed=='undefined')  { \xFE";
 z+="                if (!window.cordova) doJsbSubmit(false) \xFE";
 z+="            } else setTimeout(checkClosed, 500); \xFE";
 z+="        }\xFE";
 z+="        \xFE";
 z+="        var winObj;\xFE";
 z+="        var url = \"`:url:`\"\xFE";
 z+="\xFE";
 z+="        if (window.saveAtSession) saveAtSession()\xFE";
 z+="    \xFE";
 z+="        if (window.cordova) {\xFE";
 z+="            if (cordova.InAppBrowser) {\xFE";
 z+="                winObj = cordova.InAppBrowser.open(url, \"_blank\", \"location=yes\");\xFE";
 z+="            } else {\xFE";
 z+="                winObj = navigator.app.loadUrl(url, {openExternal:true});\xFE";
 z+="            }\xFE";
 z+="        } else {\xFE";
 z+="            winObj = window.open(url, \"_system\", \"location=yes\");\xFE";
 z+="        }\xFE";
 z+="        \xFE";
 z+="        if(!winObj || typeof winObj.closed=='undefined') winObj = false;\xFE";
 z+="\xFE";
 z+="        if (winObj)\xFE";
 z+="           checkClosed();\xFE";
 z+="        else\xFE";
 z+="            popoutWindow(\"`:oAuthAuthority:` oAuth Login\", \"`:url:`\", \"80%\", \"80%\", function () { doJsbSubmit(false); })\xFE";
 z+="    `)\xFE";
 z+="    \xFE";
 z+="\xFE";
 z+="    userVar(\"oauth_results\", \"\")\xFE";
 z+="    Dim b As String = @response.buffer()\xFE";
 z+="    Print browserScript:\xFE";
 z+="    \xFE";
 z+="    // We will return here eventually with a POST\xFE";
 z+="    @Server.Pause\xFE";
 z+="    @response.buffer(b)\xFE";
 z+="    \xFE";
 z+="    Dim access_token As String = formVar(\"accesstoken\")\xFE";
 z+="    Dim oauth_results As JSON = Nothing\xFE";
 z+="    if !access_token then\xFE";
 z+="        // ======================== Run the javascript to make the call     // ======================== \xFE";
 z+="        // Do we need to fetch access token from server?\xFE";
 z+="        if field(rtnToUrl, \"_\", 1) = \"atoken\" then\xFE";
 z+="            *Call the server, ask for our access token\xFE";
 z+="            url = _settings.jsbauthority:`/oauth_myToken?atoken=`:rtnToURL\xFE";
 z+="            Dim sOauth_results As String = @Get(Url)\xFE";
 z+="            \xFE";
 z+="            if !sOauth_results then \xFE";
 z+="                @Errors = \"no result from server routine oauth_myToken\"\xFE";
 z+="                return null\xFE";
 z+="            end if\xFE";
 z+="    \xFE";
 z+="            oauth_results = JSON(sOauth_results)\xFE";
 z+="            if oauth_results.access_errors Then @Errors = oauth_results.access_errors; return null\xFE";
 z+="        else\xFE";
 z+="            if system(1) = \"js\" then window.getAtSession()\xFE";
 z+="            for i = 1 to 12\xFE";
 z+="                oauth_results = userVar(\"oauth_results\")\xFE";
 z+="                if oauth_results then break\xFE";
 z+="                @Server.Flush\xFE";
 z+="            next\xFE";
 z+="        \xFE";
 z+="            if !oauth_results Then\xFE";
 z+="                @Errors = \"OAuth login failed for '\":oAuthAuthority:\"'\"\xFE";
 z+="                return null\xFE";
 z+="            end if\xFE";
 z+="            \xFE";
 z+="            if oauth_results.access_errors then\xFE";
 z+="                @Errors = oauth_results.access_errors\xFE";
 z+="                return null\xFE";
 z+="            end if\xFE";
 z+="        end if\xFE";
 z+="        \xFE";
 z+="        access_token = oauth_results.access_token\xFE";
 z+="        userVar(\"myOAuthCode\", oauth_results.Code)\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    // SUCCESSFUL - Save our current login\xFE";
 z+="    userVar(\"myAccessToken\", access_token)\xFE";
 z+="    userVar(\"myOAuthName\", oAuthAuthority)\xFE";
 z+="    \xFE";
 z+="    Dim Userinfo As JSON = @jsb_odb.oAuthWho()\xFE";
 z+="    Dim userName As String = \"\"\xFE";
 z+="    if userInfo then UserName = Userinfo.username\xFE";
 z+="    \xFE";
 z+="    If !UserName = Userinfo.username Then\xFE";
 z+="        @Errors = \"oAuth Login successful, but unable to retrieve a username\"\xFE";
 z+="        return null\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    Dim oAuthDomain As String = DropIfRight(oAuthAuthority, \"_config\")\xFE";
 z+="    If LCase(Left(UserName, Len(oAuthDomain) + 1)) <> LCase(oAuthDomain):\"-\" Then UserName = oAuthDomain:\"-\":UserName\xFE";
 z+="\xFE";
 z+="    @SignIn(UserName, True)\xFE";
 z+="\xFE";
 z+="    // Update profile?\xFE";
 z+="    Dim F_users As fileHandle = fHandle(\"JSB_USERS\")\xFE";
 z+="    If F_users Then\xFE";
 z+="        dim Profile As JSON\xFE";
 z+="        I_ReadJSon Profile From F_users, UserName Else\xFE";
 z+="            Profile = {}\xFE";
 z+="            Profile.username = UserName\xFE";
 z+="            Profile.password = \"X\"\xFE";
 z+="            Profile.isinrole = []\xFE";
 z+="            Profile.disabled = False\xFE";
 z+="            \xFE";
 z+="            If Userinfo.email Then\xFE";
 z+="                Profile.email = Userinfo.email\xFE";
 z+="                Dim EMailDomain As String = LCase(Dropleft(Userinfo.email, \"@\"))\xFE";
 z+="                If Left(EMailDomain, Len(oAuthDomain) + 1) = oAuthDomain:\".\" Then Profile.isinrole = [\"employee\"]\xFE";
 z+="            End If\xFE";
 z+="            \xFE";
 z+="            I_WriteJson Profile On F_users, UserName Else Null\xFE";
 z+="        End If\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    return access_token\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="// needed for the phonegap version\xFE";
 z+="restful function oauth_myToken(ByVal atoken As String) As JSON\xFE";
 z+="    System(56) ;* Run to compleation\xFE";
 z+="    if field(atoken, \"_\", 1) <> \"atoken\" then return { access_errors: \"bad request\" }\xFE";
 z+="    \xFE";
 z+="    i_readjson oauth_results from @fhandle('tmp'), atoken then \xFE";
 z+="        delete @fhandle('tmp'), atoken \xFE";
 z+="        return oauth_results\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    return { access_errors: \"unknown token\" }\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="// This server only routine is needed since oauth requires a known url for the redirect.  \xFE";
 z+="//   After the user logs in, he is rediected here with a code.  We must then\xFE";
 z+="//   contact the oauth server to convert the code into an the access token.\xFE";
 z+="//   This insures that the code is valid and it's not a spoof.\xFE";
 z+="//\xFE";
 z+="//   We are also passed the \"state\" parameter, which can be anything we want that\xFE";
 z+="//   is setup by us in the original login request.  Here we store a return URL\xFE";
 z+="//   for the user.\xFE";
 z+="\xFE";
 z+="program oauth_silent_redirect_uri\xFE";
 z+="    System(56) ;* Run to compleation\xFE";
 z+="    Dim state As String = @urlParam('state')\xFE";
 z+="    Dim oAuthName_Config As String = Field(state, '*', 1) // Our jsb_config id passed using state\xFE";
 z+="    Dim userno As String = Field(state, '*', 2)\xFE";
 z+="    Dim rtnToUrl As String = Field(state, '*', 3)\xFE";
 z+="    Dim closeUrl As String = Field(state, '*', 4)\xFE";
 z+="    Dim Code As String = @urlParam('code')\xFE";
 z+="    Dim Scope As String = @urlParam('scope')\xFE";
 z+="    Dim session_state As String = @urlParam('session_state')\xFE";
 z+="    Dim access_errors As String = @urlParam('error_description'):@UrlParam('error')\xFE";
 z+="    Dim storeOnServer As Boolean = field(rtnToUrl, \"_\", 1) = \"atoken\"\xFE";
 z+="    Dim UrlReferrer As String = \"\"\xFE";
 z+="    \xFE";
 z+="    Dim _settings As Json\xFE";
 z+="    i_readjson _settings from @fHandle('jsb_config'), oAuthName_Config else _settings = {}\xFE";
 z+="    \xFE";
 z+="    Dim jsbauthority As String = Field(@url, \"/oauth_silent_redirect_uri\", 1)\xFE";
 z+="    Dim silent_redirect_uri As String = jsbauthority:\"/oauth_silent_redirect_uri\" \xFE";
 z+="    if instr(@url, \":443\") Then silent_redirect_uri = Replace(silent_redirect_uri, \"/\":Field(silent_redirect_uri, \"/\", 3):\"/\", \"/\":Field(silent_redirect_uri, \"/\", 3):\":443/\")\xFE";
 z+="\xFE";
 z+="    // Insure we have the right UrlReferrer\xFE";
 z+="    if _settings.UrlReferrer then\xFE";
 z+="        UrlReferrer = Left(@request.UrlReferrer, len(_settings.UrlReferrer))\xFE";
 z+="        if UrlReferrer <> _settings.UrlReferrer then \xFE";
 z+="            access_errors = \"UrlReferrer isn't correct. Expected: \":_settings.UrlReferrer:\" and received \":UrlReferrer\xFE";
 z+="        end if\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    // failed?\xFE";
 z+="    if !Code || access_errors then\xFE";
 z+="        Dim oauth_results As JSON = {access_errors: access_errors}\xFE";
 z+="        userVar(\"oauth_results\", oauth_results, userno)\xFE";
 z+="            \xFE";
 z+="        if storeOnServer then\xFE";
 z+="           i_writejson oauth_results on fhandle('tmp'), rtnToUrl Else Null\xFE";
 z+="           @Server.End\xFE";
 z+="        else\xFE";
 z+="            if InStr(rtnToUrl, \"?\") then rtnToUrl := \"&\" else rtnToUrl := \"?\"\xFE";
 z+="            @response.redirect(rtnToUrl:`errors=`:@UrlEncode(access_errors))\xFE";
 z+="            @server.end\xFE";
 z+="        end if\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    // convert code to an access token ( http://docs.identityserver.io/en/latest/reference/client.html )\xFE";
 z+="    \xFE";
 z+="    // Must contain code, client_id, client_secret, redirect_uri and grant_type\xFE";
 z+="    if _settings.token Then\xFE";
 z+="        Dim Url As String = _settings.token // \"https://idfg.idaho.gov/ifwis/oauth2/connect/token\"\xFE";
 z+="        \xFE";
 z+="        Dim _body As String = `code=`:code\xFE";
 z+="        _body := `&client_id=`:UrlEncode(_settings.client_id)\xFE";
 z+="        if _settings.client_secret then _body := `&client_secret=`:UrlEncode(_settings.client_secret)\xFE";
 z+="        if _settings.grant_type then _body := `&grant_type=`:UrlEncode(_settings.grant_type)\xFE";
 z+="        _body := `&redirect_uri=`:UrlEncode(silent_redirect_uri) // This is only for verification\xFE";
 z+="    \xFE";
 z+="        Dim sdoc As String = @jsb_bf.Get(Url, \"POST\", \"\", _body) \xFE";
 z+="        Dim access_token As String\xFE";
 z+="        Dim access_errors As String\xFE";
 z+="        Dim token_type As String\xFE";
 z+="        \xFE";
 z+="        if IsNothing(sdoc) then \xFE";
 z+="            access_token = \"\"\xFE";
 z+="            access_errors = @errors\xFE";
 z+="            token_type = \"errors\"\xFE";
 z+="            j = {}\xFE";
 z+="            \xFE";
 z+="            // for testing\xFE";
 z+="            i_writejson {body: _body, storeOnServer: storeOnServer, access_token: access_token, access_errors: access_errors, url: @Url } on fhandle('tmp'), oAuthName_Config:\"_2\" Else Null\xFE";
 z+="        Else\xFE";
 z+="            j = JSon(sdoc)\xFE";
 z+="            access_token = j.access_token\xFE";
 z+="            access_errors = \"\"\xFE";
 z+="            token_type = j.token_type\xFE";
 z+="        end if\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    // Get us back to the correct version of code (aspx, phonegap, or js)\xFE";
 z+="    if storeOnServer then\xFE";
 z+="        * With phonegap, we are still in an external browser, so we need to record to the server, and fetch with a rest call\xFE";
 z+="        \xFE";
 z+="        * \"https://jsbwinforms.azurewebsites.net/sysprog/\"\xFE";
 z+="        * \"https://idfg.idaho.gov/ifwis/jsb/sysprog/oauth_silent_redirect_uri?co\xFE";
 z+="        \xFE";
 z+="        Dim closeURL As String = @HtmlRoot:`close_html?access_token=`:@urlencode(access_token):`&token_type=`:token_type:`&errors=`:@UrlEncode(access_errors):`&oAuthName_Config=`:@UrlEncode(oAuthName_Config):`&userno=`:@UrlEncode(userno)\xFE";
 z+="        \xFE";
 z+="\xFE";
 z+="        i_writejson {\xFE";
 z+="            access_token: access_token, \xFE";
 z+="            access_errors: access_errors, \xFE";
 z+="            closeURL: closeURL,\xFE";
 z+="            UrlReferrer: @request.UrlReferrer\xFE";
 z+="        } on fhandle('tmp'), rtnToUrl Else Null\xFE";
 z+="        \xFE";
 z+="        i_writejson {\xFE";
 z+="            access_token: access_token, \xFE";
 z+="            access_errors: access_errors, \xFE";
 z+="            closeURL: closeURL,\xFE";
 z+="            UrlReferrer: @request.UrlReferrer\xFE";
 z+="        } on fhandle('tmp'), oAuthName_Config:\"_3\" Else Null\xFE";
 z+="        \xFE";
 z+="        \xFE";
 z+="        Dim useScript As Boolean = Left(@request.UrlReferrer, Len(@HtmlRoot)) <> @HtmlRoot \xFE";
 z+="\xFE";
 z+="        if useScript Then\xFE";
 z+="          print @script(`window.location.href = \"`:closeURL:`\";`): \xFE";
 z+="          Stop\xFE";
 z+="        else\xFE";
 z+="            @response.redirect(closeURL)\xFE";
 z+="            @Server.End\xFE";
 z+="        end if\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    // should get us to the oauth_rtnToUrl program below\xFE";
 z+="    if InStr(rtnToUrl, \"?\") then rtnToUrl := \"&\" else rtnToUrl := \"?\"\xFE";
 z+="    @response.redirect(rtnToUrl:`access_token=`:access_token:`&token_type=`:token_type:`&errors=`:@UrlEncode(access_errors):`&oAuthName_Config=`:@UrlEncode(oAuthName_Config):`&userno=`:@UrlEncode(userno):`&returnurl=`:@UrlEncode(rtnToUrl))\xFE";
 z+="end program\xFE";
 z+="\xFE";
 z+="// Local client code redirect (does not get called for phonegap version)\xFE";
 z+="program oauth_redirect_uri\xFE";
 z+="    System(56) ;* Run to compleation\xFE";
 z+="    // should run in the same session state as the first caller\xFE";
 z+="    Dim userno As String = @urlParam('userno')\xFE";
 z+="    Dim oAuthName_Config As String = @urlParam('oAuthName_Config')\xFE";
 z+="    Dim access_token As String = @urlParam('access_token')\xFE";
 z+="    Dim access_errors As String = @urlParam('errors')\xFE";
 z+="    Dim token_type As String = @urlParam('token_type')\xFE";
 z+="    Dim rtnUrl As String = @urlParam('returnurl')\xFE";
 z+="    \xFE";
 z+="    Dim oauth_results As Json = { access_token: access_token, access_errors: access_errors, token_type: token_type, userno: userno, close: @HtmlRoot }\xFE";
 z+="    userVar(\"oauth_results\", oauth_results, userno)\xFE";
 z+="    \xFE";
 z+="    @response.redirect(@HtmlRoot:`close_html?access_token=`:access_token:`&token_type=`:token_type:`&errors=`:@UrlEncode(access_errors):`&oAuthName_Config=`:@UrlEncode(oAuthName_Config):`&userno=`:@UrlEncode(userno))\xFE";
 z+="end program\xFE";
 z+="\xFE";
 z+="Program oAuthWho\xFE";
 z+="    Dim userinfo As JSON = oAuthWho()\xFE";
 z+="    if !userInfo then print @errors\xFE";
 z+="    print userInfo\xFE";
 z+="end program\xFE";
 z+="\xFE";
 z+="Program oWho\xFE";
 z+="    Dim userinfo As JSON = oAuthWho()\xFE";
 z+="    if !userInfo then print @errors\xFE";
 z+="    print userInfo\xFE";
 z+="end program\xFE";
 z+="\xFE";
 z+="function oAuthWho()\xFE";
 z+="    Dim access_token As String = userVar(\"myAccessToken\")\xFE";
 z+="    Dim oAuthName_Config As String = userVar(\"myOAuthName\")\xFE";
 z+="    \xFE";
 z+="    if (!access_token) then @errors = \"Please first do an oAuthLogin\"; return null\xFE";
 z+="    \xFE";
 z+="    // Get user info\xFE";
 z+="    Dim _settings As JSON\xFE";
 z+="    i_readjson _settings from @fHandle('jsb_config'), oAuthName_Config else @errors =  oAuthName_Config:\" app _settings are not setup in jsb_config.\"; return null\xFE";
 z+="    if _settings.ItemContent Then Stop \"This oAuth profile isn't json\"\xFE";
 z+="    \xFE";
 z+="    Dim myDomain As String = @jsbrootact\xFE";
 z+="    if Right(myDomain, 1) = \"/\" Then myDomain = Left(myDomain, Len(myDomain) - 1)\xFE";
 z+="    \xFE";
 z+="    Dim localDomain As Boolean = lcase(_settings.jsbauthority) = lcase(myDomain)\xFE";
 z+="    Dim userinfo As JSON \xFE";
 z+="    \xFE";
 z+="    if localDomain then \xFE";
 z+="        userinfo = oauth_profile(oAuthName_Config, access_token)\xFE";
 z+="    else\xFE";
 z+="        Dim url As String = _settings.jsbauthority:\"/oauth_profile?oAuthName_Config=\":@urlEncode(oAuthName_Config):\"&access_token=\":@urlEncode(access_token)\xFE";
 z+="        userinfo = CJSon(get(url, \"GET\"))\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    if !userinfo then return null\xFE";
 z+="    if userinfo.error then @Errors = userinfo.error; return null\xFE";
 z+="    \xFE";
 z+="    return userinfo\xFE";
 z+="end program\xFE";
 z+="\xFE";
 z+="Program oQuit\xFE";
 z+="* $options aspxc-\xFE";
 z+="    if !oAuth_Quit() Then Print @Errors \xFE";
 z+="end Program\xFE";
 z+="\xFE";
 z+="Program oAuthQuit\xFE";
 z+="    if !oAuth_Quit() Then Print @Errors \xFE";
 z+="end Program\xFE";
 z+="\xFE";
 z+="Program oAuthOff\xFE";
 z+="    if !oAuth_Quit() Then Print @Errors\xFE";
 z+="end Program\xFE";
 z+="\xFE";
 z+="Program oAuthLogoff\xFE";
 z+="    if !oAuth_Quit() Then Print @Errors\xFE";
 z+="end Program\xFE";
 z+="\xFE";
 z+="Program oOff\xFE";
 z+="    if !oAuth_Quit() Then Print @Errors\xFE";
 z+="end Program\xFE";
 z+="\xFE";
 z+="Program oLogout\xFE";
 z+="    if !oAuth_Quit() Then Print @Errors\xFE";
 z+="end Program\xFE";
 z+="\xFE";
 z+="Program oLogoff\xFE";
 z+="    if !oAuth_Quit() Then Print @Errors\xFE";
 z+="end Program\xFE";
 z+="\xFE";
 z+="// http://docs.identityserver.io/en/latest/endpoints/revocation.html\xFE";
 z+="\xFE";
 z+="function oAuth_Quit()\xFE";
 z+="    Dim access_token As String = userVar(\"myAccessToken\")\xFE";
 z+="    Dim oAuthName_Config As String = userVar(\"myOAuthName\")\xFE";
 z+="    \xFE";
 z+="    if (!access_token || !oAuthName_Config) then @Errors = \"Not logged in\"; Return false\xFE";
 z+="    \xFE";
 z+="    // Get user info\xFE";
 z+="    Dim _settings As JSON\xFE";
 z+="    i_readjson _settings from @fHandle('jsb_config'), oAuthName_Config else @errors =  oAuthName_Config:\" app _settings are not setup in jsb_config.\"; return false\xFE";
 z+="    \xFE";
 z+="    Dim Url As String = _settings.revoke\xFE";
 z+="    if !Url Then Url = Replace(_settings.authorize, \"/authorize\", \"/revocation\")\xFE";
 z+="    \xFE";
 z+="    Dim header As Array = [\"Content-Type: application/x-www-form-urlencoded\", \"Authorization: Bearer \":access_token]\xFE";
 z+="    Dim Method As String\xFE";
 z+="    if instr(left(url, 10), \",\") then  \xFE";
 z+="        method = field(url, \",\", 1); \xFE";
 z+="        url = dropleft(url, \",\")\xFE";
 z+="    else\xFE";
 z+="        method = \"POST\"\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    Dim logoutInfo As JSON = CJSon(get(Url, method, header, \"token_type_hint=access_token&token=\":access_token))\xFE";
 z+="    \xFE";
 z+="    userVar(\"myAccessToken\", \"\")\xFE";
 z+="    userVar(\"myOAuthName\", \"\")\xFE";
 z+="    \xFE";
 z+="    return true\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="restful function oauth_profile(ByVal oAuthName_Config As String, ByVal access_token As String) As JSON\xFE";
 z+="* $options aspxc-\xFE";
 z+="    return oauth_profile(oAuthName_Config, access_token)\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="function oauth_profile(ByVal oAuthName_Config As String, ByVal access_token As String) As JSON\xFE";
 z+="    // Get user info\xFE";
 z+="    if right(lcase(oAuthName_Config), 7) <> \"_config\" then oAuthName_Config := \"_config\"\xFE";
 z+="    \xFE";
 z+="    Dim _settings As JSON\xFE";
 z+="    i_readjson _settings from @fHandle('jsb_config'), oAuthName_Config else return { \"error\": oAuthName_Config:\" app _settings are not setup in jsb_config.\" }\xFE";
 z+="    if _settings.ItemContent Then return { \"error\": \"This oAuth profile isn't json\" }\xFE";
 z+="    \xFE";
 z+="    Dim url As String = _settings.userinfo\xFE";
 z+="    if !url Then return { \"error\": oAuthName_Config:\" app _settings do not have a userinfo url\" }\xFE";
 z+="    \xFE";
 z+="    Dim header As Array = [\"Content-Type: application/json\", \"Authorization: Bearer \":access_token]\xFE";
 z+="    Dim Method As String\xFE";
 z+="    if instr(left(url, 10), \",\") then  \xFE";
 z+="        method = field(url, \",\", 1); \xFE";
 z+="        url = dropleft(url, \",\")\xFE";
 z+="    else\xFE";
 z+="        method = \"POST\"\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    Dim userinfo As JSON = CJSon(get(Url, method, header, \"null\"))\xFE";
 z+="    if !userInfo then return { \"error\": url:\" \":@errors }\xFE";
 z+="    \xFE";
 z+="    Dim rec As JSON = {}\xFE";
 z+="    if userInfo.email then rec.email = userInfo.email\xFE";
 z+="    \xFE";
 z+="    if userInfo.preferred_username then \xFE";
 z+="         rec.username = userInfo.preferred_username\xFE";
 z+="    else if userInfo.username then\xFE";
 z+="        rec.username = userInfo.username\xFE";
 z+="    elseif userInfo.login then\xFE";
 z+="        rec.username = userInfo.login\xFE";
 z+="    elseif userInfo.user then\xFE";
 z+="        rec.username = userInfo.user\xFE";
 z+="    elseif rec.email then\xFE";
 z+="        rec.username = field(rec.email, \"@\", 1)\xFE";
 z+="    else\xFE";
 z+="        return userInfo\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    return rec\xFE";
 z+="end function\xFE";
 z+=""
window.cached_jsb_odb["oauth_subs"]=z;
var z="\xFE";
 z+="    // httpAddress = \"http://jsonbasic-0004.appspot.com/\"\xFE";
 z+="    // LoginInfo = @jsb_odb.rpc_Login(httpAddress, \"admin\", \"xxxx\", \"\")\xFE";
 z+="    // If !LoginInfo then stop @errors\xFE";
 z+="    // open \"@rpc.filename\" to x else stop @errors\xFE";
 z+="\xFE";
 z+="sub rpc_db\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="//  Note - Call @ routines must have all ByRef parameters\xFE";
 z+="\xFE";
 z+="function rpc_showStatus(ByVal S)\xFE";
 z+="    * $options js\xFE";
 z+="    * $options external function showStatus(s)\xFE";
 z+="    showStatus(s)\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="function rpc_showStatus(s)\xFE";
 z+="    * $options aspx, gae\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="Sub rpc_dropOldCache()\xFE";
 z+="    if !@Session.rpc_cached_items Then @Session.rpc_cached_items = {}\xFE";
 z+="    if !@Session.rpc_cached_timer Then @Session.rpc_cached_timer = {}\xFE";
 z+="    if !@Session.rpc_cached_logins Then @Session.rpc_cached_logins = {}\xFE";
 z+="    if !@Session.rpc_cached_opens Then @Session.rpc_cached_opens = {}\xFE";
 z+="    \xFE";
 z+="    For Each CKey In @Session.rpc_cached_opens\xFE";
 z+="        if CKey Then\xFE";
 z+="            fileMeta = @Session.rpc_cached_opens[Ckey]\xFE";
 z+="            // invalid if more than a 30 seconds has passed - or clock has rolled over to a new day\xFE";
 z+="            If Abs(Timer() - fileMeta.Timer) > 30000 Then\xFE";
 z+="                Remove @Session.rpc_cached_opens, CKey\xFE";
 z+="            End If\xFE";
 z+="        End If\xFE";
 z+="    Next\xFE";
 z+="    \xFE";
 z+="    For Each CKey In @Session.rpc_cached_items\xFE";
 z+="        if CKey Then\xFE";
 z+="            // invalid if more than a second has passed - or clock has rolled over to a new day\xFE";
 z+="            If Abs(Timer() - @Session.rpc_cached_timer[Ckey]) > 1000 Then\xFE";
 z+="                Remove @Session.rpc_cached_items, CKey\xFE";
 z+="                Remove @Session.rpc_cached_timer, CKey\xFE";
 z+="            End If\xFE";
 z+="        End If\xFE";
 z+="    Next\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="function rpc_Login(ByVal httpAddress As String, ByVal username As String, ByVal password As String, ByVal initialdb As String)\xFE";
 z+="    Dim Key As String = LCase(Replace(httpAddress, VM(), \"**\"):\"&&\":username:\"&&\":initialdb)\xFE";
 z+="    Call rpc_dropOldCache()\xFE";
 z+="    \xFE";
 z+="    Dim loginKey As String = @Session.rpc_cached_logins[key] \xFE";
 z+="    if loginKey then \xFE";
 z+="        @Session.rpc_last_address = loginKey\xFE";
 z+="        return loginKey\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    rpc_showStatus(\"RPC Login: \": username)\xFE";
 z+="    Dim Success As Boolean = @rpc(httpAddress, @Session.server_rpcsid, \"serverlogin\", username, password, initialdb, Errors)\xFE";
 z+="    if !Success Then \xFE";
 z+="        rpc_showStatus(`XLogin Failed: `:rpc_Error(Errors))\xFE";
 z+="        Return \"\"\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    Dim Sid As String = @Session.lastGet_rpcsid_ \xFE";
 z+="    If !Sid Then\xFE";
 z+="        if InStr(Errors, \"-\") Then sid = field(Errors, \"-\", 1)\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    if !sid then sid = \"rpc:none\"\xFE";
 z+="    loginKey = httpAddress:VM():sid\xFE";
 z+="    @Session.rpc_cached_logins[key] = loginKey\xFE";
 z+="    @Session.rpc_last_address = loginKey\xFE";
 z+="    return loginKey\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="function rpc_Error(ByVal Errors As String) As String\xFE";
 z+="    if Errors Then @Errors = Errors\xFE";
 z+="    return @Errors\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="Sub rpc_Open(ByVal LoginInfo As String, ByVal DictData As String, ByVal FName As String, ByRef fHandle As String, ByRef Success As Boolean)\xFE";
 z+="    if DictData = \"\" Then DictData = \"data\"\xFE";
 z+="    Dim Key As String = LCase(Replace(LoginInfo, VM(), \"&&\"):\"&&\":DictData:\"&&\":FName)\xFE";
 z+="\xFE";
 z+="    Call rpc_dropOldCache()\xFE";
 z+="\xFE";
 z+="    if @Session.rpc_cached_opens[key] then \xFE";
 z+="        fileMeta = @Session.rpc_cached_opens[key]\xFE";
 z+="        Success = fileMeta.Success\xFE";
 z+="        rfHandle = fileMeta.rfHandle\xFE";
 z+="        if (!Success) Then Errors = fileMeta.Errors\xFE";
 z+="    Else\xFE";
 z+="        Success = @rpc(LoginInfo<1,1>, LoginInfo<1,2>, \"serveropen\", DictData, FName, rfHandle, Errors)\xFE";
 z+="        rpc_showStatus(\"RPC Open\":IIF(Success, \": \", \"Failed: \"):FName)\xFE";
 z+="        @Session.rpc_cached_opens[key] = { Success: Success, rfHandle: rfHandle, Errors: Errors, Timer: Timer() }\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    if Success Then fHandle = \"@rpc.\":LoginInfo:AM():rfHandle Else fHandle = rpc_Error(Errors)\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub rpc_CreateFile(ByVal LoginInfo As String, ByVal FName As String, ByRef fHandle As String, ByRef Success As Boolean)\xFE";
 z+="    Success = @rpc(LoginInfo<1,1>, LoginInfo<1,2>, \"servercreatefile\", FName, fHandle, Errors)\xFE";
 z+="    if Success Then fHandle = \"@rpc.\":LoginInfo:AM():fHandle Else fHandle = Errors \xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub rpc_primarykeyname(ByVal fHandle As String, ByRef Result As String, ByRef Success As Boolean)\xFE";
 z+="    Success = @rpc(fHandle<1, 1>, fHandle<1,2>, \"serverprimarykeyname\", fHandle<2>, Result, Errors)\xFE";
 z+="    if !Success Then @Errors = Errors \xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub rpc_ReadJSon(ByRef Item As JSON, ByVal fHandle As String, ByVal IName As String, ByRef Success As Boolean)\xFE";
 z+="    Dim sItem As String\xFE";
 z+="    Call rpc_ReadX(sItem, fHandle, IName, Success, \"JSon\")\xFE";
 z+="    If (Left(sItem, 1) = \"{\" Or Left(sItem, 1) = \"[\") And Success Then Item = JSon(sItem)\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub rpc_ReadJSonU(ByRef Item As JSON, ByVal fHandle As String, ByVal IName As String, ByRef Success As Boolean)\xFE";
 z+="    Dim sItem As String\xFE";
 z+="    Call rpc_ReadX(sItem, fHandle, IName, Success, \"JSonU\")\xFE";
 z+="    If (Left(sItem, 1) = \"{\" Or Left(sItem, 1) = \"[\") And Success Then Item = JSon(sItem)\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub rpc_ReadXML(Item, ByVal fHandle As String, ByVal IName As String, ByRef Success As Boolean)\xFE";
 z+="    * $options aspxc-\xFE";
 z+="    Call rpc_ReadX(Item, fHandle, IName, Success, \"XML\")\xFE";
 z+="    If Left(Item, 1) = \"<\" And Success Then Item = XML(item)\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub rpc_ReadXMLU(Item, ByVal fHandle As String, ByVal IName As String, ByRef Success As Boolean)\xFE";
 z+="    * $options aspxc-\xFE";
 z+="    Call rpc_ReadX(Item, fHandle, IName, Success, \"XMLU\")\xFE";
 z+="    If Left(Item, 1) = \"<\" And Success Then Item = XML(item)\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub rpc_Read(ByRef Item As String, ByVal fHandle As String, ByVal IName As String, ByRef Success As Boolean)\xFE";
 z+="    Call rpc_ReadX(Item, fHandle, IName, Success, \"\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub rpc_ReadU(ByRef Item As String, ByVal fHandle As String, ByVal IName As String, ByRef Success As Boolean)\xFE";
 z+="    Call rpc_ReadX(Item, fHandle, IName, Success, \"U\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub rpc_ReadX(ByRef Item As String, ByVal fHandle As String, ByVal IName As String, ByRef Success As Boolean, ByVal RType)\xFE";
 z+="    Item = \"\"\xFE";
 z+="\xFE";
 z+="    Call rpc_dropOldCache()\xFE";
 z+="    \xFE";
 z+="    Dim Key As String = LCase(Replace(fHandle, VM(), \"**\"):\"&&\":IName)\xFE";
 z+="    \xFE";
 z+="    if @Session.rpc_cached_items[key] And Right(RType, 1) <> \"U\" then \xFE";
 z+="        Success = True\xFE";
 z+="        Item = @Session.rpc_cached_items[key]\xFE";
 z+="        @Session.rpc_cached_timer[key] = timer()\xFE";
 z+="        Return\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    rpc_showStatus(\"RPC Read\":RType:\":\":IName)\xFE";
 z+="    Success = @rpc(fHandle<1, 1>, fHandle<1,2>, \"serverread\":LCase(RType), Item, fHandle<2>, IName, Errors)\xFE";
 z+="    if !Success Then @Errors = Errors\xFE";
 z+="    If Errors Then \xFE";
 z+="        rpc_showStatus(\"RPC Read Failed:\":rpc_Error(Errors))\xFE";
 z+="        fHandle = Errors\xFE";
 z+="        Return\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    @Session.rpc_cached_items[key] = Item\xFE";
 z+="    @Session.rpc_cached_timer[key] = timer()\xFE";
 z+="\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub rpc_ReadV(ByRef Item As String, ByVal fHandle As String, ByVal IName As String, ByVal AtrNo As Integer, ByRef Success As Boolean)\xFE";
 z+="    * $options aspxc-\xFE";
 z+="    \xFE";
 z+="    Item = \"\"\xFE";
 z+="    Call rpc_dropOldCache()\xFE";
 z+="    Dim Key As String = LCase(Replace(fHandle, VM(), \"**\"):\"&&\":IName)\xFE";
 z+="    \xFE";
 z+="    if @Session.rpc_cached_items[key] then \xFE";
 z+="        Success = True\xFE";
 z+="        Item = @Session.rpc_cached_items[key]\xFE";
 z+="        Item = Item<AtrNo>\xFE";
 z+="        @Session.rpc_cached_timer[key] = timer()\xFE";
 z+="        Return\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    Success = @rpc(fHandle<1, 1>, fHandle<1,2>, \"serverreadv\", Item, fHandle<2>, IName, AtrNo, Errors)\xFE";
 z+="    If Errors Then rpc_Error(Errors) else rpc_showStatus(\"RPC ReadV:\":IName)\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub rpc_ReadVU(ByRef Item As String, ByVal fHandle As String, ByVal IName As String, ByVal AtrNo As Integer, ByRef Success As Boolean)\xFE";
 z+="    * $options aspxc-\xFE";
 z+="    \xFE";
 z+="    Item = \"\"\xFE";
 z+="    Dim Key As String = LCase(Replace(fHandle, VM(), \"**\"):\"&&\":IName)\xFE";
 z+="    if @Session.rpc_cached_items Then \xFE";
 z+="        Remove @Session.rpc_cached_items, Key\xFE";
 z+="        Remove @Session.rpc_cached_timer, Key\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    Dim Errors As String\xFE";
 z+="    Success = @rpc(fHandle<1, 1>, fHandle<1,2>, \"serverreadvu\", Item, fHandle<2>, IName, AtrNo, Errors)\xFE";
 z+="    If Errors Then rpc_Error(Errors); else rpc_showStatus(\"RPC ReadVU:\":IName)\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub rpc_ListFiles(ByVal httpAddress As String, ByRef Result, ByRef Errors As String)\xFE";
 z+="    Result = \"\"\xFE";
 z+="    Call rpc_dropOldCache() \xFE";
 z+="    Success = @rpc(httpAddress<1,1>, httpAddress<1,2>, \"serverlistfiles\", Result, Errors)\xFE";
 z+="    If Errors Then rpc_Error(Errors) else rpc_showStatus(\"RPC ListFiles:\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub rpc_DeleteFile(ByVal fHandle As String, ByRef Success As Boolean)\xFE";
 z+="    Dim PKey As String = LCase(Replace(fHandle, VM(), \"**\"):\"&&\")\xFE";
 z+="    For Each CKey In @Session.rpc_cached_items\xFE";
 z+="        If CKey Then\xFE";
 z+="            If Left(CKey, Len(Pkey)) = PKey Then \xFE";
 z+="                Remove @Session.rpc_cached_items, CKey\xFE";
 z+="                Remove @Session.rpc_cached_timer, CKey\xFE";
 z+="            end if\xFE";
 z+="        End If\xFE";
 z+="    Next\xFE";
 z+="\xFE";
 z+="    Success = @rpc(fHandle<1, 1>, fHandle<1,2>, \"serverdeletefile\", fHandle<2>, Errors)\xFE";
 z+="    If Errors Then rpc_Error(Errors) else rpc_showStatus(\"RPC DeleteFile:\":fHandle<2>)\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub rpc_ClearFile(ByVal fHandle As String, ByRef Success As Boolean)\xFE";
 z+="    Dim PKey As String = LCase(Replace(fHandle, VM(), \"**\"):\"&&\")\xFE";
 z+="    Call rpc_dropOldCache()\xFE";
 z+="    \xFE";
 z+="    For Each CKey In @Session.rpc_cached_items\xFE";
 z+="        If CKey Then\xFE";
 z+="            If Left(CKey, Len(Pkey)) = PKey Then \xFE";
 z+="                Remove @Session.rpc_cached_items, CKey\xFE";
 z+="                Remove @Session.rpc_cached_timer, CKey\xFE";
 z+="            end if\xFE";
 z+="        End If\xFE";
 z+="    Next\xFE";
 z+="\xFE";
 z+="    Success = @rpc(fHandle<1, 1>, fHandle<1,2>, \"serverclearfile\", fHandle<2>, Errors)\xFE";
 z+="    If Errors Then rpc_Error(Errors) else rpc_showStatus(\"RPC ClearFile:\":fHandle<2>)\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub rpc_DeleteItem(ByVal fHandle As String, ByVal IName As String, ByRef Success As Boolean)\xFE";
 z+="    Call rpc_dropOldCache()\xFE";
 z+="    \xFE";
 z+="    Dim Key As String = LCase(Replace(fHandle, VM(), \"**\"):\"&&\":IName)\xFE";
 z+="    if @Session.rpc_cached_items Then \xFE";
 z+="        Remove @Session.rpc_cached_items, Key\xFE";
 z+="        Remove @Session.rpc_cached_timer, Key\xFE";
 z+="    end if\xFE";
 z+="    Success = @rpc(fHandle<1, 1>, fHandle<1,2>, \"serverdeleteitem\", fHandle<2>, IName, Errors)\xFE";
 z+="    If Errors Then rpc_Error(Errors) else rpc_showStatus(\"RPC DeleteItem:\":IName)\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub rpc_Select(ByVal Cols As String, ByVal fHandle As String, ByVal WhereClause As String, ByRef Success As Boolean)\xFE";
 z+="    Success = @rpc(fHandle<1, 1>, fHandle<1,2>, \"serverselect\", Cols, fHandle<2>, WhereClause, Errors, Results)\xFE";
 z+="    If Errors Then rpc_Error(Errors); Return\xFE";
 z+="    rpc_showStatus(\"RPC Select: \":fHandle<2>:\" \":WhereClause)\xFE";
 z+="    FormList Results\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub rpc_SelectTo(ByVal Cols As String, ByVal fHandle As String, ByVal WhereClause As String, ByRef SL As SelectList, ByRef Success As Boolean)\xFE";
 z+="    Success = @rpc(fHandle<1, 1>, fHandle<1,2>, \"serverselect\", Cols, fHandle<2>, WhereClause, Errors, Results)\xFE";
 z+="    If Errors Then rpc_Error(Errors); Return\xFE";
 z+="    rpc_showStatus(\"RPC SelectTo: \":fHandle<2>:\" \":WhereClause)\xFE";
 z+="    FormList Results To SL\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub rpc_Write(ByVal Item As String, ByVal fHandle As String, ByVal IName As String, ByRef Success As Boolean)\xFE";
 z+="    Call rpc_WriteX(Item, fHandle, IName, Success, \"\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub rpc_WriteU(ByVal Item As String, ByVal fHandle As String, ByVal IName As String, ByRef Success As Boolean)\xFE";
 z+="    Call rpc_WriteX(Item, fHandle, IName, Success, \"U\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub rpc_WriteJSon(ByVal Item As JSON, ByVal fHandle As String, ByVal IName As String, ByRef Success As Boolean)\xFE";
 z+="    Call rpc_WriteX(CStr(Item), fHandle, IName, Success, \"JSon\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub rpc_WriteJSonU(ByVal Item As JSON, ByVal fHandle As String, ByVal IName As String, ByRef Success As Boolean)\xFE";
 z+="    Call rpc_WriteX(CStr(Item), fHandle, IName, Success, \"JSonU\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub rpc_WriteX(ByVal Item As String, ByVal fHandle As String, ByVal IName As String, ByRef Success As Boolean, ByRef wType As String)\xFE";
 z+="    Call rpc_dropOldCache()\xFE";
 z+="    \xFE";
 z+="    rpc_showStatus(\"RPC Write\":wType:\":\":IName)\xFE";
 z+="    Success = @rpc(fHandle<1, 1>, fHandle<1,2>, \"serverwrite\":LCase(wType), \"0x\":STX(Item), fHandle<2>, IName, Errors)\xFE";
 z+="    If Errors Then rpc_Error(Errors); return\xFE";
 z+="\xFE";
 z+="    Dim Key As String = LCase(Replace(fHandle, VM(), \"**\"):\"&&\":IName)\xFE";
 z+="\xFE";
 z+="    * If the Commit for the WriteU later fails, we need to be sure to invalidate the cache\xFE";
 z+="    @Session.rpc_cached_items[key] = Item\xFE";
 z+="    @Session.rpc_cached_timer[key] = timer() \xFE";
 z+="End Sub\xFE";
 z+=""
window.cached_jsb_odb["rpc_db"]=z;
var z="/*\xFE";
 z+="     The routines listed here become RestFul functions on the server where they are compiled\xFE";
 z+="*/\xFE";
 z+="\xFE";
 z+="Subroutine rpc_server\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="function rpc_record_call(ByVal info As String) As Boolean\xFE";
 z+="   if system(1) <> \"aspx\" then return false\xFE";
 z+="   write info on @fHandle(\"\", \"iplog\", true), datetime():\".\":Right(timer(), 2):\" \":@myip Else Return False\xFE";
 z+="   return true\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="function @@ServerClearFile(ByVal fHandle As String, ByRef Errors As String) As Boolean\xFE";
 z+="    \xFE";
 z+="    if @IsAdmin else Errors = \"Insufficient privileges for ClearFile on \":@jsbRootAct:\" \":@who; return 0\xFE";
 z+="    Dim F As FileHandle\xFE";
 z+="    if system(1) = \"aspx\" then \xFE";
 z+="        Dim fh As String = field(fhandle, \":\", 2) \xFE";
 z+="        open fh to f else Errors = \"Open error: \":fh:\" \":@errors; return 0\xFE";
 z+="    end else\xFE";
 z+="        f = fhandle\xFE";
 z+="    end if\xFE";
 z+="    ClearFile f else Errors = @errors; return 0\xFE";
 z+="    Errors = \"\"\xFE";
 z+="    return 1\xFE";
 z+="end function  \xFE";
 z+="\xFE";
 z+="function @@ServerCreateFile(ByVal filename As String, ByRef fHandle As String, ByRef Errors As String) As Boolean\xFE";
 z+="    \xFE";
 z+="    if system(1) = \"aspx\" then \xFE";
 z+="        if @IsAdmin else Errors = \"Insufficient privileges for CreateFile on \":@jsbRootAct:\" \":@who; return 0\xFE";
 z+="    end else\xFE";
 z+="        if @Session.Authenticated <> \"yes\" Then Errors = \"You are not an !validated:\":@Session.Authenticated  ; return 0\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    CreateFile filename else \xFE";
 z+="        Errors = @errors\xFE";
 z+="        return 0\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    Dim X As FileHandle\xFE";
 z+="    open filename To X else\xFE";
 z+="        Errors = @errors\xFE";
 z+="        return 0\xFE";
 z+="    End If\xFE";
 z+="    if system(1) = \"aspx\" then fHandle = \"rmt:\":filename else fHandle = X\xFE";
 z+="    return 1\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="function @@ServerDeleteFile(ByVal fHandle As String, ByRef Errors As String) As Boolean\xFE";
 z+="    \xFE";
 z+="    if @IsAdmin else Errors = \"Insufficient privileges for DeleteFile on \":@jsbRootAct:\" \":@who; return 0\xFE";
 z+="    Dim F As FileHandle\xFE";
 z+="    if system(1) = \"aspx\" then \xFE";
 z+="        Dim fh As String = field(fhandle, \":\", 2) \xFE";
 z+="        open fh to f else Errors = \"Open error: \":fh:\" \":@errors; return 0\xFE";
 z+="    end else\xFE";
 z+="        f = fhandle\xFE";
 z+="    end if\xFE";
 z+="    DeleteFile f else Errors = @errors; return 0\xFE";
 z+="    Errors = \"\"\xFE";
 z+="    return 1\xFE";
 z+="end function    \xFE";
 z+="\xFE";
 z+="function @@ServerListFiles(ByRef Results As Array, ByRef Errors As String) As Boolean\xFE";
 z+="    \xFE";
 z+="    rpc_record_call(\"listfiles\")\xFE";
 z+="    ListFiles To Results Then Return True\xFE";
 z+="    Errors = @Errors\xFE";
 z+="    return false\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="\xFE";
 z+="* RPC for OPEN\xFE";
 z+="*\xFE";
 z+="*     Body = \"_p1=\":@UrlEncode(DictData):\"&_p2=\":@UrlEncode(filename)\xFE";
 z+="*     Result = JSon(@Get(\"GET\", \"\", @jsbrootact:\"ServerOpen?\":Body, \"\", \"\"))\xFE";
 z+="*     If !Result._restFunctionResult Then Stop \"Open failed: \":Result._p3\xFE";
 z+="*     fHandle = Result._p3\xFE";
 z+="*\xFE";
 z+="function @@ServerOpen(ByVal DictData As String, ByVal filename As String, ByRef fHandle As String, ByRef Errors As String) As Boolean\xFE";
 z+="    \xFE";
 z+="    if !IsAdmin() Then\xFE";
 z+="        if @jsb_bf.isRestrictedFile(DictData, filename) Then \xFE";
 z+="            Errors = @Errors:\" \":@jsbRoot\xFE";
 z+="            return 0\xFE";
 z+="        End If\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    open DictData, filename to X else \xFE";
 z+="        Errors = \"***\":@errors:\" '\":dictdata:\"'-'\":filename:\"'\"\xFE";
 z+="        return 0\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    if DictData Then DictData = DictData:\" \"\xFE";
 z+="    if system(1) = \"aspx\" then fHandle = \"rmt:\":DictData:filename else fHandle = X\xFE";
 z+="    \xFE";
 z+="    Errors = \"opened in as \":@username:\" - \":@Who:\" \":IsAdmin()\xFE";
 z+="    return 1\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="function @@ServerPrimaryKeyName(ByVal fHandle As String, ByRef PrimaryKeyColumnName As String) As Boolean\xFE";
 z+="    if !ServerAspxHandleCheck(fhandle, f, Errors) Then Return 0\xFE";
 z+="    PrimaryKeyColumnName = primaryKeyName(f)\xFE";
 z+="    if PrimaryKeyColumnName then return 1\xFE";
 z+="    PrimaryKeyColumnName = @Errors\xFE";
 z+="    return 0\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="function ServerAspxHandleCheck(byval fhandle As String, ByRef f As FileHandle, ByRef Errors As String) As Boolean\xFE";
 z+="    \xFE";
 z+="    if system(1) <> \"aspx\" then \xFE";
 z+="        if isRestrictedFile(fhandle) then\xFE";
 z+="            Errors = \"Insufficient privileges for \":fhandle:\" on \":@jsbRoot:\" as \":@UserName:\" t:\":TypeOfFile(fhandle):\" h2f:\":fname\xFE";
 z+="            return 0\xFE";
 z+="        end if\xFE";
 z+="    \xFE";
 z+="        f = fHandle\xFE";
 z+="        Return True\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    if Left(fHandle, 4) <> \"rmt:\" Then \xFE";
 z+="        Errors = \"Bad file handle: \":fHandle\xFE";
 z+="        Return False\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    fHandle = DropLeft(fHandle, \"rmt:\")\xFE";
 z+="    Dim ddata As String = FieldLeft(fHandle, \" \")\xFE";
 z+="    Dim fName As String = DropLeft(fHandle, \" \")\xFE";
 z+="        \xFE";
 z+="    if isRestrictedFile(ddata, fName) then\xFE";
 z+="        Errors = \"Insufficient privileges for \":fhandle:\" on \":@jsbRoot:\" as \":@UserName:\" t:\":TypeOfFile(fhandle):\" h2f:\":fname\xFE";
 z+="        return 0\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    open ddata, fname to f else Errors = \"Open error: \":fname:\" \":@errors; return 0\xFE";
 z+="\xFE";
 z+="    Return True\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="\xFE";
 z+="function @@ServerDeleteItem(byval fhandle As String, ByVal IName As String, ByRef Errors As String) As Boolean\xFE";
 z+="    Dim F As FileHandle\xFE";
 z+="    if !ServerAspxHandleCheck(fhandle, f, Errors) Then Return 0\xFE";
 z+="    if @IsAdmin else Errors = \"Insufficient privileges for DeleteItem on \":@jsbRootAct:\" \":@who; return 0\xFE";
 z+="    Errors = \"\"\xFE";
 z+="    return 1\xFE";
 z+="end function  \xFE";
 z+="\xFE";
 z+="function @@ServerRead(ByRef Item As String, byval fhandle As String, byval IName As String, ByRef Errors As String) As Boolean\xFE";
 z+="    Dim F As FileHandle\xFE";
 z+="    if !ServerAspxHandleCheck(fhandle, f, Errors) Then Return 0\xFE";
 z+="    read item from f, IName else Errors = @errors; return 0\xFE";
 z+="    Errors = \"\"\xFE";
 z+="    return 1\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="function @@ServerReadU(ByRef Item As String, byval fhandle As String, byval IName As String, ByRef Errors As String) As Boolean\xFE";
 z+="    Dim F As FileHandle\xFE";
 z+="    if !ServerAspxHandleCheck(fhandle, f, Errors) Then Return 0\xFE";
 z+="    read item from f, IName else Errors = @errors; return 0\xFE";
 z+="    Errors = \"\"\xFE";
 z+="    return 1\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="function @@ServerReadJSon(ByRef Item As String, byval fhandle As String, byval IName As String, ByRef Errors As String) As Boolean\xFE";
 z+="    Dim F As FileHandle\xFE";
 z+="    if !ServerAspxHandleCheck(fhandle, f, Errors) Then Return 0\xFE";
 z+="    Dim J As JSON\xFE";
 z+="    readjson J from f, IName else Errors = @errors; return 0\xFE";
 z+="    Item = CStr(J)\xFE";
 z+="    Errors = \"\"\xFE";
 z+="    return 1\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="function @@ServerReadV(ByRef Line As String, byval fhandle As String, byval IName As String, ByVal AtrNo As Integer, ByRef Errors As String) As Boolean\xFE";
 z+="    Dim F As FileHandle\xFE";
 z+="    if !ServerAspxHandleCheck(fhandle, f, Errors) Then Return 0\xFE";
 z+="    readv Line from f, IName, AtrNo else Errors = @errors; return 0\xFE";
 z+="    Errors = \"\"\xFE";
 z+="    return 1\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="function @@ServerReadVU(ByRef Line As String, byval fhandle As String, byval IName As String, ByVal AtrNo As Integer, ByRef Errors As String) As Boolean\xFE";
 z+="    Dim F As FileHandle\xFE";
 z+="    if !ServerAspxHandleCheck(fhandle, f, Errors) Then Return 0\xFE";
 z+="    readvu Line from f, IName, AtrNo else Errors = @errors; return 0\xFE";
 z+="    Errors = \"\"\xFE";
 z+="    return 1\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="function @@ServerReadXml(ByRef Item As String, byval fhandle As String, byval IName As String, ByRef Errors As String) As Boolean\xFE";
 z+="    Dim F As FileHandle\xFE";
 z+="    if !ServerAspxHandleCheck(fhandle, f, Errors) Then Return 0\xFE";
 z+="    readXml XmlItem from f, IName else Errors = @errors; return 0\xFE";
 z+="    Item = CStr(XmlItem)\xFE";
 z+="    Errors = \"\"\xFE";
 z+="    return 1\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="function @@ServerReadXmlU(ByRef Item As String, byval fhandle As String, byval IName As String, ByRef Errors As String) As Boolean\xFE";
 z+="    Dim F As FileHandle\xFE";
 z+="    if !ServerAspxHandleCheck(fhandle, f, Errors) Then Return 0\xFE";
 z+="    readXmlU XmlItem from f, IName else Errors = @errors; return 0\xFE";
 z+="    Item = CStr(XmlItem)\xFE";
 z+="    Errors = \"\"\xFE";
 z+="    return 1\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="function @@ServerSelect(ByVal COLS As String, byval fhandle As String, byval WhereClause As String, ByRef Errors As String, ByRef Results As JSON) As Boolean\xFE";
 z+="    Dim F As FileHandle\xFE";
 z+="    if !ServerAspxHandleCheck(fhandle, f, Errors) Then Return 0\xFE";
 z+="    \xFE";
 z+="    Dim SL As SelectList\xFE";
 z+="    Select cols from f where whereclause to SL else Errors = @errors; return 0\xFE";
 z+="    \xFE";
 z+="    Errors = \"\"\xFE";
 z+="    Dim Results As JSON = JSON(SL)\xFE";
 z+="    return 1\xFE";
 z+="end function     \xFE";
 z+="\xFE";
 z+="function @@ServerSendEmail(byval From As String, byval To As String, byval CC As String, byval BCC As String, byval Subject As String, byval Body As String, ByRef Errors As String) As Boolean\xFE";
 z+="    if @IsAdmin else Errors = \"Insufficient privileges for SendEmail on \":@jsbRootAct:\" \":@who; return 0\xFE";
 z+="    @EMail.Send From, To, CC, BCC, Subject, Body Then Return 1 Else Errors = @Errors\xFE";
 z+="    Body = \"\"\xFE";
 z+="    return 0\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="function @@ServerSqlSelect(ByVal SqlStatement As String, ByRef Results As JSON, ByRef Errors As String) As Boolean\xFE";
 z+="    if @IsAdmin else Errors = \"Insufficient privileges for SqlSelect on \":@jsbRootAct:\" \":@who; return 0\xFE";
 z+="    Dim SL As SelectList\xFE";
 z+="    SqlSelect SqlStatement To SL Else Errors = @errors; return 0\xFE";
 z+="    Results = GetList(SL)\xFE";
 z+="    Errors = \"\"\xFE";
 z+="    return 1\xFE";
 z+="end function \xFE";
 z+="\xFE";
 z+="function @@ServerWrite(ByVal Itm As String, byval fhandle As String, byval IName As String, ByRef Errors As String) As Boolean\xFE";
 z+="    Dim F As FileHandle\xFE";
 z+="    if !ServerAspxHandleCheck(fhandle, f, Errors) Then Return 0\xFE";
 z+="    \xFE";
 z+="    if system(1) = \"aspx\" then \xFE";
 z+="        if @IsAdmin else Errors = \"Insufficient privileges for Write on \":@jsbRootAct:\" \":@who; return 0\xFE";
 z+="    end else\xFE";
 z+="        if @Session.Authenticated <> \"yes\" Then Errors = \"You are not an !validated:\":@Session.Authenticated  ; return 0\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    if Left(Itm, 2) = \"0x\" Then Itm = XTS(Mid(Itm, 3))\xFE";
 z+="    write Itm on f, IName else Errors = @errors; return 0\xFE";
 z+="    Errors = \"\"\xFE";
 z+="    Itm = \"\"\xFE";
 z+="    return 1\xFE";
 z+="end function     \xFE";
 z+="\xFE";
 z+="function @@ServerWriteU(ByVal Itm As String, byval fhandle As String, byval IName As String, ByRef Errors As String) As Boolean\xFE";
 z+="    Dim F As FileHandle\xFE";
 z+="    if !ServerAspxHandleCheck(fhandle, f, Errors) Then Return 0\xFE";
 z+="    \xFE";
 z+="    if system(1) = \"aspx\" then \xFE";
 z+="        if @IsAdmin else Errors = \"Insufficient privileges for WriteU on \":@jsbRootAct:\" \":@who; return 0\xFE";
 z+="    end else\xFE";
 z+="        if @Session.Authenticated <> \"yes\" Then Errors = \"You are not an !validated:\":@Session.Authenticated  ; return 0\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    if Left(Itm, 2) = \"0x\" Then Itm = XTS(Mid(Itm, 3))\xFE";
 z+="    writeu Itm on f, IName else Errors = @errors; return 0\xFE";
 z+="    Errors = \"\"\xFE";
 z+="    Itm = \"\"\xFE";
 z+="    return 1\xFE";
 z+="end function    \xFE";
 z+="\xFE";
 z+="function @@ServerWriteJson(ByVal Itm As String, byval fhandle As String, byval IName As String, ByRef Errors As String) As Boolean \xFE";
 z+="    Dim F As FileHandle\xFE";
 z+="    if !ServerAspxHandleCheck(fhandle, f, Errors) Then Return 0\xFE";
 z+="    \xFE";
 z+="    if system(1) = \"aspx\" then \xFE";
 z+="        if @IsAdmin else Errors = \"Insufficient privileges for WriteJson on \":@jsbRootAct:\" \":@who; return 0\xFE";
 z+="    end else\xFE";
 z+="        if @Session.Authenticated <> \"yes\" Then Errors = \"You are not an !validated:\":@Session.Authenticated  ; return 0\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    if Left(Itm, 2) = \"0x\" Then Itm = XTS(Mid(Itm, 3))\xFE";
 z+="    writejson Itm on f, IName else Errors = @errors; return 0\xFE";
 z+="    Errors = \"\"\xFE";
 z+="    Itm = \"\"\xFE";
 z+="    return 1\xFE";
 z+="end function     \xFE";
 z+="\xFE";
 z+="function @@ServerWriteJsonU(ByVal Itm As String, byval fhandle As String, byval IName As String, ByRef Errors As String) As Boolean\xFE";
 z+="    Dim F As FileHandle\xFE";
 z+="    if !ServerAspxHandleCheck(fhandle, f, Errors) Then Return 0\xFE";
 z+="    \xFE";
 z+="    if system(1) = \"aspx\" then \xFE";
 z+="        if @IsAdmin else Errors = \"Insufficient privileges for WriteJsonU on \":@jsbRootAct:\" \":@who; return 0\xFE";
 z+="    end else\xFE";
 z+="        if @Session.Authenticated <> \"yes\" Then Errors = \"You are not an !validated:\":@Session.Authenticated  ; return 0\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    if Left(Itm, 2) = \"0x\" Then Itm = XTS(Mid(Itm, 3))\xFE";
 z+="    writejsonU Itm on f, IName else Errors = @errors; return 0\xFE";
 z+="    Errors = \"\"\xFE";
 z+="    Itm = \"\"\xFE";
 z+="    return 1\xFE";
 z+="end function     \xFE";
 z+=" \xFE";
 z+="\xFE";
 z+="function @@ServerLogin(ByVal UserName As String, ByVal Password As String, ByVal InitialDB As String, ByRef Errors As String) As Boolean\xFE";
 z+="    if Not(@VerifyUser(UserName, Password)) Then\xFE";
 z+="        Errors = \"Unable to verify password for \":UserName\xFE";
 z+="        rpc_record_call(\"failed rpc login: \":UserName)\xFE";
 z+="        Return False\xFE";
 z+="    End If\xFE";
 z+="    rpc_record_call(\"rpc login: \":UserName)\xFE";
 z+="    \xFE";
 z+="    if system(1) = \"gae\" then \xFE";
 z+="        @Session.Authenticated = \"yes\"\xFE";
 z+="        @Session.UserName = UserName\xFE";
 z+="    Else\xFE";
 z+="        @signin(UserName, true) ' only good for this session, not other tabs\xFE";
 z+="\xFE";
 z+="        AttachDB InitialDB Else\xFE";
 z+="            Errors = \"***\":@errors\xFE";
 z+="            Return False\xFE";
 z+="        End If\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    Errors = @UserNo:\"-Signed in as \":username:\"-\":IsAdmin() ;* UserNo (SID) is for GAE\xFE";
 z+="    return True\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="function @@ServerCompile(ByVal fname As String, ByVal IName As String, ByRef Errors As String) As Boolean\xFE";
 z+="    if system(1) = \"aspx\" then \xFE";
 z+="        if @IsAdmin else Errors = \"Insufficient privileges for WriteXmlU on \":@jsbRootAct:\" \":@who; return 0\xFE";
 z+="    end else\xFE";
 z+="        if @Session.Authenticated <> \"yes\" Then Errors = \"You are not an !validated:\":@Session.Authenticated  ; return 0\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    Dim xMsg as String = \"\"\xFE";
 z+="    Execute \"BASIC \":Fname:\" \":IName Capturing XMsg\xFE";
 z+="    \xFE";
 z+="    Dim ELine As String = \"\"\xFE";
 z+="    Dim fromLineNo As Integer = 0\xFE";
 z+="    \xFE";
 z+="    If Instr(XMsg, Chr(14)) Then ' Errors\xFE";
 z+="        ELine = Field(XMsg, Chr(14), 2)\xFE";
 z+="        fromLineNo = Field(ELine, ' ', 1)\xFE";
 z+="        ELine = Mid(ELine, Col2()+1)\xFE";
 z+="        Errors = \"!Error: \":ELine\xFE";
 z+="        \xFE";
 z+="    ElseIf Instr(XMsg, Chr(15)) Then ' Warnings\xFE";
 z+="        ELine = Field(XMsg, Chr(15), 2)\xFE";
 z+="        fromLineNo = Field(ELine, ' ', 1)\xFE";
 z+="        ELine = Mid(ELine, Col2()+1)\xFE";
 z+="        Errors = ELine\xFE";
 z+="        \xFE";
 z+="    ElseIf Instr(XMsg, \"^\") Then\xFE";
 z+="        XMsg = Replace(XMsg, Crlf(), Am())\xFE";
 z+="        XMsg = Replace(XMsg, Chr(13), Am())\xFE";
 z+="        XMsg = Replace(XMsg, Chr(10), Am())\xFE";
 z+="        XMsg = DropTags(XMsg)\xFE";
 z+="        \xFE";
 z+="        P = Instr(XMsg, \"^\")\xFE";
 z+="        \xFE";
 z+="        LineNo = Dcount(XMsg[1, P], Am())\xFE";
 z+="        BLine = XMsg<LineNo-1>\xFE";
 z+="        ELine = XMsg<LineNo>\xFE";
 z+="        ALine = XMsg<LineNo+1>\xFE";
 z+="        \xFE";
 z+="        fromLineNo = Val(ELine)\xFE";
 z+="        If !fromLineNo Then fromLineNo = Val(BLine)\xFE";
 z+="        \xFE";
 z+="        Errors = \"!\":BLine:Crlf():ELine:Crlf():ALine\xFE";
 z+="    Else\xFE";
 z+="        Errors = \"\"\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    return Errors = \"\"\xFE";
 z+="end function\xFE";
 z+=""
window.cached_jsb_odb["rpc_server"]=z;
var z="Function SelectTo(byval COLS As String, byval fHandle As Object, byval WhereClause As String, ByRef SL As SelectList) As Boolean\xFE";
 z+="   * $options aspx\xFE";
 z+="\xFE";
 z+="    if instri(WhereClause, \"orderby\") then\xFE";
 z+="        Dim aWhereClause As Array = Split(WhereClause, 5)\xFE";
 z+="        Dim term As String\xFE";
 z+="        Dim termi As Integer\xFE";
 z+="        for each term, termi in aWhereClause\xFE";
 z+="            if lcase(term) = \"orderby\" then awhereclause[termi] = \"order by\"\xFE";
 z+="        next\xFE";
 z+="        WhereClause = Join(aWhereClause, ' ')\xFE";
 z+="    end if\xFE";
 z+="            \xFE";
 z+="    if !System(11) And WhereClause <> \"\" And (system(1) = 'js' Or left(fhandle, 4) = \"dos:\") Then\xFE";
 z+="       ' Can we build a pre-select on ItemID's?\xFE";
 z+="        Dim preSelect As String = preSelectByItemID(WhereClause)\xFE";
 z+="        if preSelect Then I_Select Cols From fHandle Where preSelect Else ClearSelect\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    // Limit to list of previously selected ids?\xFE";
 z+="    If System(11) Then\xFE";
 z+="        Dim aLimitedIDs As Array = GetList(0)\xFE";
 z+="        If Len(aLimitedIDs) Then\xFE";
 z+="            Dim NeedParens As Integer = InStr(Replace(Replace(lcase(WhereClause), \"(\", \" \"), \")\", \" \"), \" or \") \xFE";
 z+="            If NeedParens Then WhereClause = \"(\":WhereClause:\")\"\xFE";
 z+="            \xFE";
 z+="            * Put this first so a pre-select can be made on itemid's\xFE";
 z+="            * The funny spacing and mixed case is so I can pull this apart in javaScript and know it was a pre-select\xFE";
 z+="            Dim LimitedIDs As String = \"('\":Join(aLimitedIDs, \"','\"):\"')\"\xFE";
 z+="            LimitedIDs = \"ItemID iN \":LimitedIDs  \xFE";
 z+="            Dim nexttk As String = lcase(field(whereclause, \" \", 1))\xFE";
 z+="            \xFE";
 z+="            Dim AndClause As String\xFE";
 z+="            if nexttk = \"sort\" or nexttk = \"order\" or nexttk = \"by\" then AndClause = \" \" else AndClause = \" AnD \"\xFE";
 z+="            if WhereClause Then WhereClause = LimitedIDs:AndClause:WhereClause ELse WhereClause = LimitedIDs\xFE";
 z+="        End If\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    If left(fHandle, 1) = \"@\" Then\xFE";
 z+="        Dim cName As String = \"jsb_odb|\":Mid(Field(fHandle, \".\", 1), 2):\"_selectto\"\xFE";
 z+="        Dim rfHandle As String = Mid(fHandle, Col2()+1)\xFE";
 z+="        Dim Success As Boolean\xFE";
 z+="        call @cName(ByVal COLS, ByVal rfHandle, ByVal WhereClause, ByRef SL, ByRef Success)\xFE";
 z+="        Return Success\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    I_Select Cols from fHandle where WhereClause to SL then\xFE";
 z+="        return 1\xFE";
 z+="    else\xFE";
 z+="        return 0\xFE";
 z+="    end if\xFE";
 z+="End Function\xFE";
 z+="\xFE";
 z+="Function SelectTo(byval COLS As String, byval fHandle As Variable, byval WhereClause As String, ByRef SL As SelectList) As Boolean\xFE";
 z+="   * $options js, gae\xFE";
 z+="   \xFE";
 z+="    if instri(WhereClause, \"orderby\") then\xFE";
 z+="        Dim aWhereClause As Array = Split(WhereClause, 5)\xFE";
 z+="        for each term, termi in aWhereClause\xFE";
 z+="            if lcase(term) = \"orderby\" then awhereclause[termi] = \"order by\"\xFE";
 z+="        next\xFE";
 z+="        WhereClause = Join(aWhereClause, ' ')\xFE";
 z+="    end if\xFE";
 z+="            \xFE";
 z+="    if !System(11) And WhereClause <> \"\" And (system(1) = 'js' Or left(fhandle, 4) = \"dos:\") Then\xFE";
 z+="       ' Can we build a pre-select on ItemID's?\xFE";
 z+="        preSelect = preSelectByItemID(WhereClause)\xFE";
 z+="        if preSelect Then I_Select Cols From fHandle Where preSelect Else ClearSelect\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    // Limit to list of previously selected ids?\xFE";
 z+="    If System(11) Then\xFE";
 z+="        LimitedIDs = GetList(0)\xFE";
 z+="        If Len(LimitedIDs) Then\xFE";
 z+="            NeedParens = InStr(Replace(Replace(lcase(WhereClause), \"(\", \" \"), \")\", \" \"), \" or \") \xFE";
 z+="            If NeedParens Then WhereClause = \"(\":WhereClause:\")\"\xFE";
 z+="            \xFE";
 z+="            * Put this first so a pre-select can be made on itemid's\xFE";
 z+="            * The funny spacing and mixed case is so I can pull this apart in javaScript and know it was a pre-select\xFE";
 z+="            LimitedIDs = \"('\":Join(LimitedIDs, \"','\"):\"')\"\xFE";
 z+="            if system(1) = \"js\" then LimitedIDs = \"ItEmID iN \":LimitedIDs Else LimitedIDs = \"ItemID iN \":LimitedIDs  \xFE";
 z+="            nexttk = lcase(field(whereclause, \" \", 1))\xFE";
 z+="            if nexttk = \"sort\" or nexttk = \"order\" or nexttk = \"by\" then AndClause = \" \" else AndClause = \" AnD \"\xFE";
 z+="            if WhereClause Then WhereClause = LimitedIDs:AndClause:WhereClause ELse WhereClause = LimitedIDs\xFE";
 z+="        End If\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    If left(fHandle, 1) = \"@\" Then\xFE";
 z+="        cName = \"jsb_odb|\":Mid(Field(fHandle, \".\", 1), 2):\"_selectto\"\xFE";
 z+="        rfHandle = Mid(fHandle, Col2()+1)\xFE";
 z+="        call @cName(ByVal COLS, ByVal rfHandle, ByVal WhereClause, ByRef SL, ByRef Success)\xFE";
 z+="        Return Success\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    if system(1) = \"aspx\" Then\xFE";
 z+="        I_Select Cols from fHandle where WhereClause to SL then\xFE";
 z+="            return 1\xFE";
 z+="        else\xFE";
 z+="            return 0\xFE";
 z+="        end if\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    if LCase(FieldLeft(Cols, \" \")) = \"top\" then\xFE";
 z+="        Cols = DropLeft(Cols, \" \")\xFE";
 z+="        topN = FieldLeft(Cols, \" \")\xFE";
 z+="        Cols = DropLeft(Cols, \" \")\xFE";
 z+="    Elseif LCase(FieldLeft(Cols, \" \")) = \"bottom\" then\xFE";
 z+="        Cols = DropLeft(Cols, \" \")\xFE";
 z+="        bottomN = FieldLeft(Cols, \" \")\xFE";
 z+="        Cols = DropLeft(Cols, \" \")\xFE";
 z+="    elseif left(LCase(Cols), 7) = \"bottom \" then\xFE";
 z+="        bottomN = field(cols, \" \", 2)\xFE";
 z+="    end if\xFE";
 z+="        \xFE";
 z+="    // Look in Where Clause for Functions, Operators, ItemContent and OrderBy\xFE";
 z+="    Call ParseSqlColumns(WhereClause, false, [], WhereHasFunctions, WhereHasOperators, usesItemContent, hasOrderBy)\xFE";
 z+="    \xFE";
 z+="    // Build list of display Columns and also check for functions, operators, ItemContent\xFE";
 z+="    DisplayColumns = []\xFE";
 z+="    Call ParseSqlColumns(COLS, true, DisplayColumns, ColumnsHasFunctions, ColumnsHasOperators, usesItemContent, ignoreorderby)\xFE";
 z+="\xFE";
 z+="    if ColumnsHasFunctions or ColumnsHasOperators Or WhereHasFunctions or (WhereHasOperators and system(1) = \"gae\") or (hasOrderBy and system(1) = \"gae\") Then  \xFE";
 z+="        if WhereHasFunctions or WhereHasOperators then tWhere = \"\" else tWhere = WhereClause\xFE";
 z+="        if (usesItemContent and system(1) <> \"aspx\") or WhereHasFunctions then \xFE";
 z+="            if InStr(lcase(Cols), \"itemid\") then tcols = \"*,ItemID\" Else tcols = \"*\"\xFE";
 z+="        else \xFE";
 z+="            tCols = COLS\xFE";
 z+="        end if\xFE";
 z+="        I_Select tCols from fHandle Where tWhere to SL Else Return 0\xFE";
 z+="    else\xFE";
 z+="        if topN then TopN = \"top \":TopN:\" \"\xFE";
 z+="        I_Select topN:COLS from fHandle where WhereClause to SL then\xFE";
 z+="            return 1\xFE";
 z+="        else\xFE";
 z+="            return 0\xFE";
 z+="        end if\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    js = JSON(SL)\xFE";
 z+="    SelectedItemIDs = js.SelectedItemIDs\xFE";
 z+="    SelectedItems = js.SelectedItems\xFE";
 z+="\xFE";
 z+="    if WhereHasFunctions or (WhereHasOperators and system(1) <> \"aspx\") or (hasOrderBy and system(1) = \"gae\") then\xFE";
 z+="        if !filterJsonArray(SelectedItemIDs, SelectedItems, WhereClause) Then Return false\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    if ColumnsHasFunctions or ColumnsHasOperators or (usesItemContent and system(1) <> \"aspx\") or WhereHasFunctions then\xFE";
 z+="        if !processColumns(DisplayColumns, SelectedItems, SelectedItemIDs) Then Return false\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    if topN then \xFE";
 z+="        newIDS = []\xFE";
 z+="        newItems = []\xFE";
 z+="        \xFE";
 z+="        SelectedItemIDs = Split(SelectedItemIDs, Am())\xFE";
 z+="        if topN > UBound(SelectedItemIDs) then topN = UBound(SelectedItemIDs)\xFE";
 z+="        for I = 1 to topN\xFE";
 z+="           newIDS[-1] = SelectedItemIDs[I]\xFE";
 z+="           if len(SelectedItems) then newItems[-1] = SelectedItems[I]\xFE";
 z+="        next\xFE";
 z+="        SelectedItemIDs = Join(newIDS, Am())\xFE";
 z+="        SelectedItems = newItems\xFE";
 z+="        \xFE";
 z+="    ElseIf bottomN Then\xFE";
 z+="        newIDS = []\xFE";
 z+="        newItems = []\xFE";
 z+="        \xFE";
 z+="        SelectedItemIDs = Split(SelectedItemIDs, Am())\xFE";
 z+="        for I = bottomN+1 to UBound(SelectedItemIDs)\xFE";
 z+="           newIDS[-1] = SelectedItemIDs[I]\xFE";
 z+="           if len(SelectedItems) then newItems[-1] = SelectedItems[I]\xFE";
 z+="        next\xFE";
 z+="        SelectedItemIDs = Join(newIDS, Am())\xFE";
 z+="        SelectedItems = newItems\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    if js.OnlyReturnItemIDs then SelectedItems = [] else SelectedItems = json(SelectedItems)\xFE";
 z+="\xFE";
 z+="    rs = { }\xFE";
 z+="    rs.SelectedItemIDs = SelectedItemIDs\xFE";
 z+="    rs.SelectedItems = SelectedItems\xFE";
 z+="    rs.OnlyReturnItemIDs = js.OnlyReturnItemIDs\xFE";
 z+="\xFE";
 z+="    formlist rs To SL\xFE";
 z+="    return 1\xFE";
 z+="End Function\xFE";
 z+="\xFE";
 z+="Function Select(byval COLS As String, byval fHandle As Object, byval WhereClause As String, Optional ByVal ToIgnored As Object) As Boolean\xFE";
 z+="    * $options aspx\xFE";
 z+="    if !System(11) And WhereClause <> \"\" And left(fhandle, 4) = \"dos:\" Then\xFE";
 z+="       ' Can we build a pre-select on ItemID's?\xFE";
 z+="        Dim preSelect As String = preSelectByItemID(WhereClause)\xFE";
 z+="        if preSelect Then \xFE";
 z+="            Select Cols From fHandle Where preSelect\xFE";
 z+="        end if\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    // Limit to list of previously selected ids?\xFE";
 z+="    If System(11) Then\xFE";
 z+="        Dim aLimitedIDs As Array = GetList(0)\xFE";
 z+="        If Len(aLimitedIDs) Then\xFE";
 z+="            Dim NeedParens As Integer = InStr(Replace(Replace(lcase(WhereClause), \"(\", \" \"), \")\", \" \"), \" or \") \xFE";
 z+="            If NeedParens Then WhereClause = \"(\":WhereClause:\")\"\xFE";
 z+="            \xFE";
 z+="            * Put this first so a pre-select can be made on itemid's\xFE";
 z+="            * The funny spacing and mixed case is so I can pull this apart in javaScript and know it was a pre-select\xFE";
 z+="            Dim LimitedIDs As String = \"('\":Join(aLimitedIDs, \"','\"):\"')\"\xFE";
 z+="            LimitedIDs = \"ItemID iN \":LimitedIDs \xFE";
 z+="            if WhereClause Then WhereClause = LimitedIDs:\" AnD \":WhereClause ELse WhereClause = LimitedIDs\xFE";
 z+="        End If\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    If left(fHandle, 1) = \"@\" Then\xFE";
 z+="        Dim cName As String = \"jsb_odb|\":Mid(Field(fHandle, \".\", 1), 2):\"_select\"\xFE";
 z+="        Dim rfHandle As String = Mid(fHandle, Col2()+1)\xFE";
 z+="        Dim Success As Boolean\xFE";
 z+="        call @cName(ByVal COLS, ByVal rfHandle, ByVal WhereClause, ByRef Success)\xFE";
 z+="        Return Success\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    I_Select Cols from fHandle where WhereClause then\xFE";
 z+="        return 1\xFE";
 z+="    else\xFE";
 z+="        return 0\xFE";
 z+="    end if\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="Function Select(byval COLS As String, byval fHandle As Variable, byval WhereClause As String, Optional ByVal ToIgnored) As Boolean\xFE";
 z+="    * $options js, gae\xFE";
 z+="    if !System(11) And WhereClause <> \"\" And (system(1) = 'js' Or left(fhandle, 4) = \"dos:\") Then\xFE";
 z+="       ' Can we build a pre-select on ItemID's?\xFE";
 z+="        preSelect = preSelectByItemID(WhereClause)\xFE";
 z+="        if preSelect Then Select Cols From fHandle Where preSelect\xFE";
 z+="    End If\xFE";
 z+="    \xFE";
 z+="    // Limit to list of previously selected ids?\xFE";
 z+="    If System(11) Then\xFE";
 z+="        LimitedIDs = GetList(0)\xFE";
 z+="        If Len(LimitedIDs) Then\xFE";
 z+="            NeedParens = InStr(Replace(Replace(lcase(WhereClause), \"(\", \" \"), \")\", \" \"), \" or \") \xFE";
 z+="            If NeedParens Then WhereClause = \"(\":WhereClause:\")\"\xFE";
 z+="            \xFE";
 z+="            * Put this first so a pre-select can be made on itemid's\xFE";
 z+="            * The funny spacing and mixed case is so I can pull this apart in javaScript and know it was a pre-select\xFE";
 z+="            LimitedIDs = \"('\":Join(LimitedIDs, \"','\"):\"')\"\xFE";
 z+="            if system(1) = \"js\" then LimitedIDs = \"ItEmID iN \":LimitedIDs Else LimitedIDs = \"ItemID iN \":LimitedIDs \xFE";
 z+="            if WhereClause Then WhereClause = LimitedIDs:\" AnD \":WhereClause ELse WhereClause = LimitedIDs\xFE";
 z+="        End If\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    If left(fHandle, 1) = \"@\" Then\xFE";
 z+="        cName = \"jsb_odb|\":Mid(Field(fHandle, \".\", 1), 2):\"_select\"\xFE";
 z+="        rfHandle = Mid(fHandle, Col2()+1)\xFE";
 z+="        call @cName(ByVal COLS, ByVal rfHandle, ByVal WhereClause, ByRef Success)\xFE";
 z+="        Return Success\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    if system(1) = \"aspx\" Then\xFE";
 z+="        I_Select Cols from fHandle where WhereClause then\xFE";
 z+="            return 1\xFE";
 z+="        else\xFE";
 z+="            return 0\xFE";
 z+="        end if\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    if LCase(FieldLeft(Cols, \" \")) = \"top\" then\xFE";
 z+="        Cols = DropLeft(Cols, \" \")\xFE";
 z+="        topN = FieldLeft(Cols, \" \")\xFE";
 z+="        Cols = DropLeft(Cols, \" \")\xFE";
 z+="    Elseif LCase(FieldLeft(Cols, \" \")) = \"bottom\" then\xFE";
 z+="        Cols = DropLeft(Cols, \" \")\xFE";
 z+="        bottomN = FieldLeft(Cols, \" \")\xFE";
 z+="        Cols = DropLeft(Cols, \" \")\xFE";
 z+="    elseif left(LCase(Cols), 7) = \"bottom \" then\xFE";
 z+="        bottomN = field(cols, \" \", 2)\xFE";
 z+="    end if\xFE";
 z+="        \xFE";
 z+="    // Look in Where Clause for Functions, Operators, ItemContent and OrderBy\xFE";
 z+="    Call ParseSqlColumns(WhereClause, false, [], WhereHasFunctions, WhereHasOperators, usesItemContent, hasOrderBy)\xFE";
 z+="    \xFE";
 z+="    // Build list of display Columns and also check for functions, operators, ItemContent\xFE";
 z+="    DisplayColumns = []\xFE";
 z+="    Call ParseSqlColumns(COLS, true, DisplayColumns, ColumnsHasFunctions, ColumnsHasOperators, usesItemContent, ignoreorderby)\xFE";
 z+="\xFE";
 z+="    if ColumnsHasFunctions or ColumnsHasOperators Or WhereHasFunctions or (WhereHasOperators and system(1) = \"gae\") or (hasOrderBy and system(1) = \"gae\") Then  \xFE";
 z+="        if WhereHasFunctions or WhereHasOperators then tWhere = \"\" else tWhere = WhereClause\xFE";
 z+="        if (usesItemContent and system(1) <> \"aspx\") or WhereHasFunctions then \xFE";
 z+="            if InStr(lcase(Cols), \"itemid\") then tcols = \"*,ItemID\" Else tcols = \"*\"\xFE";
 z+="        else \xFE";
 z+="            tCols = COLS\xFE";
 z+="        end if\xFE";
 z+="        I_Select tCols from fHandle Where tWhere to SL Else Return 0\xFE";
 z+="    else\xFE";
 z+="        if topN then TopN = \"top \":TopN:\" \"\xFE";
 z+="        I_Select topN:COLS from fHandle where WhereClause then\xFE";
 z+="            return 1\xFE";
 z+="        else\xFE";
 z+="            return 0\xFE";
 z+="        end if\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    js = JSON(SL)\xFE";
 z+="    SelectedItemIDs = js.SelectedItemIDs\xFE";
 z+="    SelectedItems = js.SelectedItems\xFE";
 z+="\xFE";
 z+="    if WhereHasFunctions or (WhereHasOperators and system(1) <> \"aspx\") or (hasOrderBy and system(1) = \"gae\") then\xFE";
 z+="        if !filterJsonArray(SelectedItemIDs, SelectedItems, WhereClause) Then Return false\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    if ColumnsHasFunctions or ColumnsHasOperators or (usesItemContent and system(1) <> \"aspx\") or WhereHasFunctions then\xFE";
 z+="        if !processColumns(DisplayColumns, SelectedItems, SelectedItemIDs) Then Return false\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    if topN then \xFE";
 z+="        newIDS = []\xFE";
 z+="        newItems = []\xFE";
 z+="        \xFE";
 z+="        SelectedItemIDs = Split(SelectedItemIDs, Am())\xFE";
 z+="        if topN > UBound(SelectedItemIDs) then topN = UBound(SelectedItemIDs)\xFE";
 z+="        for I = 1 to topN\xFE";
 z+="           newIDS[-1] = SelectedItemIDs[I]\xFE";
 z+="           if len(SelectedItems) then newItems[-1] = SelectedItems[I]\xFE";
 z+="        next\xFE";
 z+="        SelectedItemIDs = Join(newIDS, Am())\xFE";
 z+="        SelectedItems = newItems\xFE";
 z+="        \xFE";
 z+="    ElseIf bottomN Then\xFE";
 z+="        newIDS = []\xFE";
 z+="        newItems = []\xFE";
 z+="        \xFE";
 z+="        SelectedItemIDs = Split(SelectedItemIDs, Am())\xFE";
 z+="        for I = bottomN+1 to UBound(SelectedItemIDs)\xFE";
 z+="           newIDS[-1] = SelectedItemIDs[I]\xFE";
 z+="           if len(SelectedItems) then newItems[-1] = SelectedItems[I]\xFE";
 z+="        next\xFE";
 z+="        SelectedItemIDs = Join(newIDS, Am())\xFE";
 z+="        SelectedItems = newItems\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    if js.OnlyReturnItemIDs then SelectedItems = [] else SelectedItems = json(SelectedItems)\xFE";
 z+="\xFE";
 z+="    rs = { SelectedItemIDs: SelectedItemIDs }\xFE";
 z+="    rs.SelectedItems = SelectedItems\xFE";
 z+="    rs.OnlyReturnItemIDs = js.OnlyReturnItemIDs\xFE";
 z+="\xFE";
 z+="    formlist rs\xFE";
 z+="    return 1\xFE";
 z+="End Function\xFE";
 z+="\xFE";
 z+="function filterJsonArray(SelectedItemIDs, SelectedItems, where)\xFE";
 z+="    * $options js, gae\xFE";
 z+="    \xFE";
 z+="    // AND - OR, &&, ||\xFE";
 z+="    // A Matches B\xFE";
 z+="    // =, #, NE, >=, <=, >, <, EQ, GE, LE, LT, GT\xFE";
 z+="    // Concat : &\xFE";
 z+="    // + -\xFE";
 z+="    // ^\xFE";
 z+="    // uniary + -\xFE";
 z+="    //\xFE";
 z+="\xFE";
 z+="    var tokens = Split(where, \" \", 5)\xFE";
 z+="    tokens[-1] = Chr(255)\xFE";
 z+="    if typeOf(SelectedItemIDs) = \"String\" Then SelectedItemIDs = Split(SelectedItemIDs, AM())\xFE";
 z+="\xFE";
 z+="    sortColumns = []\xFE";
 z+="    var results = []\xFE";
 z+="    sorting = false;\xFE";
 z+="    var gotone = false;\xFE";
 z+="    var hasCompare = false;\xFE";
 z+="    var needC = false\xFE";
 z+="    var ClauseStart = 1\xFE";
 z+="    likeStart = 1\xFE";
 z+="    \xFE";
 z+="    for i = 1 to UBound(tokens)\xFE";
 z+="        var otoken = tokens[i];\xFE";
 z+="        var token = LCase(otoken);\xFE";
 z+="\xFE";
 z+="        if (sorting) {\xFE";
 z+="            if (token == ',') {\xFE";
 z+="                gotone = false\xFE";
 z+="\xFE";
 z+="            } else if (gotone && token == 'asc') {\xFE";
 z+="                sortColumns[len(sortColumns)] = \">\":sortColumns[len(sortColumns)];\xFE";
 z+="\xFE";
 z+="            } else if (gotone && token == 'desc') {\xFE";
 z+="                sortColumns[len(sortColumns)] = \"<\":sortColumns[len(sortColumns)];\xFE";
 z+="\xFE";
 z+="            } else if (gotone && token == 'numeric') {\xFE";
 z+="                sortColumns[len(sortColumns)] = \"#\":sortColumns[len(sortColumns)];\xFE";
 z+="\xFE";
 z+="            } else if (gotone && token == 'right') {\xFE";
 z+="                sortColumns[len(sortColumns)] = \"!\":sortColumns[len(sortColumns)];\xFE";
 z+="\xFE";
 z+="            } else if right(token, 1) = \"(\" {\xFE";
 z+="                @Errors = \"invalid sort column \":token\xFE";
 z+="                return false\xFE";
 z+="\xFE";
 z+="            } else if IsAlpha(Left(token, 1)) {\xFE";
 z+="                gotone = true\xFE";
 z+="                sortColumns[-1] = otoken\xFE";
 z+="\xFE";
 z+="            } else if (Left(token, 1) == \"[\" && Right(token, 1) == \"]\") {\xFE";
 z+="                otoken = Mid(otoken, 1, Len(otoken) - 2);\xFE";
 z+="                gotone = true\xFE";
 z+="                sortColumns[-1] = otoken\xFE";
 z+="\xFE";
 z+="            } else if Left(token, 2) = \"*a\" {\xFE";
 z+="                gotone = true\xFE";
 z+="                sortColumns[-1] = otoken\xFE";
 z+="\xFE";
 z+="            } else if token == Chr(255) {\xFE";
 z+="                    ' done\xFE";
 z+="\xFE";
 z+="            } else {\xFE";
 z+="                @errors = \"invalid sort syntax '\":token:'\"'\xFE";
 z+="                return false\xFE";
 z+="            }\xFE";
 z+="\xFE";
 z+="        } else {\xFE";
 z+="\xFE";
 z+="            var ntoken = LCase(tokens[i + 1]);\xFE";
 z+="            isValidSqlFunction = ValidSqlFunction(token, rToken)\xFE";
 z+="\xFE";
 z+="            switch (true) {\xFE";
 z+="            case token == Chr(255)\xFE";
 z+="                if hasCompare then  results.Insert(ClauseStart, \"LCase(\");  results[-1] = \")\"\xFE";
 z+="                if needC then results[-1] = \")\"\xFE";
 z+="\xFE";
 z+="            case token == \"order\" && ntoken == \"by\":\xFE";
 z+="                if hasCompare then results.Insert(ClauseStart, \"LCase(\");  results[-1] = \")\"\xFE";
 z+="                if needC then results[-1] = \")\"\xFE";
 z+="\xFE";
 z+="                sorting = true\xFE";
 z+="                i += 1\xFE";
 z+="\xFE";
 z+="            case token == \"gt\": results[-1] = \") > LCase(\"; hasCompare = True\xFE";
 z+="            case token == \"lt\": results[-1] = \") < LCase(\"; hasCompare = True\xFE";
 z+="            case token == \"ge\": results[-1] = \") >= LCase(\"; hasCompare = True\xFE";
 z+="            case token == \"le\": results[-1] = \") <= LCase(\"; hasCompare = True\xFE";
 z+="            case token == \"eq\": results[-1] = \") = LCase(\"; hasCompare = True\xFE";
 z+="            case token == \"ne\": results[-1] = \") <> LCase(\"; hasCompare = True\xFE";
 z+="            case token == \"=\": results[-1] = \") = LCase(\"; hasCompare = True\xFE";
 z+="            case token == \">\": results[-1] = \") > LCase(\"; hasCompare = True\xFE";
 z+="            case token == \"<\": results[-1] = \") < LCase(\"; hasCompare = True\xFE";
 z+="            case token == \">=\": results[-1] = \") >= LCase(\"; hasCompare = True\xFE";
 z+="            case token == \"<=\": results[-1] = \") <= LCase(\"; hasCompare = True\xFE";
 z+="            case token == \"=>\": results[-1] = \") >= LCase(\"; hasCompare = True\xFE";
 z+="            case token == \"=<\": results[-1] = \") <= LCase(\"; hasCompare = True\xFE";
 z+="            case token == \"<>\": results[-1] = \") <> LCase(\"; hasCompare = True\xFE";
 z+="            case token == \"!=\": results[-1] = \") <> LCase(\"; hasCompare = True\xFE";
 z+="\xFE";
 z+="            case token == \"like\":\xFE";
 z+="                results.Insert(ClauseStart, \"@jsb_odb.sqlLikeCompare(\"); results[-1] = \",\"\xFE";
 z+="                needC = true\xFE";
 z+="\xFE";
 z+="            case token == \":\": results[-1] = \":'':\"\xFE";
 z+="            case token == \"&\": results[-1] = \":'':\"\xFE";
 z+="\xFE";
 z+="            case token == 'itemid' Or token = \"*a0\": results[-1] = \"ItemID\"\xFE";
 z+="\xFE";
 z+="            case Left(token, 2) == \"*a\" && isNum(Mid(token, 3)):\xFE";
 z+="                results[-1] = \"@jsb_odb.SqlExtract(row, \":Mid(token, 3):\")\"\xFE";
 z+="\xFE";
 z+="            case token == Chr(9): results[-1] = \" \"\xFE";
 z+="            case isNum(token): results[-1] = token\xFE";
 z+="\xFE";
 z+="            case token == \"and\" || token == \"&&\": \xFE";
 z+="                if hasCompare then results.Insert(ClauseStart, \"LCase(\");  results[-1] = \")\"; hasCompare = False\xFE";
 z+="                if needC then results[-1] = \")\"\xFE";
 z+="                results[-1] = \" and \"\xFE";
 z+="                likeStart = UBound(results) + 1\xFE";
 z+="\xFE";
 z+="            case token == \"or\" or token == \"||\": \xFE";
 z+="                if hasCompare then results.Insert(ClauseStart, \"LCase(\");  results[-1] = \")\"; hasCompare = False\xFE";
 z+="                if needC then results[-1] = \")\"\xFE";
 z+="                results[-1] = \" or \"\xFE";
 z+="                ClauseStart = UBound(results) + 1\xFE";
 z+="\xFE";
 z+="            case isValidSqlFunction: \xFE";
 z+="                if rToken = \"IsNull(\" Then rToken = \"IsNull2(\"\xFE";
 z+="                results[-1] = rToken\xFE";
 z+="                ClauseStart = UBound(results)\xFE";
 z+="  \xFE";
 z+="            case IsAlpha(Left(token, 1)):\xFE";
 z+="                    // get data from dataset row\xFE";
 z+="                    //results[-1] = \"LCase(\":\"row.\":token:\")\"\xFE";
 z+="\xFE";
 z+="                results[-1] = \"row[translate['\":token:\"']]\"\xFE";
 z+="\xFE";
 z+="            case Left(token, 1) == \"[\" && Right(token, 1) == \"]\":\xFE";
 z+="                    // get data from dataset row\xFE";
 z+="                results[-1] = \"row[translate['\":Mid(token, 2, Len(otoken) - 2):\"']]\"\xFE";
 z+="\xFE";
 z+="            case InStr(`'\",+-/^%()`, Left(token, 1)) > 0:\xFE";
 z+="                results[-1] = token\xFE";
 z+="                \xFE";
 z+="            case InStr(\" \":Chr(9), Left(token, 1)) > 0:\xFE";
 z+="                    // white space\xFE";
 z+="                results[-1] = ' '\xFE";
 z+="            }\xFE";
 z+="        }\xFE";
 z+="    next\xFE";
 z+="\xFE";
 z+="        // create dynamic function\xFE";
 z+="    if UBound(results) And Len(SelectedItemIDs) {\xFE";
 z+="        var sFilter = Join(results, ' ')\xFE";
 z+="        var f = ''\xFE";
 z+="        id = \"eval_\":Replace(Replace(@UserNo, \":\", \"_\"), \"-\", \"_\")\xFE";
 z+="\xFE";
 z+="        f = `sub `:id:`(translate, SelectedItemIDs, SelectedItems)`\xFE";
 z+="        f<-1> = '   var Items = []; '\xFE";
 z+="        f<-1> = '   var ItemIDs = []; '\xFE";
 z+="        f<-1> = '   for each ItemID, i in SelectedItemIDs'\xFE";
 z+="        f<-1> = '      if ItemID <> \"__json_indexes__\" then'\xFE";
 z+="        f<-1> = '         var row = SelectedItems[i]; '\xFE";
 z+="        f<-1> = '         if !row Then Row = {}'\xFE";
 z+="        f<-1> = `         if ` : sFilter : ` { Items[-1] = SelectedItems[i]; ItemIDs[-1] = ItemID } `\xFE";
 z+="        f<-1> = `      End If`\xFE";
 z+="        f<-1> = '   next'\xFE";
 z+="        f<-1> = '   SelectedItemIDs = ItemIDs'\xFE";
 z+="        f<-1> = '   SelectedItems = Items'\xFE";
 z+="        f<-1> = 'end sub'\xFE";
 z+="\xFE";
 z+="        ftmp = fhandle('tmp')\xFE";
 z+="        write f on ftmp, id\xFE";
 z+="        execute \"basic tmp \":id capturing c\xFE";
 z+="\xFE";
 z+="        if !instr(lcase(c), \"successful\") then\xFE";
 z+="            @Errors = C\xFE";
 z+="            return false\xFE";
 z+="        end if\xFE";
 z+="\xFE";
 z+="        cid = \"tmp|\":id\xFE";
 z+="\xFE";
 z+="        translate = {}\xFE";
 z+="\xFE";
 z+="        for each tag in SelectedItems[0]\xFE";
 z+="            translate[lcase(tag)] = tag\xFE";
 z+="        next\xFE";
 z+="\xFE";
 z+="        call @cid(translate, SelectedItemIDs, SelectedItems)\xFE";
 z+="\xFE";
 z+="        delete ftmp, id\xFE";
 z+="\xFE";
 z+="        if system(1) = \"js\" then\xFE";
 z+="            delete @fhandle(\"dict\", \"tmp\"), id:\"_SUB1.js\"\xFE";
 z+="        else\xFE";
 z+="            delete @fhandle(\"dict\", \"tmp\"), id:\"_1.pcs\"\xFE";
 z+="        end if\xFE";
 z+="\xFE";
 z+="    }\xFE";
 z+="\xFE";
 z+="    if (sorting and system(1) = \"gae\") {\xFE";
 z+="            // combine everything into a single JSON record for sort\xFE";
 z+="        for i = 1 to len(SelectedItems)\xFE";
 z+="            if SelectedItems[i] then r = SelectedItems[i] else r = {}\xFE";
 z+="            r._itemId_ = SelectedItemIDs[i]\xFE";
 z+="            SelectedItems[i] = r\xFE";
 z+="        next\xFE";
 z+="\xFE";
 z+="        SelectedItems = Sort(SelectedItems, sortColumns)\xFE";
 z+="\xFE";
 z+="            // explode JSON rec back into sepeate recs for item ids\xFE";
 z+="        for i = 1 to len(SelectedItems)\xFE";
 z+="            SelectedItemIDs[i] = SelectedItems[i]._itemId_\xFE";
 z+="            r = SelectedItems[i]\xFE";
 z+="            Remove r, \"_itemId_\"\xFE";
 z+="        next\xFE";
 z+="    }\xFE";
 z+="\xFE";
 z+="    SelectedItemIDs = Join(SelectedItemIDs, AM())\xFE";
 z+="    return true\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="function sqlLikeCompare(X, L)\xFE";
 z+="    * $options js, gae\xFE";
 z+="    \xFE";
 z+="    var fchar = Left(L, 1)\xFE";
 z+="    var e = \"%\";\xFE";
 z+="    X = LCase(X)\xFE";
 z+="    L = LCase(L)\xFE";
 z+="\xFE";
 z+="    if (fchar == \"%\" || fchar == \"[\") {\xFE";
 z+="        var lenL = Len(L);\xFE";
 z+="        if Right(L, 1) == \"]\" || Right(L, 1) == \"%\" then return InStr(X, Mid(L, 2, lenL - 2)) > 0;\xFE";
 z+="        return Right(X, lenL - 1) == Mid(L, 2)\xFE";
 z+="    }\xFE";
 z+="\xFE";
 z+="    var echar = Right(L, 1);\xFE";
 z+="    if (echar == \"%\" || echar == \"]\") {\xFE";
 z+="        lenL = Len(L);\xFE";
 z+="        return Left(X, lenL - 1) == Left(L, lenL - 1)\xFE";
 z+="    }\xFE";
 z+="\xFE";
 z+="    return LCase(X) == LCase(L)\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="function sqlExtract(row, atrno)\xFE";
 z+="    * $options js, gae\xFE";
 z+="    \xFE";
 z+="    if !row then return \"\"\xFE";
 z+="    if hasTag(row, \"ItemContent\") Then return Extract(row.ItemContent, atrno) else return row[atrNo] ;* row[Extract(row, atrNo)]\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="Subroutine parseSqlColumns(s, addRowObj, Columns, hasFunctions, hasOperators, usesItemContent, hasOrderBy)\xFE";
 z+="    * $options js, gae\xFE";
 z+="    \xFE";
 z+="    Columns = []\xFE";
 z+="    lp = 0\xFE";
 z+="    AfterConjection = false\xFE";
 z+="    hasOrderBy = false\xFE";
 z+="\xFE";
 z+="    * Which format?\xFE";
 z+="    *   LIST TABLENAME C1 C2 With C3 = C4 BY C5\xFE";
 z+="    *\xFE";
 z+="    * or\xFE";
 z+="    *   SELECT C1, C2 FROM TABLENAME WHERE C3 = C4 ORDER BY C5\xFE";
 z+="    *\xFE";
 z+="    a = split(s, \"\", 5)\xFE";
 z+="    For each token in a\xFE";
 z+="        if token = \"from\" then SqlFormat = True\xFE";
 z+="    next\xFE";
 z+="\xFE";
 z+="    Term = \"\"\xFE";
 z+="    For each token, i in a\xFE";
 z+="        t = lcase(token)\xFE";
 z+="        lt = left(t, 1)\xFE";
 z+="        rt = right(t, 1)\xFE";
 z+="\xFE";
 z+="        switch (true) {\xFE";
 z+="            case t == \"gt\": t = \">\"\xFE";
 z+="            case t == \"lt\": t = \"<\"\xFE";
 z+="            case t == \"ge\": t = \">=\"\xFE";
 z+="            case t == \"le\": t = \"<=\"\xFE";
 z+="            case t == \"eq\": t = \"==\"\xFE";
 z+="            case t == \"ne\": t = \"<>\"\xFE";
 z+="            case t == \"!=\": t = \"<>\"\xFE";
 z+="            case t == \",\": if !lp Then token = \"\"\xFE";
 z+="            \xFE";
 z+="            case t == \"like\": \xFE";
 z+="                if system(1) = \"gae\" then\xFE";
 z+="                    token = \"sqlLikeCompare(\":Term:\", \"\xFE";
 z+="                    Term = \"\"\xFE";
 z+="                    hasFunctions = true\xFE";
 z+="                end if\xFE";
 z+="    \xFE";
 z+="            case t == 'in'\xFE";
 z+="                if system(1) = \"gae\" then\xFE";
 z+="                    token = \"sqlInOperator(\":Term:\", \"\xFE";
 z+="                    Term = \"\"\xFE";
 z+="                    hasFunctions = true\xFE";
 z+="                end if\xFE";
 z+="    \xFE";
 z+="            case t = \"list\" || t = \"sort\" || t = \"order\" || t = \"by\" || t = \"with\" || t = \"where\" || t = \"or\" || t = \"and\" || t = \"top\" || t = \"bottom\"\xFE";
 z+="    \xFE";
 z+="            case t == 'itemid' or t = '*a0': token = \"ItemID\"\xFE";
 z+="    \xFE";
 z+="            case rt = \"(\":\xFE";
 z+="    \xFE";
 z+="            case t = \"as\" And Lp = 0:\xFE";
 z+="                i += 1\xFE";
 z+="                if Term Then\xFE";
 z+="                    Term := \" as \":a[i]\xFE";
 z+="                Else\xFE";
 z+="                    Columns[UBound(Columns)] := \" as \":a[i]\xFE";
 z+="                End If\xFE";
 z+="                \xFE";
 z+="                token = \"\"\xFE";
 z+="                \xFE";
 z+="            case Left(t, 2) == \"*a\" && isNum(Mid(t, 3)): \xFE";
 z+="                if addRowObj then token = \"@jsb_odb.SqlExtract(row, \":Mid(t, 3):\")\"\xFE";
 z+="                usesItemContent = true\xFE";
 z+="    \xFE";
 z+="            case IsAlpha(Left(t, 1)):\xFE";
 z+="                // get data from dataset row\xFE";
 z+="                if addRowObj then token = \"row.\":token\xFE";
 z+="                usesItemContent = true\xFE";
 z+="    \xFE";
 z+="            case lt == \"[\" && rt == \"]\":\xFE";
 z+="                // get data from dataset row\xFE";
 z+="                if addRowObj then token = \"row['\":Mid(token, 2, Len(token) - 2):\"']\"\xFE";
 z+="                usesItemContent = true\xFE";
 z+="        }\xFE";
 z+="\xFE";
 z+="        t = lcase(token)\xFE";
 z+="        lt = left(t, 1)\xFE";
 z+="\xFE";
 z+="        if t = \"\" Then\xFE";
 z+="        \xFE";
 z+="        Elseif t = \"(\" then\xFE";
 z+="            lp++\xFE";
 z+="            Term := t\xFE";
 z+="            hasOperators = true\xFE";
 z+="\xFE";
 z+="        elseif rt = \"(\" then \xFE";
 z+="            lp++\xFE";
 z+="            If Term Then Columns[-1] = Term\xFE";
 z+="            if validSqlFunction(t, sqlFunc) then Term = sqlFunc else Term = \"Invalid_function_\":t\xFE";
 z+="            hasFunctions = true\xFE";
 z+="\xFE";
 z+="        else if t = \")\" then\xFE";
 z+="            lp--\xFE";
 z+="            Term := t\xFE";
 z+="            if lp = 0 then \xFE";
 z+="                Columns[-1] = Term\xFE";
 z+="                Term = ''\xFE";
 z+="            end if\xFE";
 z+="\xFE";
 z+="        else if t = \"and\" or t = \"or\" or t = \"like\" or InStr(\"=<>/:&|!\", lt) then \xFE";
 z+="            if !Len(Columns) And !Term Then Columns[-1] = \"Invalid Syntax\"\xFE";
 z+="            Term := \" \":t\xFE";
 z+="            AfterConjection = true\xFE";
 z+="            hasOperators = true\xFE";
 z+="\xFE";
 z+="        else if InStr(\"+-\", lt) then \xFE";
 z+="            Term := t\xFE";
 z+="            AfterConjection = true\xFE";
 z+="            hasOperators = true\xFE";
 z+="\xFE";
 z+="        else if AfterConjection then\xFE";
 z+="            Term := t\xFE";
 z+="            AfterConjection = false\xFE";
 z+="\xFE";
 z+="        elseif i = 1 and (t = \"top\" or t = \"bottom\") then\xFE";
 z+="            i++\xFE";
 z+="            \xFE";
 z+="        elseif i = 1 and (t = \"sort\" or t = \"list\") then\xFE";
 z+="            AfterConjection = false\xFE";
 z+="\xFE";
 z+="            if !SqlFormat Then\xFE";
 z+="                i++\xFE";
 z+="                TableName = a[i]\xFE";
 z+="\xFE";
 z+="                if LCase(TableName) = \"dict\" then\xFE";
 z+="                    i++\xFE";
 z+="                    TableName := \" \":a[i]\xFE";
 z+="\xFE";
 z+="                else if LCase(TableName) = \"data\" then\xFE";
 z+="                    i++\xFE";
 z+="                    TableName = a[i]\xFE";
 z+="                end if\xFE";
 z+="            end if\xFE";
 z+="\xFE";
 z+="        elseif lp = 0 and (t = \"sort\" or t = \"order\" or t= \"by\" or t= \"orderby\") then\xFE";
 z+="            hasOrderBy = true\xFE";
 z+="\xFE";
 z+="        elseif lp = 0 then\xFE";
 z+="            If Term Then Columns[-1] = Term\xFE";
 z+="            AfterConjection = false\xFE";
 z+="            if t = \",\" then Term = \"\" Else Term = token\xFE";
 z+="        else\xFE";
 z+="            If Term Then Term := \" \"\xFE";
 z+="            Term := Token\xFE";
 z+="        end if\xFE";
 z+="    next\xFE";
 z+="\xFE";
 z+="    If Term Then Columns[-1] = Term\xFE";
 z+="    if lp != 0 then Columns[-1] = \"unbalanced parentheses\"\xFE";
 z+="end subroutine\xFE";
 z+="\xFE";
 z+="function processColumns(Columns, Items, ItemIDs)\xFE";
 z+="    * $options js, gae\xFE";
 z+="    \xFE";
 z+="    // create dynamic function\xFE";
 z+="    if UBound(Columns) And UBound(Items) then\xFE";
 z+="        id = \"eval_\":Replace(Replace(@UserNo, \":\", \"_\"), \"-\", \"_\")\xFE";
 z+="\xFE";
 z+="        I1 = Items[1]\xFE";
 z+="\xFE";
 z+="        f = `sub `:id:`(Items, ItemIDs)`\xFE";
 z+="        f<-1> = '   var Results = []; '\xFE";
 z+="        f<-1> = '   for each row, rowi in Items'\xFE";
 z+="        f<-1> = '      ItemID = ItemIDs[rowi]'\xFE";
 z+="        f<-1> = '      r = {} '\xFE";
 z+="\xFE";
 z+="        For Each ColumnClause, ColumnI In Columns\xFE";
 z+="            if left(ColumnClause, 4) = \"row.\" then\xFE";
 z+="                if instr(ColumnClause, \" as \") then ColumnClause = \"row.\":DropLeft(ColumnClause, \" as \")\xFE";
 z+="                f<-1> = \"      r[`\":Field(ColumnClause, \".\", 2):\"`] =  \":ColumnClause\xFE";
 z+="                \xFE";
 z+="            elseIf LCase(ColumnClause) = \"itemid\" Then\xFE";
 z+="                f<-1> = \"      r.\":ColumnClause:\" =  \":ColumnClause\xFE";
 z+="            \xFE";
 z+="            elseIf columnClause = \",\" Then\xFE";
 z+="            \xFE";
 z+="            elseif instr(ColumnClause, \" as \") then\xFE";
 z+="                f<-1> = \"      r[`\":DropLeft(ColumnClause, \" as \"):\"`] = \":DropRight(ColumnClause, \" as \")\xFE";
 z+="                \xFE";
 z+="            Else\xFE";
 z+="                f<-1> = \"      r[`expr_\":ColumnI:\"`] =  \":ColumnClause\xFE";
 z+="            end if\xFE";
 z+="        Next\xFE";
 z+="\xFE";
 z+="\xFE";
 z+="        f<-1> = '      Results[-1] = r '\xFE";
 z+="        f<-1> = '   next'\xFE";
 z+="        f<-1> = '   Items = Results'\xFE";
 z+="        f<-1> = 'end sub'\xFE";
 z+="\xFE";
 z+="        ftmp = fhandle('tmp')\xFE";
 z+="        write f on ftmp, id\xFE";
 z+="        execute \"basic tmp \":id capturing c\xFE";
 z+="\xFE";
 z+="        if !instr(lcase(c), \"successful\") then\xFE";
 z+="            @Errors = C\xFE";
 z+="            return false\xFE";
 z+="        end if\xFE";
 z+="\xFE";
 z+="        cid = \"tmp|\":id\xFE";
 z+="\xFE";
 z+="        call @cid(Items, Split(ItemIDs, Chr(254)))\xFE";
 z+="\xFE";
 z+="        delete ftmp, id\xFE";
 z+="\xFE";
 z+="        if system(1) = \"js\" then\xFE";
 z+="            delete @fhandle(\"dict\", \"tmp\"), id:\"_SUB1.js\"\xFE";
 z+="        else\xFE";
 z+="            delete @fhandle(\"dict\", \"tmp\"), id:\"_1.pcs\"\xFE";
 z+="        end if\xFE";
 z+="    end if\xFE";
 z+="    return true\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="function validSqlFunction(token, rtoken)\xFE";
 z+="    * $options js, gae\xFE";
 z+="    \xFE";
 z+="    switch (true) {\xFE";
 z+="    case token == \"abs(\": rtoken = \"Abs(\"\xFE";
 z+="    case token == \"guid(\": rtoken = \"GUID(\"\xFE";
 z+="    case token == \"seq(\": rtoken = \"Seq(\"\xFE";
 z+="    case token == \"asc(\": rtoken = \"Seq(\"\xFE";
 z+="    case token == \"isint(\": rtoken = \"IsInt(\"\xFE";
 z+="    case token == \"isnull(\": rtoken = \"IsNull(\"\xFE";
 z+="    case token == \"isnothing(\": rtoken = \"IsNothing(\"\xFE";
 z+="    case token == \"chr(\": rtoken = \"Chr(\"\xFE";
 z+="    case token == \"char(\": rtoken = \"Chr(\"\xFE";
 z+="    case token == \"mid(\": rtoken = \"Mid(\"\xFE";
 z+="    case token == \"left(\": rtoken = \"Left(\"\xFE";
 z+="    case token == \"right(\": rtoken = \"Right(\"\xFE";
 z+="    case token == \"count(\": rtoken = \"Count(\"\xFE";
 z+="    case token == \"cint(\": rtoken = \"CInt(\"\xFE";
 z+="    case token == \"clng(\": rtoken = \"CInt(\"\xFE";
 z+="    case token == \"cdbl(\": rtoken = \"CNum(\"\xFE";
 z+="    case token == \"csng(\": rtoken = \"CNum(\"\xFE";
 z+="    case token == \"val(\": rtoken = \"CNum(\"\xFE";
 z+="    case token == \"cdec(\": rtoken = \"CNum(\"\xFE";
 z+="    case token == \"delete(\": rtoken = \"Delete(\"\xFE";
 z+="    case token == \"dcount(\": rtoken = \"DCount(\"\xFE";
 z+="    case token == \"extract(\": rtoken = \"Extract(\"\xFE";
 z+="    case token == \"hex(\": rtoken = \"DTX(\"\xFE";
 z+="    case token == \"exp(\": rtoken = \"Exp(\"\xFE";
 z+="    case token == \"field(\": rtoken = \"Field(\"\xFE";
 z+="    case token == \"iconv(\": rtoken = \"IConv(\"\xFE";
 z+="    case token == \"oconv(\": rtoken = \"OConv(\"\xFE";
 z+="    case token == \"index(\": rtoken = \"Index(\"\xFE";
 z+="    case token == \"instr(\": rtoken = \"InStr(\"\xFE";
 z+="    case token == \"len(\": rtoken = \"Len(\"\xFE";
 z+="    case token == \"ln(\": rtoken = \"Log(\"\xFE";
 z+="    case token == \"mcl(\": rtoken = \"LCase(\"\xFE";
 z+="    case token == \"lcase(\": rtoken = \"LCase(\"\xFE";
 z+="    case token == \"mcu(\": rtoken = \"UCase(\"\xFE";
 z+="    case token == \"ucase(\": rtoken = \"UCase(\"\xFE";
 z+="    case token == \"lower(\": rtoken = \"Lower(\"\xFE";
 z+="    case token == \"raise(\": rtoken = \"raise(\"\xFE";
 z+="    case token == \"mod(\": rtoken = \"Mod(\"\xFE";
 z+="    case token == \"not(\": rtoken = \"Not(\"\xFE";
 z+="    case token == \"pwr(\": rtoken = \"Pwr(\"\xFE";
 z+="    case token == \"rem(\": rtoken = \"Mod(\"\xFE";
 z+="    case token == \"rnd(\": rtoken = \"Rnd(\"\xFE";
 z+="    case token == \"space(\": rtoken = \"Space(\"\xFE";
 z+="    case token == \"sqrt(\": rtoken = \"Qqrt(\"\xFE";
 z+="    case token == \"str(\": rtoken = \"StrRpt(\"\xFE";
 z+="    case token == \"strrpt(\": rtoken = \"StrRpt(\"\xFE";
 z+="    case token == \"dateserial(\": rtoken = \"Date(\"\xFE";
 z+="    case token == \"timedate(\": rtoken = \"TimeDate(\"\xFE";
 z+="    case token == \"datetime(\": rtoken = \"DateTime(\"\xFE";
 z+="    case token == \"trim(\": rtoken = \"Trim(\"\xFE";
 z+="    case token == \"ltrim(\": rtoken = \"LTrim(\"\xFE";
 z+="    case token == \"trimf(\": rtoken = \"LTrim(\"\xFE";
 z+="    case token == \"rtrim(\": rtoken = \"RTrim(\"\xFE";
 z+="    case token == \"trimb(\": rtoken = \"RTrim(\"\xFE";
 z+="    case token == \"xtd(\": rtoken = \"XTD(\"\xFE";
 z+="    case token == \"convert(\": rtoken = \"Convert(\"\xFE";
 z+="    case token == \"replace(\": rtoken = \"Replace(\"\xFE";
 z+="    case token == \"change(\": rtoken = \"Change(\"\xFE";
 z+="    case token == \"changei(\": rtoken = \"ChangeI(\"\xFE";
 z+="    case token == \"xts(\": rtoken = \"XTS(\"\xFE";
 z+="    case token == \"stx(\": rtoken = \"STX(\"\xFE";
 z+="    case token == \"encode(\": rtoken = \"Encrypt(\"\xFE";
 z+="    case token == \"encrypt(\": rtoken = \"Encrypt(\"\xFE";
 z+="    case token == \"decode(\": rtoken = \"Decrypt(\"\xFE";
 z+="    case token == \"decrypt(\": rtoken = \"Decrypt(\"\xFE";
 z+="    case token == \"date(\": rtoken = \"Date(\"\xFE";
 z+="    case token == \"time(\": rtoken = \"Time(\"\xFE";
 z+="    case token == \"timer(\": rtoken = \"Timer(\"\xFE";
 z+="    case token == \"now(\": rtoken = \"Now(\"\xFE";
 z+="    case token == \"dow(\": rtoken = \"DayOfWeek(\"\xFE";
 z+="    case token == \"dayofweek(\": rtoken = \"DayOfWeek(\"\xFE";
 z+="    case token == \"year(\": rtoken = \"Year(\"\xFE";
 z+="    case token == \"month(\": rtoken = \"Month(\"\xFE";
 z+="    case token == \"day(\": rtoken = \"Day(\"\xFE";
 z+="    case token == \"dmy(\": rtoken = \"DMY(\"\xFE";
 z+="    case token == \"cstr(\": rtoken = \"CStr(\"\xFE";
 z+="    case token == \"system(\": rtoken = \"System(\"\xFE";
 z+="    case token == \"json(\": rtoken = \"JSON(\"\xFE";
 z+="    case token == \"xml(\": rtoken = \"XML(\"\xFE";
 z+="    case token == \"htmlencode(\": rtoken = \"htmlEscape(\"\xFE";
 z+="    case token == \"htmlescape(\": rtoken = \"htmlEscape(\"\xFE";
 z+="    case token == \"htmldecode(\": rtoken = \"htmlUnescape(\"\xFE";
 z+="    case token == \"htmlunescape(\": rtoken = \"htmlUnescape(\"\xFE";
 z+="    case token == \"urlencode(\": rtoken = \"urlEncode(\"\xFE";
 z+="    case token == \"urlescape(\": rtoken = \"urlEncode(\"\xFE";
 z+="    case token == \"urldecode(\": rtoken = \"UrlDecode(\"\xFE";
 z+="    case token == \"urlunescape(\": rtoken = \"UrlDecode(\"\xFE";
 z+="    case token == \"fmt(\": rtoken = \"Fmt(\"\xFE";
 z+="    case token == \"typeof(\": rtoken = \"typeOf(\"\xFE";
 z+="    case token == \"lbound(\": rtoken = \"LBound(\"\xFE";
 z+="    case token == \"ubound(\": rtoken = \"UBound(\"\xFE";
 z+="    case token == \"hastag(\": rtoken = \"HasTag(\"\xFE";
 z+="    case token == \"regx(\": rtoken = \"regExp(\"\xFE";
 z+="    case token == \"regex(\": rtoken = \"regExp(\"\xFE";
 z+="    case token == \"regexp(\": rtoken = \"regExp(\"\xFE";
 z+="    case else\xFE";
 z+="        return false\xFE";
 z+="    }\xFE";
 z+="    return true\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+=" // The point of a preselect is to get as much of the select condition that involves the ItemID\xFE";
 z+=" //   We then select this list, and it gives us a shorter list to filter with\xFE";
 z+=" //\xFE";
 z+="function preSelectByItemID(ByVal WhereClause As String) As String\xFE";
 z+="    ' Can we build a pre-select of only ItemID's?\xFE";
 z+="    Dim aWhereClause As Array = Split(WhereClause, 5)\xFE";
 z+="    WhereClause = Join(aWhereClause, ' ')\xFE";
 z+="    \xFE";
 z+="    Dim StopHere As Integer = 0\xFE";
 z+="    Dim PreSelect As Array = []\xFE";
 z+="    \xFE";
 z+="    Dim Term As String\xFE";
 z+="    Dim TermI As Integer\xFE";
 z+="    Dim Truncated As Integer\xFE";
 z+="    \xFE";
 z+="    For Each Term, TermI In aWhereClause\xFE";
 z+="        Dim ColName As String = ''\xFE";
 z+="        Dim lcterm As String = lcase(term)\xFE";
 z+="        \xFE";
 z+="        Dim fc As String = left(lcterm, 1)      ;* first char\xFE";
 z+="        Dim sc As String = mid(lcterm, 2, 1)    ;* 2nd chr\xFE";
 z+="        Dim m3 As String = mid(lcterm, 3)       ;* 3rd char forward\xFE";
 z+="        Dim lc As String = right(lcterm, 1)     ;* last char\xFE";
 z+="\xFE";
 z+="        if fc = '*' and sc = 'a' and isNumeric(m3) then\xFE";
 z+="               *Annn\xFE";
 z+="            ColName = lcterm\xFE";
 z+="            \xFE";
 z+="        elseif lcterm = 'and' or lcterm = 'or' then\xFE";
 z+="            \xFE";
 z+="        elseif lcterm = 'like' then\xFE";
 z+="        \xFE";
 z+="        elseif IsAlpha(fc) And InStr(fc, '(') = 0 Then\xFE";
 z+="                * Indetifier\xFE";
 z+="            ColName = lcterm\xFE";
 z+="                \xFE";
 z+="        else if fc = '[' and lc = ']' then\xFE";
 z+="                * [ColName]\xFE";
 z+="            ColName = mid(lcterm, 1, len(lcterm)-2)\xFE";
 z+="        \xFE";
 z+="        else if fc = '[' or lc = ']' or fc = '%' or lc = '%' then\xFE";
 z+="            * like term \xFE";
 z+="            \xFE";
 z+="        elseIf fc = '\"' Or fc = \"'\" Then\xFE";
 z+="            * \"String\" or \"ColName\"  (Column Name if next token is an relational operator)\xFE";
 z+="                \xFE";
 z+="            Dim nc As String = LCase(aWhereClause[TermI+1])\xFE";
 z+="            if InStr(' <>=!', Left(nc,1)) > 1 or nc = 'like' Then ColName = Mid(lcterm, 2, len(lcterm) - 2)\xFE";
 z+="        end if\xFE";
 z+="\xFE";
 z+="        if ColName Then\xFE";
 z+="            if ColName <> 'itemid' and ColName <> '*a0' then \xFE";
 z+="                Truncated = TermI\xFE";
 z+="                break\xFE";
 z+="            end if\xFE";
 z+="            \xFE";
 z+="        Elseif fc = \"'\" or fc = '\"' Then\xFE";
 z+="            * Ignore in strings\xFE";
 z+="            Term = Replace(Term, \"(\", Chr(1))\xFE";
 z+="            Term = Replace(Term, \")\", Chr(2))\xFE";
 z+="        End If\xFE";
 z+="                   \xFE";
 z+="        preSelect[-1] = Term\xFE";
 z+="    next\xFE";
 z+="    \xFE";
 z+="    Dim sPreSelect As String = Join(preSelect, ' ')\xFE";
 z+="    \xFE";
 z+="    Loop While Truncated Do\xFE";
 z+="        ' Find Last and or Or before the offending clause\xFE";
 z+="        preSelect = Split(sPreSelect, 5)\xFE";
 z+="        for i As Integer = ubound(preSelect) to lBound(preSelect) Step -1\xFE";
 z+="            lcTerm = LCase(preSelect[i])\xFE";
 z+="            preSelect.Pop()\xFE";
 z+="            if lcTerm = 'and' or lcTerm = 'or' or lcterm = \"order\" or lcterm = \"orderby\" or lcterm = \"by\" then break\xFE";
 z+="        next\xFE";
 z+="        \xFE";
 z+="        if lcterm = \"or\" then return \"\" ;* we can't preselect as the other part is an or statement\xFE";
 z+="        \xFE";
 z+="        ' Make sure parenthsis are balanced\xFE";
 z+="        sPreSelect = Join(preSelect, ' ')\xFE";
 z+="        Truncated = False\xFE";
 z+="        Loop\xFE";
 z+="            Dim FCnt As Integer = Count(sPreSelect, '(')\xFE";
 z+="            Dim BCnt As Integer = Count(sPreSelect, ')')\xFE";
 z+="        Until FCnt = BCnt Do\xFE";
 z+="            Dim FI As Integer = Index(sPreSelect, '(', FCnt)\xFE";
 z+="            Dim BI As Integer = Index(sPreSelect, ')', BCnt)\xFE";
 z+="            If FI > BI Then sPreSelect = Left(preSelect, FI - 1) Else sPreSelect = Left(preSelect, BI - 1)\xFE";
 z+="            sPreSelect = RTrim(sPreSelect)\xFE";
 z+="            Truncated = True\xFE";
 z+="        Repeat\xFE";
 z+="    Repeat\xFE";
 z+="    \xFE";
 z+="    sPreSelect = Replace(sPreSelect, Chr(1), \"(\")\xFE";
 z+="    sPreSelect = Replace(sPreSelect, Chr(2), \")\")\xFE";
 z+="\xFE";
 z+="    // no change? we can push all of this into the main select\xFE";
 z+="    if sPreSelect = WhereClause Then Return \"\"\xFE";
 z+="    return sPreSelect\xFE";
 z+="end function\xFE";
 z+=""
window.cached_jsb_odb["selectto"]=z;
var z="sub sheets\xFE";
 z+="    ****** see https://developers.google.com/sheets/reference/rest/\xFE";
 z+="    \xFE";
 z+="    * for auth:\xFE";
 z+="    ******     https://developers.google.com/identity/protocols/OAuth2WebServer\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="program gt\xFE";
 z+="   ' This is only for testing\xFE";
 z+="   Call sheets_Login(LoginInfo, Provider, UserName, _Password, InitialDB)\xFE";
 z+="   @session.CachedAccounts = \"sheets\":AM():\"@sheets%%\":LoginInfo\xFE";
 z+="end program\xFE";
 z+="\xFE";
 z+="// A single SHEET contains rows which get translated to individual Items (with keys that are either in Col1 (non-interger) or by Index # (integer)\xFE";
 z+="\xFE";
 z+="function sheets_readItems(LoginInfo, FileName)\xFE";
 z+="debug\xFE";
 z+="\xFE";
 z+="    SheetID = sheets_getID(FileName)\xFE";
 z+="    if !SheetID Then Return Nothing\xFE";
 z+="    \xFE";
 z+="    SpreadSheetID = Field(SheetID, \"*\", 1)\xFE";
 z+="    SheetID = Field(SheetID, '*', 2)\xFE";
 z+="    \xFE";
 z+="    if !LoginInfo Then\xFE";
 z+="        s = @session.CachedAccounts\xFE";
 z+="        locate 'sheets' in s<1> setting spot else Return Nothing\xFE";
 z+="        LoginInfo = Field(s<2, spot>, '%%', 2)\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    Url = `https://sheets.googleapis.com/v4/spreadsheets/`:SpreadSheetID:`/values/`:SheetID:`!A1%3AZZ9999?alt=json`\xFE";
 z+="    header = [\"Content-Type: application/json\", \"Authorization: Bearer \":LoginInfo]\xFE";
 z+="    sdoc = @jsb_bf.Get(Url, \"GET\", Header, '')\xFE";
 z+="    \xFE";
 z+="    debug\xFE";
 z+="    \xFE";
 z+="    sdoc = JSON(sdoc)\xFE";
 z+="    \xFE";
 z+="    Results = sdoc.values\xFE";
 z+="    Return Results\xFE";
 z+="    \xFE";
 z+="    firstMinor = Results[1]\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="// True (folder), False(file), Null(does not exist)\xFE";
 z+="function sheets_isFolder(ByVal LoginInfo, ByVal Path)\xFE";
 z+="    // Get meta data\xFE";
 z+="    if left(path, 1) = \"/\" then path = mid(path, 2)\xFE";
 z+="    Return @Session.sheets_cached_folders[Lcase(Path)]\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="function sheets_writeItems(LoginInfo, FileName, NewItem)\xFE";
 z+="    SheetID = sheets_getID(FileName)\xFE";
 z+="    if !SheetID Then Return Nothing\xFE";
 z+="    \xFE";
 z+="    debug\xFE";
 z+="    \xFE";
 z+="    SheetID = field(SheetID, 'full/', 2)\xFE";
 z+="    \xFE";
 z+="    if !LoginInfo Then\xFE";
 z+="        s = @session.CachedAccounts\xFE";
 z+="        locate 'sheets' in s<1> setting spot else stop 'attach sheets first'\xFE";
 z+="        LoginInfo = Field(s<2, spot>, '%%', 2)\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    Url = `https://sheets.googleapis.com/v4/spreadsheets/`:SheetID:`/values/A1%3AZZ9999?alt=json&valueInputOption=USER_ENTERED`\xFE";
 z+="    header = [\"Content-Type: application/json\", \"Authorization: Bearer \":LoginInfo]\xFE";
 z+="    sdoc = @jsb_bf.Get(Url, \"PUT\", Header, '')\xFE";
 z+="    \xFE";
 z+="    sdoc = JSON(sdoc)\xFE";
 z+="    \xFE";
 z+="    Majors = sdoc.values\xFE";
 z+="    firstMinor = Majors[1]\xFE";
 z+="    \xFE";
 z+="    debug\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="// **************************************** File System Calls Below // **************************************** \xFE";
 z+="// **************************************** File System Calls Below // **************************************** \xFE";
 z+="// **************************************** File System Calls Below // **************************************** \xFE";
 z+="// **************************************** File System Calls Below // **************************************** \xFE";
 z+="// **************************************** File System Calls Below // **************************************** \xFE";
 z+="\xFE";
 z+="Sub sheets_Logout(ByVal LoginInfo, ByRef Success)\xFE";
 z+="    Call sheets_dropOldCache()\xFE";
 z+="\xFE";
 z+="    s = @session.CachedAccounts\xFE";
 z+="    locate 'sheets' in s<1> setting spot then\xFE";
 z+="        s = delete(s, 1, spot)\xFE";
 z+="        s = delete(s, 2, spot)\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    // Logout\xFE";
 z+="    Url = `https://accounts.google.com/o/oauth2/revoke?token=`:@UrlEncode(LoginInfo)\xFE";
 z+="    header = [\"Content-Type: application/json\"]\xFE";
 z+="    sdoc = @jsb_bf.Get(Url, \"GET\", Header, \"\")\xFE";
 z+="    \xFE";
 z+="    if IsNothing(sdoc) Or sDoc = \"{}\" then\xFE";
 z+="        success = true\xFE";
 z+="        @session.at = \"\"\xFE";
 z+="        return\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    Success = False\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub sheets_ListFiles(LoginInfo, ByRef Results, ByRef Success)\xFE";
 z+="    Call sheets_dropOldCache()\xFE";
 z+="    Result = \"\"\xFE";
 z+="\xFE";
 z+="    // List a directory\xFE";
 z+="    Url = `https://spreadsheets.google.com/feeds/spreadsheets/private/full?alt=json`\xFE";
 z+="    header = [\"Content-Type: application/json\", \"Authorization: Bearer \":LoginInfo]\xFE";
 z+="    sdoc = @jsb_bf.Get(Url, \"GET\", Header, '')\xFE";
 z+="    \xFE";
 z+="    if IsNothing(sdoc) then\xFE";
 z+="BadJson:\xFE";
 z+="        success = false\xFE";
 z+="        return\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    On Error Goto BadJson\xFE";
 z+="    sDoc = JSON(sDoc)\xFE";
 z+="    On Error Goto 0\xFE";
 z+="    \xFE";
 z+="    Titles = []\xFE";
 z+="    IDs = []\xFE";
 z+="    \xFE";
 z+="    jc = sdoc.feed.entry\xFE";
 z+="    \xFE";
 z+="    for each item in jc\xFE";
 z+="        SpreadSheetTitle = item.title[\"$t\"]\xFE";
 z+="        SpreadSheetID = Field(item.id[\"$t\"], \"/full/\", 2)\xFE";
 z+="        \xFE";
 z+="        // Each SpreadSheet contains multiple workbooks (sheets)\xFE";
 z+="        Url = `https://sheets.googleapis.com/v4/spreadsheets/`:SpreadSheetID:`?alt=json`\xFE";
 z+="        header = [\"Content-Type: application/json\", \"Authorization: Bearer \":LoginInfo]\xFE";
 z+="        sdoc = @jsb_bf.Get(Url, \"GET\", Header, '')\xFE";
 z+="        sDoc = JSon(sDoc)\xFE";
 z+="        for each Sheet in sDoc.sheets\xFE";
 z+="           Sheetid = sheet.sheetId\xFE";
 z+="           Title = sheet.properties.title\xFE";
 z+="           Titles[-1] = trim(SpreadSheetTitle:\"*\":Title)\xFE";
 z+="           IDs[-1] = SpreadSheetID:\"*\":Title\xFE";
 z+="        next\xFE";
 z+="    next\xFE";
 z+="    \xFE";
 z+="    Results = Join(Titles, Chr(254))\xFE";
 z+="    IDs = Join(IDs, Chr(254))\xFE";
 z+="    \xFE";
 z+="    @Session.sheetTitles = LCase(Results)\xFE";
 z+="    @Session.sheetIDs = IDs\xFE";
 z+="    \xFE";
 z+="    Success = True\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="function sheets_getID(byval title)\xFE";
 z+="    title = trim(lcase(title))\xFE";
 z+="    Titles = @Session.sheetTitles\xFE";
 z+="\xFE";
 z+="    locate LCase(title) in Titles setting spot else return null\xFE";
 z+="    IDS = @Session.sheetIDs\xFE";
 z+="    return IDS<spot>\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="Sub sheets_Select(ByVal Cols, byval dbHandle, ByVal WhereClause, ByRef Success)\xFE";
 z+="    Call sheets_Select(Cols, dbHandle, WhereClause, Success, Results)\xFE";
 z+="    if Success Then FormList Results\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub sheets_SelectTo(ByVal Cols, byval dbHandle, ByVal WhereClause, ByRef SL, ByRef Success)\xFE";
 z+="    Call sheets_Select(Cols, dbHandle, WhereClause, Success, Results)\xFE";
 z+="    if Success Then FormList Results To SL\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub sheets_Select(ByVal Cols, byval dbHandle, ByVal WhereClause, ByRef Success, ByRef Results)\xFE";
 z+="    Call sheets_dropOldCache()\xFE";
 z+="    path = sheets_decodeHandle(dbHandle, LoginInfo)\xFE";
 z+="\xFE";
 z+="    Url = `https://api.sheetsapi.com/2/files/list_folder`\xFE";
 z+="    header = [\"Content-Type: application/json\" , \"Authorization: Bearer \":LoginInfo]\xFE";
 z+="    sdoc = @jsb_bf.Get(Url, \"POST\", Header, { path: \"/\":path })\xFE";
 z+="    if IsNothing(sdoc) then\xFE";
 z+="        success = false\xFE";
 z+="        return\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    Results = []\xFE";
 z+="    jc = JSon(sdoc).entries\xFE";
 z+="    for each item in jc\xFE";
 z+="        if item[\".tag\"] = \"file\" then Results[-1] = item.name\xFE";
 z+="    next\xFE";
 z+="    Success = True\xFE";
 z+="\xFE";
 z+="    if (!Cols And !WhereClause) Or (!Results) Then Return\xFE";
 z+="\xFE";
 z+="\xFE";
 z+="    debug\xFE";
 z+="\xFE";
 z+="    Call ParseSqlColumns(WhereClause, false, IgnoreColumns, WhereHasFunctions, WhereHasOperators, usesItemContent, hasOrderBy)\xFE";
 z+="    Call ParseSqlColumns(COLS, true, DisplayColumns, ColumnsHasFunctions, ColumnsHasOperators, usesItemContent, ignoreorderby)\xFE";
 z+="\xFE";
 z+="    ' Need to read all items into SelectedItems\xFE";
 z+="    if WhereClause then\xFE";
 z+="        if !filterJsonArray(SelectedItemIDs, SelectedItems, WhereClause) Then Success = False; Return\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    if ColumnsHasFunctions or ColumnsHasOperators then\xFE";
 z+="        ' This will create an item in TMP, compile it, and run it to get the results\xFE";
 z+="        if !processColumns(DisplayColumns, SelectedItems, SelectedItemIDs) Then Success = False; Return\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    Results = { SelectedItemIDs: SelectedItemIDs }\xFE";
 z+="    Results.SelectedItems = SelectedItems\xFE";
 z+="    Results.OnlyReturnItemIDs = COLS = \"\"\xFE";
 z+="\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub sheets_CreateFile(ByVal LoginInfo, byval dd, ByVal FName, ByRef Success)\xFE";
 z+="    Success = False\xFE";
 z+="    dd = lcase(dd)\xFE";
 z+="\xFE";
 z+="    if !dd or dd = \"data\" then\xFE";
 z+="        mt = sheets_isFolder(LoginInfo, fname)\xFE";
 z+="        if !mt then\xFE";
 z+="            if !IsNull(mt) then\xFE";
 z+="                @Errors = \"File already exists with the same name\"\xFE";
 z+="                return\xFE";
 z+="            end if\xFE";
 z+="\xFE";
 z+="            // create path\xFE";
 z+="            Url = `https://api.sheetsapi.com/2/files/create_folder`\xFE";
 z+="            header = [\"Content-Type: application/json\", \"Authorization: Bearer \":LoginInfo]\xFE";
 z+="            Item = @jsb_bf.Get(Url, \"POST\", Header, { path: \"/\":@UrlEncode(fname) })\xFE";
 z+="            if IsNothing(Item) Then Return\xFE";
 z+="        end if\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    if !dd or dd = \"dict\" then\xFE";
 z+="        // make sure jsb_dictionaries exists and create it if necessary\xFE";
 z+="        if !sheets_isFolder(LoginInfo, \"jsb_dictionaries\") then\xFE";
 z+="            // create directory\xFE";
 z+="            Url = `https://api.sheetsapi.com/2/files/create_folder`\xFE";
 z+="            header = [\"Content-Type: application/json\", \"Authorization: Bearer \":LoginInfo]\xFE";
 z+="            Item = @jsb_bf.Get(Url, \"POST\", Header, { path: \"/jsb_dictionaries\" } )\xFE";
 z+="            if IsNothing(Item) Then Return\xFE";
 z+="        end if\xFE";
 z+="\xFE";
 z+="        mt = sheets_isFolder(LoginInfo, \"jsb_dictionaries/\":fname)\xFE";
 z+="        if !sheets_isFolder(LoginInfo, \"jsb_dictionaries/\":fname) then\xFE";
 z+="            if !IsNull(mt) then\xFE";
 z+="                @Errors = \"File already exists with the same name\"\xFE";
 z+="                return\xFE";
 z+="            end if\xFE";
 z+="\xFE";
 z+="            // create path\xFE";
 z+="            Url = `https://api.sheetsapi.com/2/files/create_folder`\xFE";
 z+="            header = [\"Content-Type: application/json\", \"Authorization: Bearer \":LoginInfo]\xFE";
 z+="            Item = @jsb_bf.Get(Url, \"POST\", Header, { path: \"/jsb_dictionaries/\":fname })\xFE";
 z+="            if IsNothing(Item) Then Return\xFE";
 z+="        end if\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    Success = True\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub sheets_ReadJSon(Item, dbHandle, IName, Success)\xFE";
 z+="    Call sheets_ReadX(Item, dbHandle, IName, Success, \"JSon\")\xFE";
 z+="    If (Left(Item, 1) = \"{\" Or Left(Item, 1) = \"[\") And Success Then Item = JSon(item)\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub sheets_ReadJSonU(Item, dbHandle, IName, Success)\xFE";
 z+="    Call sheets_ReadX(Item, dbHandle, IName, Success, \"JSonU\")\xFE";
 z+="    If (Left(Item, 1) = \"{\" Or Left(Item, 1) = \"[\") And Success Then Item = JSon(item)\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub sheets_ReadXML(Item, dbHandle, IName, Success)\xFE";
 z+="    Call sheets_ReadX(Item, dbHandle, IName, Success, \"XML\")\xFE";
 z+="    If Left(Item, 1) = \"<\" And Success Then Item = XML(item)\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub sheets_ReadXMLU(Item, dbHandle, IName, Success)\xFE";
 z+="    Call sheets_ReadX(Item, dbHandle, IName, Success, \"XMLU\")\xFE";
 z+="    If Left(Item, 1) = \"<\" And Success Then Item = XML(item)\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub sheets_Read(Item, dbHandle, IName, Success)\xFE";
 z+="    Call sheets_ReadX(Item, dbHandle, IName, Success, \"\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub sheets_ReadU(Item, dbHandle, IName, Success)\xFE";
 z+="    Call sheets_ReadX(Item, dbHandle, IName, Success, \"U\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub sheets_ReadV(Item, dbHandle, IName, AtrNo, Success)\xFE";
 z+="    Call sheets_ReadX(Item, dbHandle, IName, Success, \"\")\xFE";
 z+="    If !Success Then Return\xFE";
 z+="    Item = Item<AtrNo>\xFE";
 z+="    Return\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub sheets_ReadVU(Item, dbHandle, IName, AtrNo, Success)\xFE";
 z+="    Call sheets_ReadX(Item, dbHandle, IName, Success, \"U\")\xFE";
 z+="    If !Success Then Return\xFE";
 z+="    Item = Item<AtrNo>\xFE";
 z+="    Return\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="function sheets_decodeHandle(dbHandle, loginInfo)\xFE";
 z+="    loginInfo = Field(dbHandle, VM(), 2)\xFE";
 z+="    return Field(dbHandle, VM(), 1)\xFE";
 z+="End function\xFE";
 z+="\xFE";
 z+="Sub sheets_ReadX(Item, dbHandle, IName, Success, Opts)\xFE";
 z+="    Item = \"\"\xFE";
 z+="    Success = False\xFE";
 z+="    Call sheets_dropOldCache()\xFE";
 z+="\xFE";
 z+="    path = sheets_decodeHandle(dbHandle, LoginInfo)\xFE";
 z+="\xFE";
 z+="    // Check Cache\xFE";
 z+="    Key = LCase(path:\"&&\":IName)\xFE";
 z+="    if @Session.sheets_cached_items[key] And Right(Opts, 1) <> \"U\" then \xFE";
 z+="        Success = True\xFE";
 z+="        Item = @Session.sheets_cached_items[key]\xFE";
 z+="        @Session.sheets_cached_timer[key] = timer()\xFE";
 z+="        Return\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    isFolder = sheets_isFolder(LoginInfo, Path:`/`:IName)\xFE";
 z+="    if isFolder then \xFE";
 z+="        @Errors = \"Attempted READ on directory\"\xFE";
 z+="        Return\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    // Not Found\xFE";
 z+="    if IsNull(isFolder) then \xFE";
 z+="        @Errors = ''\xFE";
 z+="        Return\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    // read the file\xFE";
 z+="    Url = `https://content.sheetsapi.com/2/files/download`\xFE";
 z+="    args = \"sheets-API-Arg: \": { path: `/`:Path:`/`:IName }\xFE";
 z+="\xFE";
 z+="    header = [\"Authorization: Bearer \":LoginInfo, \"Content-Type:\", args]\xFE";
 z+="\xFE";
 z+="    Item = @jsb_bf.Get(Url, \"POST\", Header, \"\")\xFE";
 z+="    if IsNothing(Item) Then Return\xFE";
 z+="\xFE";
 z+="    Select Case Opts\xFE";
 z+="        Case \"JSon\", \"JSonU\"\xFE";
 z+="            On Error Goto ErrOut\xFE";
 z+="            Item = json(Item)\xFE";
 z+="\xFE";
 z+="        Case \"XML\", \"XMLU\"\xFE";
 z+="            On Error Goto ErrOut\xFE";
 z+="            Item = xml(Item)\xFE";
 z+="    End Select\xFE";
 z+="\xFE";
 z+="    @Session.sheets_cached_items[key] = Item\xFE";
 z+="    @Session.sheets_cached_timer[key] = timer()\xFE";
 z+="    Success = True\xFE";
 z+="\xFE";
 z+="errout: \xFE";
 z+="    Return\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub sheets_dropOldCache()\xFE";
 z+="    if !@Session.sheets_cached_items Then @Session.sheets_cached_items = {}\xFE";
 z+="    if !@Session.sheets_cached_timer Then @Session.sheets_cached_timer = {}\xFE";
 z+="\xFE";
 z+="    For Each CKey In @Session.sheets_cached_items\xFE";
 z+="        If CKey Then\xFE";
 z+="            If @Session.sheets_cached_timer[Ckey] + 1000 < timer() Then\xFE";
 z+="                Remove @Session.sheets_cached_items, CKey\xFE";
 z+="                Remove @Session.sheets_cached_timer, CKey\xFE";
 z+="            End If\xFE";
 z+="        End If\xFE";
 z+="    Next\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub sheets_DeleteFile(byval dbHandle, Success)\xFE";
 z+="    Call sheets_dropOldCache()\xFE";
 z+="    path = sheets_decodeHandle(dbHandle, LoginInfo)\xFE";
 z+="\xFE";
 z+="    PKey = LCase(path:\"&&\")\xFE";
 z+="    For Each CKey In @Session.sheets_cached_items\xFE";
 z+="        If CKey Then\xFE";
 z+="            If Left(CKey, Len(Pkey)) = PKey Then \xFE";
 z+="                Remove @Session.sheets_cached_items, CKey\xFE";
 z+="                Remove @Session.sheets_cached_timer, CKey\xFE";
 z+="            end if\xFE";
 z+="        End If\xFE";
 z+="    Next\xFE";
 z+="\xFE";
 z+="    // delete the directory\xFE";
 z+="    Url = `https://api.sheetsapi.com/2/files/delete`\xFE";
 z+="    header = [\"Content-Type: application/json\", \"Authorization: Bearer \":LoginInfo]\xFE";
 z+="    Item = @jsb_bf.Get(Url, \"POST\", Header, { path: `/`:Path } )\xFE";
 z+="\xFE";
 z+="    if !Item Then \xFE";
 z+="        if header<1> = 404 then\xFE";
 z+="            success = True\xFE";
 z+="            return\xFE";
 z+="        end if\xFE";
 z+="        return\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    Success = True\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub sheets_ClearFile(byval dbHandle, Success)\xFE";
 z+="    Call sheets_DeleteFile(dbHandle, Success)\xFE";
 z+="    if !Success Then Return\xFE";
 z+="\xFE";
 z+="    Success = False\xFE";
 z+="    path = sheets_decodeHandle(dbHandle, LoginInfo)\xFE";
 z+="    Url = `https://api.sheetsapi.com/2/files/create_folder`\xFE";
 z+="    header = [\"Content-Type: application/json\", \"Authorization: Bearer \":LoginInfo]\xFE";
 z+="    Item = @jsb_bf.Get(Url, \"POST\", Header, { path: `/`:Path } )\xFE";
 z+="    if IsNothing(Item) Then Return\xFE";
 z+="    Success = True\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub sheets_DeleteItem(byval dbHandle, IName, Success)\xFE";
 z+="    path = sheets_decodeHandle(dbHandle, LoginInfo)\xFE";
 z+="    Success = False\xFE";
 z+="\xFE";
 z+="    Call sheets_dropOldCache()\xFE";
 z+="\xFE";
 z+="    Key = LCase(Path:\"&&\":IName)\xFE";
 z+="    if @Session.sheets_cached_items Then \xFE";
 z+="        Remove @Session.sheets_cached_items, Key\xFE";
 z+="        Remove @Session.sheets_cached_timer, Key\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    // delete the file\xFE";
 z+="    Url = `https://api.sheetsapi.com/2/files/delete`\xFE";
 z+="    header = [\"Content-Type: application/json\", \"Authorization: Bearer \":LoginInfo]\xFE";
 z+="    Item = @jsb_bf.Get(Url, \"POST\", Header, { path: `/`:Path:`/`:IName })\xFE";
 z+="\xFE";
 z+="    if !Item Then \xFE";
 z+="        if header<1> = 404 then\xFE";
 z+="            success = True\xFE";
 z+="            return\xFE";
 z+="        end if\xFE";
 z+="        return\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    Success = True\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub sheets_Write(byval Item, dbHandle, byval IName, Success)\xFE";
 z+="    Call sheets_WriteX(Item, dbHandle, IName, Success, \"\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub sheets_WriteU(Item, dbHandle, IName, Success)\xFE";
 z+="    Call sheets_WriteX(Item, dbHandle, IName, Success, \"U\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub sheets_WriteJSon(Item, dbHandle, IName, Success)\xFE";
 z+="    Call sheets_WriteX(Item, dbHandle, IName, Success, \"JSon\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub sheets_WriteJSonU(Item, dbHandle, IName, Success)\xFE";
 z+="    Call sheets_WriteX(Item, dbHandle, IName, Success, \"JSonU\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub sheets_WriteXml(Item, dbHandle, IName, Success)\xFE";
 z+="    Call sheets_WriteX(Item, dbHandle, IName, Success, \"Xml\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub sheets_WriteXmlU(Item, dbHandle, IName, Success)\xFE";
 z+="    Call sheets_WriteX(Item, dbHandle, IName, Success, \"XmlU\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub sheets_WriteX(byval Item, byval dbHandle, byval IName, Success, Opts)\xFE";
 z+="    Success = False\xFE";
 z+="    Call sheets_dropOldCache()\xFE";
 z+="\xFE";
 z+="    path = sheets_decodeHandle(dbHandle, LoginInfo)\xFE";
 z+="\xFE";
 z+="    // Check Cache\xFE";
 z+="    Key = LCase(path:\"&&\":IName)\xFE";
 z+="    if InStr(IName, \".\") Then Ext = RightField(IName, \".\") Else Ext = \"txt\"\xFE";
 z+="    mime_type = @mimeType(Ext)\xFE";
 z+="\xFE";
 z+="    // write a file\xFE";
 z+="\xFE";
 z+="    args = \"sheets-API-Arg: \": { path: `/`:Path:`/`:IName, mode: 'overwrite', autorename: false, mute: false }\xFE";
 z+="    Url = `https://content.sheetsapi.com/2/files/upload`\xFE";
 z+="    header = [\"Content-Type: application/octet-stream\", \"Authorization: Bearer \":LoginInfo, \"Accept: */*\", \"Accept-Encoding: gzip, deflate, br\", args]\xFE";
 z+="\xFE";
 z+="    NR = @jsb_bf.Get(Url, \"POST\", Header, Item)\xFE";
 z+="\xFE";
 z+="    If IsNothing(NR) Then Return\xFE";
 z+="\xFE";
 z+="    Success = True\xFE";
 z+="\xFE";
 z+="    * If the Commit for the WriteU later fails, we need to be sure to invalidate the cache\xFE";
 z+="    @Session.sheets_cached_items[key] = Item\xFE";
 z+="    @Session.sheets_cached_timer[key] = timer() \xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="\xFE";
 z+="// **************************************** OAUTH for Google below **************************************** \xFE";
 z+="// **************************************** OAUTH for Google below **************************************** \xFE";
 z+="// **************************************** OAUTH for Google below **************************************** \xFE";
 z+="\xFE";
 z+="function sheets_ClientID()\xFE";
 z+="    return \"557076037317-3pa0u9tb4e5otbom0corauebh8nimug9.apps.googleusercontent.com\" ;* JSB Client\xFE";
 z+="end function\xFE";
 z+="\xFE";
 z+="' This is only used on the server, not javascript client versions\xFE";
 z+="function sheets_ClientSecret()\xFE";
 z+="    read googleConfig from @fHandle('jsb_config'), 'google_Config' else return \"google app secret not setup in jsb_config google_Config (https://console.developers.google.com/apis/credentials/wizard?api=sheets.googleapis.com&project=json--basic)\"\xFE";
 z+="    return XTS(googleConfig<1>)\xFE";
 z+="\xFE";
 z+="// Returns @Errors and Empty LoginInfo on error\xFE";
 z+="Sub sheets_Login(LoginInfo, Provider, UserName, _Password, InitialDB)\xFE";
 z+="    LoginInfo = \"\"\xFE";
 z+="    \xFE";
 z+="    if system(1) = \"js\" then isPhoneGap = window.isPhoneGap()\xFE";
 z+="    \xFE";
 z+="    if isPhoneGap then state = \"atoken__\":@guid else state = @jsbRestCall(`sheets_oauthrtn`)\xFE";
 z+="    \xFE";
 z+="    scope = \"https://spreadsheets.google.com/feeds/ https://www.googleapis.com/auth/spreadsheets\" ;*  https://www.googleapis.com/auth/drive\"\xFE";
 z+="    \xFE";
 z+="    url = `https://accounts.google.com/o/oauth2/v2/auth?response_type=code&prompt=consent&scope=`:UrlEncode(scope):`&client_id=`:@sheets_ClientID:`&state=`:@UrlEncode(state) \xFE";
 z+="    if instr(@url, \":443\") Then\xFE";
 z+="        url := `&redirect_uri=`:UrlEncode(\"https://jsonbasic.azurewebsites.net:443/sysprog/sheets_redirect\")\xFE";
 z+="    else\xFE";
 z+="        url := `&redirect_uri=`:UrlEncode(\"https://jsonbasic.azurewebsites.net/sysprog/sheets_redirect\")\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    b = @response.buffer()\xFE";
 z+="    Print @hidden(\"accesstoken\", \"\"):\xFE";
 z+="    print @script(`\xFE";
 z+="        var winObj;\xFE";
 z+="        var url = \"`:url:`\"\xFE";
 z+="        \xFE";
 z+="        if (window.cordova) {\xFE";
 z+="            if (window.cordova.InAppBrowser) {\xFE";
 z+="                winObj = cordova.InAppBrowser.open(url, \"_blank\", \"location=yes\");\xFE";
 z+="            } else if (isMobile.Android) {\xFE";
 z+="                winObj = navigator.app.loadUrl(url, {openExternal:true});\xFE";
 z+="            } else {\xFE";
 z+="                winObj = window.open(url, \"_system\", \"location=yes\");\xFE";
 z+="            }\xFE";
 z+="        } else {\xFE";
 z+="            winObj = window.open(url, \"_blank\", \"location=yes\");\xFE";
 z+="        }\xFE";
 z+="        \xFE";
 z+="        function checkClosed() {\xFE";
 z+="            if (!winObj || winObj.closed || typeof winObj.closed=='undefined')  { \xFE";
 z+="                if (!window.cordova) doJsbSubmit(false) \xFE";
 z+="            } else setTimeout(checkClosed, 500); \xFE";
 z+="        }\xFE";
 z+="\xFE";
 z+="        checkClosed();\xFE";
 z+="    `):\xFE";
 z+="\xFE";
 z+="    @Session.at = \"\"\xFE";
 z+="    if system(1) = \"js\" then window.saveAtSession()\xFE";
 z+="    \xFE";
 z+="    // Make the call\xFE";
 z+="    if isPhoneGap then @Server.Flush Else @Server.Pause\xFE";
 z+="    @response.buffer(b)\xFE";
 z+="    \xFE";
 z+="    if system(1) = \"js\" then window.getAtSession()\xFE";
 z+="    LoginInfo = @Session.at\xFE";
 z+="    \xFE";
 z+="    if !LoginInfo Then\xFE";
 z+="        // Either the user canceled out, or we are on phonegap\xFE";
 z+="        if isPhoneGap Then\xFE";
 z+="            Sleep 2\xFE";
 z+="            Ans = MsgBox(\"After you have finished with Google Sheets, click here to continue.\")\xFE";
 z+="           \xFE";
 z+="            *Call the server, ask for our access token\xFE";
 z+="            Url = `https://jsonbasic.azurewebsites.net/sysprog/oauth_myToken?g=`:state ;* oauth_myToken is in dropbox code\xFE";
 z+="            R = @Get(Url)\xFE";
 z+="            \xFE";
 z+="            if !R then \xFE";
 z+="                @Errors = \"no result from server routine oauth_myToken\"\xFE";
 z+="                exit sub\xFE";
 z+="            end if\xFE";
 z+="\xFE";
 z+="            R = JSON(R)\xFE";
 z+="            if  r.key = \"nokey\" then\xFE";
 z+="                @Errors = \"user canceled out\"\xFE";
 z+="                exit sub\xFE";
 z+="            end if\xFE";
 z+="\xFE";
 z+="            // Return key\xFE";
 z+="            LoginInfo = r.key\xFE";
 z+="            exit sub\xFE";
 z+="        end if\xFE";
 z+="    else\xFE";
 z+="        @Errors = @session.at_errors\xFE";
 z+="        @session.at = \"\"\xFE";
 z+="    end if\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="// This server only routine is common for sheets since sheets requires a known url for the redirect.  \xFE";
 z+="program sheets_redirect\xFE";
 z+="    ' We should have two parameters: state and code.  We exchange the code for an access token and then rediect to state.\xFE";
 z+="    Code = @urlParam('code')\xFE";
 z+="    state = @urlParam('state')\xFE";
 z+="    \xFE";
 z+="    if !code or !state then Stop \"No No!\"\xFE";
 z+="\xFE";
 z+="    // convert to an access token\xFE";
 z+="    Url = `https://www.googleapis.com/oauth2/v4/token`\xFE";
 z+="    \xFE";
 z+="    _Body = `code=`:code\xFE";
 z+="    _Body := `&client_id=`:@sheets_ClientID\xFE";
 z+="    _Body := `&client_secret=`:@sheets_ClientSecret\xFE";
 z+="    _Body := `&redirect_uri=https://jsonbasic.azurewebsites.net/sysprog/sheets_redirect`\xFE";
 z+="    _Body := `&grant_type=authorization_code&`\xFE";
 z+="\xFE";
 z+="    sdoc = @jsb_bf.Get(Url, \"POST\", [\"application/x-www-form-urlencoded\"], _Body)\xFE";
 z+="    \xFE";
 z+="    if IsNothing(sdoc) then \xFE";
 z+="        access_token = \"\"\xFE";
 z+="        atErrors = @errors\xFE";
 z+="        token_type = \"errors\"\xFE";
 z+="    Else\xFE";
 z+="        j = JSon(sdoc)\xFE";
 z+="        access_token = j.access_token\xFE";
 z+="        atErrors = \"\"\xFE";
 z+="        token_type = j.token_type\xFE";
 z+="    end if\xFE";
 z+="\xFE";
 z+="    // Get us back to the correct version of code (aspx, phonegap, or js)\xFE";
 z+="    if left(state, 4) = \"http\" then\xFE";
 z+="        if InStr(state, \"?\") then state := \"&\" else state := \"?\"\xFE";
 z+="        @response.redirect(state:`access_token=`:access_token:`&token_type=`:token_type:`&uid=`:j.uid:`&atErrors=`:@UrlEncode(atErrors))\xFE";
 z+="\xFE";
 z+="    elseif field(state, \"_\", 1) = \"atoken\" then\xFE";
 z+="        * With phonegap, we are still in an external browser, so we need to record to the server, and fetch with a rest call\xFE";
 z+="        rec = access_token:AM():atErrors:AM():token_type\xFE";
 z+="        write rec on fhandle('tmp'), state\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    @Server.End\xFE";
 z+="end program\xFE";
 z+="\xFE";
 z+="// Store our access token and then be done (does not get called for phonegap version)\xFE";
 z+="// Store our access token and then be done (does not get called for phonegap version)\xFE";
 z+="program sheets_oauthrtn\xFE";
 z+="    @session.at = @urlParam('access_token')\xFE";
 z+="    @session.at_errors = @urlParam('errors')\xFE";
 z+="    @session.token_type = @urlParam('token_type')\xFE";
 z+="\xFE";
 z+="    if system(1) = \"js\" then \xFE";
 z+="        window.saveAtSession()\xFE";
 z+="        window.close()\xFE";
 z+="        if window.isPhoneGap() then\xFE";
 z+="            write @urlParam('access_token') on fhandle('tmp'), 'access_token' else stop @errors\xFE";
 z+="        end if\xFE";
 z+="    else\xFE";
 z+="        @response.redirect(@HtmlRoot:`close_html`)\xFE";
 z+="    end if\xFE";
 z+="end program\xFE";
 z+=""
window.cached_jsb_odb["sheets"]=z;
var z="\xFE";
 z+="// Sample code to use for building other protocol libraries\xFE";
 z+="//  Gives an example of caching\xFE";
 z+="\xFE";
 z+="sub hbd_db\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hbd_Open(ByVal LoginInfo, ByVal DictData, ByVal FName, ByRef fHandle, ByRef Success)\xFE";
 z+="    i_open dictdata, fname to fHandle Then Success = True Else Success = False\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hbd_CreateFile(ByVal LoginInfo, ByVal FileName, ByRef fHandle, ByRef Success)\xFE";
 z+="    Success = False\xFE";
 z+="    I_CreateFile FileName Then \xFE";
 z+="        i_open FileName To fHandle Then Success = True\xFE";
 z+="    End If\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hbd_ReadJSon(Item, fHandle, IName, Success)\xFE";
 z+="    Call hbd_ReadX(Item, fHandle, IName, Success, \"JSon\")\xFE";
 z+="    If (Left(Item, 1) = \"{\" Or Left(Item, 1) = \"[\") And Success Then Item = JSon(item)\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hbd_ReadJSonU(Item, fHandle, IName, Success)\xFE";
 z+="    Call hbd_ReadX(Item, fHandle, IName, Success, \"JSonU\")\xFE";
 z+="    If (Left(Item, 1) = \"{\" Or Left(Item, 1) = \"[\") And Success Then Item = JSon(item)\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hbd_ReadXML(Item, fHandle, IName, Success)\xFE";
 z+="    Call hbd_ReadX(Item, fHandle, IName, Success, \"XML\")\xFE";
 z+="    If Left(Item, 1) = \"<\" And Success Then Item = XML(item)\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hbd_ReadXMLU(Item, fHandle, IName, Success)\xFE";
 z+="    Call hbd_ReadX(Item, fHandle, IName, Success, \"XMLU\")\xFE";
 z+="    If Left(Item, 1) = \"<\" And Success Then Item = XML(item)\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hbd_Read(Item, fHandle, IName, Success)\xFE";
 z+="    Call hbd_ReadX(Item, fHandle, IName, Success, \"\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hbd_ReadU(Item, fHandle, IName, Success)\xFE";
 z+="    Call hbd_ReadX(Item, fHandle, IName, Success, \"U\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hbd_ReadV(Item, fHandle, IName, AtrNo, Success)\xFE";
 z+="    Call hbd_ReadX(Item, fHandle, IName, Success, \"\")\xFE";
 z+="    If !Success Then Return\xFE";
 z+="    Item = Item<AtrNo>\xFE";
 z+="    Return\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hbd_ReadVU(Item, fHandle, IName, AtrNo, Success)\xFE";
 z+="    Call hbd_ReadX(Item, fHandle, IName, Success, \"U\")\xFE";
 z+="    If !Success Then Return\xFE";
 z+="    Item = Item<AtrNo>\xFE";
 z+="    Return\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hbd_ReadX(Item, byval fHandle, IName, Success, RType)\xFE";
 z+="    Item = \"\"\xFE";
 z+="\xFE";
 z+="    Call hbd_dropOldCache()\xFE";
 z+="    Key = LCase(Replace(fHandle, VM(), \"**\"):\"&&\":IName)\xFE";
 z+="\xFE";
 z+="    if @Session.hbd_cached_items[key] And Right(RType, 1) <> \"U\" then \xFE";
 z+="        Success = True\xFE";
 z+="        Item = @Session.hbd_cached_items[key]\xFE";
 z+="        @Session.hbd_cached_timer[key] = timer()\xFE";
 z+="        Return\xFE";
 z+="    End If\xFE";
 z+="\xFE";
 z+="    fHandle = hbd_reopen(fHandle)\xFE";
 z+="    Select Case RType\xFE";
 z+="       Case \"U\"\xFE";
 z+="           I_ReadU Item From fHandle, IName Then Success = True Else Success = False\xFE";
 z+="           \xFE";
 z+="       Case \"JSon\"\xFE";
 z+="           I_ReadJSon Item From fHandle, IName Then Success = True Else Success = False\xFE";
 z+="           \xFE";
 z+="       Case \"JSonU\"\xFE";
 z+="           I_ReadJSonU Item From fHandle, IName Then Success = True Else Success = False\xFE";
 z+="           \xFE";
 z+="       Case \"XML\"\xFE";
 z+="           I_ReadXML Item From fHandle, IName Then Success = True Else Success = False\xFE";
 z+="           \xFE";
 z+="       Case \"XMLU\"\xFE";
 z+="           I_ReadXMLU Item From fHandle, IName Then Success = True Else Success = False\xFE";
 z+="           \xFE";
 z+="       Case Else\xFE";
 z+="           I_Read Item From fHandle, IName Then Success = True Else Success = False\xFE";
 z+="    End Select\xFE";
 z+="    \xFE";
 z+="    If !Success Then Return\xFE";
 z+="    \xFE";
 z+="    @Session.hbd_cached_items[key] = Item\xFE";
 z+="    @Session.hbd_cached_timer[key] = timer()\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hbd_dropOldCache()\xFE";
 z+="    if !@Session.hbd_cached_items Then @Session.hbd_cached_items = {}\xFE";
 z+="    if !@Session.hbd_cached_timer Then @Session.hbd_cached_timer = {}\xFE";
 z+="    \xFE";
 z+="    For Each CKey In @Session.hbd_cached_items\xFE";
 z+="        If CKey Then\xFE";
 z+="            If @Session.hbd_cached_timer[Ckey] + 1000 < timer() Then\xFE";
 z+="                Remove @Session.hbd_cached_items, CKey\xFE";
 z+="                Remove @Session.hbd_cached_timer, CKey\xFE";
 z+="            End If\xFE";
 z+="        End If\xFE";
 z+="    Next\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hbd_ListFiles(ByVal LoginInfo, ByRef Result, ByRef Success)\xFE";
 z+="    Call hbd_dropOldCache()\xFE";
 z+="    I_ListFiles To Result Else Result = \"\"\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hbd_DeleteFile(byval fHandle, Success)\xFE";
 z+="    Call hbd_dropOldCache()\xFE";
 z+="    \xFE";
 z+="    PKey = LCase(Replace(fHandle, VM(), \"**\"):\"&&\")\xFE";
 z+="    For Each CKey In @Session.hbd_cached_items\xFE";
 z+="        If CKey Then\xFE";
 z+="            If Left(CKey, Len(Pkey)) = PKey Then \xFE";
 z+="                Remove @Session.hbd_cached_items, CKey\xFE";
 z+="                Remove @Session.hbd_cached_timer, CKey\xFE";
 z+="            end if\xFE";
 z+="        End If\xFE";
 z+="    Next\xFE";
 z+="    \xFE";
 z+="    fHandle = hbd_reopen(fHandle)\xFE";
 z+="    I_DeleteFile fHandle Then Success = 1 Else Success = 0\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hbd_ClearFile(byval fHandle, Success)\xFE";
 z+="    Call hbd_dropOldCache()\xFE";
 z+="    \xFE";
 z+="    PKey = LCase(Replace(fHandle, VM(), \"**\"):\"&&\")\xFE";
 z+="    For Each CKey In @Session.hbd_cached_items\xFE";
 z+="        If CKey Then\xFE";
 z+="            If Left(CKey, Len(Pkey)) = PKey Then \xFE";
 z+="                Remove @Session.hbd_cached_items, CKey\xFE";
 z+="                Remove @Session.hbd_cached_timer, CKey\xFE";
 z+="            end if\xFE";
 z+="        End If\xFE";
 z+="    Next\xFE";
 z+="\xFE";
 z+="    fHandle = hbd_reopen(fHandle)\xFE";
 z+="    I_ClearFile fHandle Then Success = 1 Else Success = 0\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hbd_DeleteItem(byval fHandle, IName, Success)\xFE";
 z+="    Call hbd_dropOldCache()\xFE";
 z+="    \xFE";
 z+="    Key = LCase(Replace(fHandle, VM(), \"**\"):\"&&\":IName)\xFE";
 z+="    if @Session.hbd_cached_items Then \xFE";
 z+="        Remove @Session.hbd_cached_items, Key\xFE";
 z+="        Remove @Session.hbd_cached_timer, Key\xFE";
 z+="    end if\xFE";
 z+="    \xFE";
 z+="    fHandle = hbd_reopen(fHandle)\xFE";
 z+="    I_Delete fHandle, IName Then Success = 1 Else Success = 0\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hbd_Select(Cols, byval fHandle, WhereClause, Success)\xFE";
 z+="    fHandle = hbd_reopen(fHandle)\xFE";
 z+="    I_Select Cols from fHandle where WhereClause Then Success = 1 Else Success = 0\xFE";
 z+="    ' If Success Then FormList Results\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hbd_SelectTo(Cols, byval fHandle, WhereClause, SL, Success)\xFE";
 z+="    fHandle = hbd_reopen(fHandle)\xFE";
 z+="    I_Select cols from fHandle where WhereClause to SL Then Success = 1 Else Success = 0\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hbd_Write(byval Item, fHandle, byval IName, Success)\xFE";
 z+="    Call hbd_WriteX(Item, fHandle, IName, Success, \"\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hbd_WriteU(Item, fHandle, IName, Success)\xFE";
 z+="    Call hbd_WriteX(Item, fHandle, IName, Success, \"U\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hbd_WriteJSon(Item, fHandle, IName, Success)\xFE";
 z+="    Call hbd_WriteX(Item, fHandle, IName, Success, \"JSon\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hbd_WriteJSonU(Item, fHandle, IName, Success)\xFE";
 z+="    Call hbd_WriteX(Item, fHandle, IName, Success, \"JSonU\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hbd_WriteXml(Item, fHandle, IName, Success)\xFE";
 z+="    Call hbd_WriteX(Item, fHandle, IName, Success, \"Xml\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hbd_WriteXmlU(Item, fHandle, IName, Success)\xFE";
 z+="    Call hbd_WriteX(Item, fHandle, IName, Success, \"XmlU\")\xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="Sub hbd_WriteX(byval Item, byval fHandle, byval IName, Success, wType)\xFE";
 z+="    Call hbd_dropOldCache()\xFE";
 z+="    \xFE";
 z+="    Key = LCase(Replace(fHandle, VM(), \"**\"):\"&&\":IName)\xFE";
 z+="    \xFE";
 z+="    fHandle = hbd_reopen(fHandle)\xFE";
 z+="    Select Case wType\xFE";
 z+="       Case \"U\"\xFE";
 z+="           I_WriteU Item On fHandle, IName Then Success = True Else Success = False\xFE";
 z+="           \xFE";
 z+="       Case \"JSon\"\xFE";
 z+="           I_WriteJSon Item On fHandle, IName Then Success = True Else Success = False\xFE";
 z+="           \xFE";
 z+="       Case \"JSonU\"\xFE";
 z+="           I_WriteJSONU Item On fHandle, IName Then Success = True Else Success = False\xFE";
 z+="           \xFE";
 z+="       Case \"XML\"\xFE";
 z+="           I_WriteXML Item On fHandle, IName Then Success = True Else Success = False\xFE";
 z+="           \xFE";
 z+="       Case \"XMLU\"\xFE";
 z+="           I_WriteXMLU Item On fHandle, IName Then Success = True Else Success = False\xFE";
 z+="           \xFE";
 z+="       Case Else\xFE";
 z+="           I_Write Item On fHandle, IName Then Success = True Else Success = False\xFE";
 z+="    End Select\xFE";
 z+="    \xFE";
 z+="    If !Success Then Return\xFE";
 z+="\xFE";
 z+="    * If the Commit for the WriteU later fails, we need to be sure to invalidate the cache\xFE";
 z+="    @Session.hbd_cached_items[key] = Item\xFE";
 z+="    @Session.hbd_cached_timer[key] = timer() \xFE";
 z+="End Sub\xFE";
 z+="\xFE";
 z+="function hbd_reopen(fHandle)\xFE";
 z+="    if System(1) = \"aspx\" Then\xFE";
 z+="        open DropLeft(fHandle, \":\") to nHandle Then fHandle = nHandle\xFE";
 z+="    End If\xFE";
 z+="    return fHandle\xFE";
 z+="end function\xFE";
 z+=""
window.cached_jsb_odb["template_db"]=z;
}
anonymousFunc()
anonymousFunc = null